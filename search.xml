<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>OS 复习笔记</title>
    <url>/2024/11/06/OS-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1><span id="第七章-内存管理">第七章 内存管理</span></h1><h2><span id="一-内存管理的功能">一、内存管理的功能</span></h2><h3><span id="1内存分配的三种基本形式">1.内存分配的三种基本形式</span></h3><p><strong>（1）直接指定方式——编写程序时确定地址</strong></p>
<p><strong>（2）静态分配方式——程序装入内存时确定地址</strong></p>
<p>编译器编译的目标程序都采用从0开始的编址方式。</p>
<p><strong>（3）动态分配方式——程序执行时确定地址</strong></p>
<p>可以接受不可预测的分配和释放内存区域的请求，实现个别存储区域的分配和回收。</p>
<h3><span id="2地址变换">2.地址变换</span></h3><p><strong>（1）地址空间</strong></p>
<p>程序编译后，从0开始，称为逻辑地址，其集合为地址空间。</p>
<p>由计算机体系结构决定，如16位地址范围64kb，32位地址范围4gb。</p>
<p><strong>（2）存储空间</strong></p>
<p>程序在主存中实际位置称为物理地址，其集合为存储空间。</p>
<p>大小由计算机的内存决定。</p>
<p><strong>（3）地址转换</strong></p>
<p>逻辑地址到物理地址的转换，又叫重定位。</p>
<h3><span id="3存储保护">3.存储保护</span></h3><p><strong>（1）地址保护</strong></p>
<p>一个进程中的程序通常不能跳转到另一个进程的指令地址上去。</p>
<p><strong>（2）权限保护</strong></p>
<p>对于不同的进程有不同的存取权限。</p>
<p>4.存储共享</p>
<p>（1）允许每个进程访问该程序同一个副本</p>
<p>（2）让每个进程有自己单独的副本</p>
<h3><span id="5存储扩充">5.存储扩充</span></h3><p><strong>（1）请求调入功能</strong></p>
<p>把程序的一部分装入内存，使其先运行，在运行的过程中随时请求操作系统把需要的部分调入内存。</p>
<p><strong>（2）置换功能</strong></p>
<p>把不需要的部分换出主存，以装载需要的部分。（需要外存支持）</p>
<h2><span id="二-连续分配方式">二、连续分配方式</span></h2><p>1.单一连续分配</p>
<p>出现在单道程序系统中。</p>
<h3><span id="2固定分区分配">2.固定分区分配</span></h3><p><strong>（1）特点</strong></p>
<ul>
<li>操作系统初始化时把内存空间划分多个分区</li>
<li>运行时不改变，这种机制称为固定分区分配</li>
</ul>
<p><strong>（2）划分固定分区的两种方法</strong></p>
<ul>
<li>分区大小相同</li>
<li>分区大小不同</li>
</ul>
<p><strong>（3）优点：</strong>简单</p>
<p><strong>缺点：</strong>内存利用率低，会产生很多内碎片</p>
<h3><span id="3动态分区分配按需分配">3.动态分区分配——按需分配</span></h3><p><strong>（1）特点</strong></p>
<ul>
<li>事先不划定大小</li>
<li>根据进程大小动态分配内存空间</li>
</ul>
<p><strong>（2）分配策略</strong>（重要）</p>
<ul>
<li>首次适应算法：从链表的开头开始查找</li>
<li>下次适应算法：对首次适应算法的改动，从上次查找停止的位置开始查找</li>
<li>最佳适应算法：<strong>查找时间最长，产生最多外碎片</strong></li>
<li>最坏适应算法：使用当前可用的最大分区</li>
</ul>
<p><strong>排序：首次&gt;下次&gt;最坏&gt;最佳</strong></p>
<p><img src="/2024/11/06/OS-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241106030021302-1730835186457-1.png" alt="image-20241106030021302"></p>
<p><img src="/2024/11/06/OS-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241106030042521-1730835198918-3.png" alt="image-20241106030042521"></p>
<p><img src="/2024/11/06/OS-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241106030056654-1730835211197-5.png" alt="image-20241106030056654"></p>
<p><img src="/2024/11/06/OS-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241106030140820-1730835216988-7.png" alt="image-20241106030140820"></p>
<h2><span id="三-交换和覆盖">三、交换和覆盖</span></h2><h2><span id="四-基本分页分配方式">四、基本分页分配方式</span></h2><p><strong>分区分配方式的缺点：</strong></p>
<ul>
<li>会遗留很多碎片</li>
<li>要求连续的较大的空间</li>
</ul>
<p><strong>当前操作系统全部采用基本分页分配方式。</strong></p>
<h3><span id="1页面相关概念">1.页面相关概念</span></h3><p><strong>（1）页面：</strong></p>
<p>分页存储管理是将作业的逻辑地址划分成一系列同等大小的部分，称为页。</p>
<p>每个作业的页的编号都是从0开始。</p>
<p>把可用的物理内存也划分成同样大小的连续的部分，称为块。</p>
<p>先有块，才有页。</p>
<p><strong>（2）地址结构：</strong></p>
<p>由页号和页内偏移量组成。</p>
<p>2^10&#x3D;1K     2^11&#x3D;2K     2^12&#x3D;4K    2^20&#x3D;1M</p>
<p><img src="/2024/11/06/OS-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241106031044737-1730835231317-9.png" alt="image-20241106031044737"></p>
<h2><span id="2计算重要">2.计算（重要）</span></h2><h4><span id="1若逻辑地址a十进制页大小l">（1）<strong>若逻辑地址A（十进制），页大小L</strong></span></h4><p>①页号p&#x3D; INT（A&#x2F;L)</p>
<p>②页内偏移w&#x3D; (A mod L)</p>
<h4><span id="2若逻辑地址a八x2f十六进制页面大小为l">（2）<strong>若逻辑地址A（八&#x2F;十六进制），页面大小为L</strong></span></h4><p>①先把逻辑地址A转换成二进制；</p>
<p>②计算页面大小L在地址结构中占的位数l；</p>
<p>③右侧数0 ~ l-1位为偏移量；</p>
<p>④右侧数第 l 位开始为页号。</p>
<h4><span id="3逻辑地址a转物理地址">（3）<strong>逻辑地址A转物理地址</strong></span></h4><p>若逻辑地址为十进制数，则用页号p&#x3D;INT(A&#x2F;页大小L), 页内偏移量w&#x3D;AmodL，找页表块 号，</p>
<p>块号大小+偏移量&#x3D;物理地址 </p>
<p>若为八进制&#x2F;十六进制，则转为二进制，然后根据页大小L从右往左取位数，取页内偏移量 和页号，找页表块号，</p>
<p>块号大小+偏移量&#x3D;物理地址</p>
<p><img src="/2024/11/06/OS-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241106032228541-1730835249284-11.png" alt="image-20241106032228541"></p>
<h3><span id="3页面大小">3.页面大小</span></h3><p>页数&#x3D;文件大小&#x2F;页面大小</p>
<p>页表文件大小&#x3D;页数*块号大小</p>
<p>页表文件页数&#x3D;页面大小&#x2F;页表文件大小</p>
<h4><span id="1分页存储管理所造成的资源消耗"><strong>（1）分页存储管理所造成的资源消耗</strong></span></h4><ul>
<li><strong>内存资源：</strong>页表需要保存在内存中，占用内存资源 </li>
<li><strong>运行性能：</strong>获取指令的过程中需要多次访问内存（至少2次！）</li>
</ul>
<p><strong>（2）把页表页看成普通的文件，对它进行离散的分配，即对页表再分页，由此形成多级页表 的思想。</strong></p>
<p><strong>（3）最优页面大小公式：</strong></p>
<p> <strong>p&#x3D;根号（2es）</strong> </p>
<p>页面大小p，每个页表项需要e字节，平均进程大小是s字节</p>
<h2><span id="五-基本分段分配方式">五、基本分段分配方式</span></h2><h4><span id="1引入分段的必要性">1.<strong>引入分段的必要性</strong></span></h4><p>逻辑上完整</p>
<p>动态增长</p>
<p>动态链接</p>
<p>信息共享</p>
<p>信息保护</p>
<h4><span id="2地址变换机构">2.地址变换机构</span></h4><ul>
<li>由逻辑地址得到段号，段内地址；</li>
<li>段号与段表寄存器中的段长度比较，检查是否越界；</li>
<li>由段表始址、段号找到对应段表项；</li>
<li>检查段表中记录的段长，<strong>检查段内地址是否越界</strong>（区分页表的一点）；</li>
<li>由段表中“基址+段内地址”得到最终的物理地址；</li>
<li>访问目标单元；</li>
</ul>
<h4><span id="例题">例题</span></h4><p>在分段系统中，段表如下所示，请将逻辑地址（0，337），（1，5000），（2，3609），（5，1230）转换为物理地址。</p>
<p>段号	内存地址	段长<br>0	         50K	10K<br>1	         60K	3K<br>2	         70K	5K<br>3	        120K	8K<br>4	        150K	4K<br>（1）段号0小于段表长5，段号合法；根据段表第0项可知段表的内存始址为50K，段长为10K；由于段内地址337小于段长10K，故段内地址也是合法的。因此可以得出对应物理地址为50K+337&#x3D;51537；</p>
<p>（2）段号1小于段表长5，段号合法；根据段表第1项可知段表的内存始址为60K，段长为3K；经检查，段内地址5000超过段长3K，因此产生越界中断；</p>
<p>（3）段号2小于段表长5，段号合法；根据段表第2项可知段表的内存始址为70K，段长为5K；由于段内地址3609小于段长5K，故段内地址也是合法的。因此可以得出对应物理地址为70K+3609&#x3D;75289；</p>
<p>（4）段号不合法，产生越界中断；</p>
<h4><span id="3分页与分段的区别">3.分页与分段的区别</span></h4><ul>
<li>页是信息的物理单位，段是信息的逻辑单位；</li>
<li>页是系统的，段是用户的；</li>
<li>页的大小是固定的，段的长度是不固定的；</li>
<li>分页的地址空间是一维的，分段的地址空间是二维的；</li>
<li>页存在内碎片，段存在外碎片。</li>
</ul>
<h1><span id="第八章-虚拟存储管理">第八章 虚拟存储管理</span></h1><h2><span id="一-虚拟存储器">一、虚拟存储器</span></h2><h3><span id="1为什么需要虚拟存储器">1.为什么需要虚拟存储器</span></h3><p>(1) 用户地址空间可以大于物理内存空间 </p>
<p>(2) 内存尽可能保存多个进程——提高并发性（提高CPU利用率）</p>
<h3><span id="2虚拟存储器">2.虚拟存储器</span></h3><p>通过<strong>请求调入功能</strong>和<strong>置换功能</strong>，能从<strong>逻辑上</strong>对内存容量加以<strong>扩充</strong>的一种存储器系统（基于程序局部性原理）</p>
<h3><span id="3虚拟存储器的特点">3.虚拟存储器的特点</span></h3><ul>
<li><strong>多次性：</strong>一个进程的数据会多次装入内存</li>
<li><strong>对换性：</strong>允许一个程序在运行过程中从内存换入和换出</li>
<li><strong>虚拟性：</strong>未改变系统中内存物理的大小</li>
</ul>
<p>4.需要解决的问题</p>
<p>地址映射、分配策略、置换策略、装载控制</p>
<h2><span id="二-请求页式分配">二、请求页式分配</span></h2><h3><span id="1请求分页">1.请求分页</span></h3><p>在基本分页的基础上增加请求调页和页面置换功能的一种存储分配策略 </p>
<p>(1) 在进程开始运行前，不是装入全部页面，而是装入几个页面 </p>
<p>(2) 根据进程运行的需要，动态装入其他页 </p>
<p>(3) 当内存空间已满，需要装入新页面，则需要置换算法淘汰某个页面</p>
<h3><span id="2结构">2.结构</span></h3><p><img src="/2024/11/06/OS-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20241122014844.png" alt="微信截图_20241122014844"></p>
<h3><span id="3缺页中断机构及特点">3.缺页中断机构及特点</span></h3><p>访问的页不在内存，产生一个<strong>缺页中断</strong>——状态位为0</p>
<p><strong>缺页中断特点</strong>：</p>
<ul>
<li>同样要经历中断步骤（硬件寄存器支持）</li>
<li>在指令执行期间产生</li>
<li>恢复执行被中断指令</li>
</ul>
<h3><span id="4内存分配策略">4.内存分配策略</span></h3><p>（1）内存分配要考虑的问题：</p>
<ul>
<li>分配进程物理块少，内存中进程数越多，进程缺页可能性很高。</li>
<li>进程分配的物理块超过一定数目后，给该进程分配更多的物理块对该进程的缺页率没有影响。</li>
</ul>
<p>（2）三种组合：</p>
<p>固定分配局部置换、可变分配局部置换、可变分配全局置换</p>
<p>（3）内存分配方法：</p>
<p>平均分配、按进程大小比例分配（bi&#x3D;pi&#x2F;p*m)、考虑优先级的分配算法</p>
<p>（4）影响缺页率的因素：</p>
<ul>
<li>分配的物理块数</li>
<li>置换算法</li>
<li>数据访问顺序</li>
</ul>
<h3><span id="5页面置换算法">5.页面置换算法</span></h3><h4><span id="1最优页面置换算法opt">（1）最优页面置换算法——OPT</span></h4><p>选择当前内存中最后一个用到的页并把它置换出去，<strong>往后推</strong></p>
<p><img src="/2024/11/06/OS-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241213004548764.png" alt="image-20241213004548764"></p>
<h4><span id="2先进先出置换算法fifo">（2）先进先出置换算法——FIFO</span></h4><p>选择最早进入内存的那一页并把它置换出去</p>
<p>产生<strong>Belady异常（物理块多反而缺页率增加）</strong></p>
<p><img src="/2024/11/06/OS-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241213004610988.png" alt="image-20241213004610988"></p>
<h4><span id="3最近最少使用置换算法lru">（3）最近最少使用置换算法——LRU</span></h4><p><img src="/2024/11/06/OS-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241213004634309.png" alt="image-20241213004634309"></p>
<h4><span id="4时钟算法">（4）时钟算法</span></h4><p>某一页首次装入内存时，使用位u置为1，当被使用时也置为1；</p>
<p>指针扫描，当扫描到这个页面，置为0；</p>
<p>当扫描到一个u&#x3D;0的物理块，这个物理块就被置换，指针继续移动一个格子。</p>
<p><img src="/2024/11/06/OS-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241213004728354.png" alt="image-20241213004728354"></p>
<h4><span id="5改进时钟算法">（5）改进时钟算法</span></h4><p>Clock只考虑了使用频率，未考虑是否修改。 故增加一个修改位w；</p>
<p>新装入页u&#x3D;1，w&#x3D;0； 找u&#x3D;0，w&#x3D;0 或 u&#x3D;0，w&#x3D;1的物理块替换</p>
<p>①扫描时不修改使用位，若找到u&#x3D;0，w&#x3D;0的，置换它； </p>
<p>②若未找到，再次扫描，找u&#x3D;0，w&#x3D;1的，置换它，并将期间遇到u&#x3D;1的都置0 </p>
<p>③若未找到，跳转①</p>
<h3><span id="6段页式分配方法">6.段页式分配方法</span></h3><p>（1）<strong>分页的优势</strong></p>
<ul>
<li>对程序员是透明的</li>
<li>消除外部碎片</li>
<li>大小固定相等，可开发出精致的存储管理算法</li>
</ul>
<p>（2）<strong>分段的优势</strong></p>
<ul>
<li>具有处理不断增长的数据结构的能力</li>
<li>无内碎片</li>
<li>段共享及保护操作容易</li>
<li>支持动态链接</li>
</ul>
<h3><span id="7工作集模型">7.工作集模型</span></h3><p>基本思想：</p>
<ul>
<li>一个进程当前正在使用的页面的集合称为它的工作集</li>
<li>如果在内存中装入的是整个工作集，进程的运行就不会产生很多缺页</li>
<li>若分配给进程的物理块太少，无法容纳下整个工作集，进程的运行会产生大量的缺页</li>
</ul>
<h3><span id="8伙伴策略原理">8.伙伴策略原理</span></h3><p>在进程提出存储请求时，Linux并不一定按照请求的块数进行分配，而是将大于、等于这个数目的最小2^i个块数进行分配。</p>
<p>例如要求3个块，则分配2^2&#x3D;4个块</p>
<p>（1）特点</p>
<ul>
<li>允许内部碎片的存在</li>
<li>外部碎片非常少</li>
<li>从空间区队列表中搜索空闲块的速度极快</li>
</ul>
<p>（2）分配和释放</p>
<p>内存可分配总量为1MB，请求和释放的序列为：A(100KB)→B(240KB)→C(64KB)→D(256KB)→B(240KB)→A(100KB)→E(75KB)→C(64KB)→E(75KB)→D(256KB)</p>
<p><img src="/2024/11/06/OS-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/51da8a3eea3ebae4c60146d92fc4671.jpg" alt="51da8a3eea3ebae4c60146d92fc4671"></p>
<h1><span id="第九章-设备管理不考大题">第九章 设备管理（不考大题）</span></h1><h2><span id="一-io系统">一、IO系统</span></h2><h3><span id="1设备的类别">1.设备的类别</span></h3><p>（1）使用特性</p>
<p><img src="/2024/11/06/OS-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241213010925611.png" alt="image-20241213010925611"></p>
<p>（2）系统观点——数据传输率</p>
<p>低速设备——键盘、</p>
<p>中速设备——打印机</p>
<p>高速设备——磁带、磁盘、光盘</p>
<p>（3）按系统观点——传输单位</p>
<p> 字符设备——不可寻址、I&#x2F;O中断驱动和传输率相对较低 </p>
<p> 块设备——可寻址、一般为DMA方式</p>
<p>（4）按系统观点——共享属性</p>
<p>独占设备——如打印机、磁带机等顺序设备。作为系统资源，也称为临界资源 </p>
<p> 共享设备——如磁盘可随机访问随机设备 </p>
<p> 虚拟设备——<strong>通过虚拟技术将独占设备变换成可共享逻辑设备，供多个进程同时访问</strong></p>
<p>（5）系统设备与用户设备 </p>
<p>系统设备（标准设备）——一些通用设备；</p>
<p>如键盘、 打印机以及文件存储设备等 </p>
<p>用户设备（非标准设备）——由用户自己安装配置后 ，由操作系统统一管理的设备；</p>
<p>如实时系统中的A&#x2F;D 、D&#x2F;A变换器、现场监控数码显示</p>
<h3><span id="2设备标识">2.设备标识</span></h3><p> <strong>3 个原因:</strong> </p>
<p>①类型与数量多，赋予绝对设备号 </p>
<p>② 并发性；编写程序时，不可能知道哪类哪台设备是可用的 </p>
<p>③ 使用的方便性；I&#x2F;O申请时，给出类型号、设备号（相对顺序），由系统进行“地址变换” （绝对设备号）</p>
<h3><span id="3io系统的结构">3.IO系统的结构</span></h3><p><strong>（1）总线结构</strong></p>
<p>由于规模不同，系统结构不尽相同: </p>
<ul>
<li>在微型计算机和小型计算机系统中大多采用了<strong>单总线 I&#x2F;O系统结构</strong> </li>
<li>一些中、大型计算机系统中，往往具有专门进行I&#x2F;O处理的通道（处理机），因而更多地采用了<strong>多总线</strong>多通道结构</li>
</ul>
<p><strong>（2）设备控制器</strong></p>
<p>作用：</p>
<ul>
<li>是CPU与IO设备之间的接口</li>
<li>根据主机发来的命令控制设备进行IO操作</li>
</ul>
<p>功能：</p>
<ul>
<li>接受命令并进行译码（控制寄存器）</li>
<li>进行数据交换（数据寄存器）</li>
<li>记录和报告设备状态（状态寄存器）</li>
</ul>
<h2><span id="二-io设备数据传输控制方式">二、IO设备数据传输控制方式</span></h2><h3><span id="1程序直接控制方式早期用户使用">1.程序直接控制方式——早期用户使用</span></h3><p>①用户直接编写I&#x2F;O指令程序控制输入输出</p>
<p>②要保持CPU与外设同步（由于速度差距）</p>
<p>（1）优点：CPU与外设通过状态信息得到同步，硬件简单。</p>
<p>（2）缺点：</p>
<ul>
<li>CPU不断读取状态寄存器信息，造成“忙等”。</li>
<li>CPU只能与一台设备交换数据,不能实现设备之间的并行工作。</li>
<li>传输完全在CPU控制之下，对外部出现异常事件无实时响应能力。</li>
</ul>
<p>(只适用于较简单的单片机系统）</p>
<h3><span id="2中断控制方式要求设备控制器应具备中断机构">2.中断控制方式——要求设备控制器应具备中断机构</span></h3><p>中断驱动方式仅适合于中、慢速设备。对于大批量成组数据交换，可以利用DMA和通道方式</p>
<p>（1）基本工作过程： </p>
<p>① CPU执行设备驱动程序，向控制器发启动指令 </p>
<p>② 控制器按照I&#x2F;O指令要求，启动并控制I&#x2F;O设备工作。CPU与外设是并行操作的。 </p>
<p>③ 输入就绪&#x2F;输出完成，控制器向CPU发中断信号。 </p>
<p>④ CPU接中断信号，保护现场，转中断处理程序。 </p>
<p>⑤ 中断处理程序完成后退出中断，恢复现场。</p>
<p> ⑥ 将控制转回被打断的执行位置。</p>
<p>（2）优点： </p>
<ul>
<li>CPU与外设、外设与外设可以并行工作，提高系统效率</li>
<li>具有实时响应能力，可应用于实时控制场合</li>
</ul>
<p>（3）弱点： </p>
<ul>
<li>完成一次I&#x2F;O要多次中断驱动</li>
<li>对各高速设备，或成组数据交换的问题——</li>
<li>一方面高速外设由于中断方式可能来不及响应而丢失数据</li>
<li>另一方面，成组数据交换多次地通过中断进行，也显得速度太慢</li>
</ul>
<h3><span id="3dma控制方式">3.DMA控制方式</span></h3><p>通道的引入：</p>
<ul>
<li>一个DMA控制器只能挂接少量的同类设备</li>
<li>一次一块+且地址连续，若多个块，就需要多次启动DMA，因而也产生了多次中断处理</li>
</ul>
<p>特点： </p>
<ul>
<li>数据在内存和设备之间直接传送，CPU不干预。 </li>
<li>一个数据块传输完，DMA向CPU发出一个中断请求。 </li>
<li>数据的传输控制完全由DMA控制器完成，速度快， 适合高速成组数据传输。 </li>
<li>数据块在传输过程中，CPU与外设并行工作，比中断控制方式的并行性高。</li>
</ul>
<h3><span id="4通道控制方式">4.通道控制方式</span></h3><p>特点：</p>
<ul>
<li>一次可以实现多个离散数据块的传输。</li>
<li>可通过指令实现对设备控制，如磁带反绕等。</li>
<li>可以实现较为复杂的I&#x2F;O控制。</li>
</ul>
<p><img src="/2024/11/06/OS-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241213012648214.png" alt="image-20241213012648214"></p>
<h2><span id="三-设备管理">三、设备管理</span></h2><p>①用户不可能掌握每一种设备的具体控制与操作</p>
<p>②由于系统的并发性也不允许用户直接控制各个设备的启动与操作</p>
<h3><span id="1设备管理的目标">1.设备管理的目标</span></h3><p>(1) 设备独立性：提供通用、一致、规范的使用接口，做到用户应用程序与实际物理设备无关 </p>
<p>(2) 提高系统整体效率：提高设备和CPU效率，如设备控制方式、缓冲技术</p>
<p><strong>可利用分层方法实现IO管理软件</strong></p>
<h3><span id="2io管理层次">2.IO管理层次</span></h3><p>（1）用户进程</p>
<p>（2）逻辑IO（独立于设备的软件）</p>
<p>（3）设备IO（设备驱动程序）</p>
<p>（4）中断控制程序（主机与IO设备接口）</p>
<h3><span id="3io-管理主要功能">3.IO 管理主要功能</span></h3><p>(1) 记录设备信息 </p>
<p>(2) 设备分配与再分配 </p>
<p>(3) 实施IO操作 </p>
<p>(4) 缓冲管理</p>
<h2><span id="四-缓冲">四、缓冲</span></h2><p>作用：</p>
<p>(1) 减少进程被阻塞的机会，以及设备和中断的次数 </p>
<p>(2) 缓解对存储管理模块的干扰 </p>
<p>(3) 缓解CPU和低速外设速度不匹配的矛盾，使数据处理速度提高</p>
<h2><span id="五-io软件设计">五、IO软件设计</span></h2><p> IO 软件层次 </p>
<p>(1) IO 中断处理设备 </p>
<p>(2) IO 设备驱动程序 </p>
<p>(3) 与设备无关的操作系统IO软件 </p>
<p>(4) 用户层IO软件</p>
<h2><span id="六-磁盘存储器管理">六、磁盘存储器管理</span></h2><p>扇区：IO传输和空间分配基本单位</p>
<h3><span id="1改善磁盘io速度">1.改善磁盘IO速度</span></h3><p>(1) 选硬件上性能指标高者 </p>
<p>(2) 根据IO请求采用适合的磁盘调度算法 </p>
<p>(3) 设置磁盘高速缓冲区</p>
<h3><span id="2确定一个扇区需要三个参数">2.确定一个扇区需要三个参数</span></h3><p>柱面号(磁道)、盘面号(磁头)和扇区号(三维地址物理形式)</p>
<p>对于数组A【i】【j】【k】</p>
<p>i&#x3D;磁道，j&#x3D;磁头，k&#x3D;扇区</p>
<h3><span id="3磁盘访问时间">3.磁盘访问时间</span></h3><p>寻道时间Ts&#x3D;启动磁盘的时间S + 移动磁道n条*m（低速0.3，高速0.1）</p>
<p>旋转延迟时间Tr &#x3D; 1 &#x2F;（2r）</p>
<p>传输时间Td&#x3D;每次读写的字节数b &#x2F;旋转速度r*一条磁道上的字节数N</p>
<p>平均访问时间Ta&#x3D;Ts + Tr + Td</p>
<h3><span id="4磁盘调度算法重点">4.磁盘调度算法（重点）</span></h3><p>(1) FCFS&#x2F;FIFO</p>
<p>优点：策略是公平的</p>
<p>缺点：大量进程访问者竞争一个磁盘，则性能接近于随机调度，性能很差 </p>
<p><img src="/2024/11/06/OS-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241213020114717.png" alt="image-20241213020114717"></p>
<p>(2) SSTF 最短寻道时间优先</p>
<p>策略——选择当前位置移动距离最短I&#x2F;O访问者</p>
<p>问题——每次选择距离最短者同时，忽略可能不断新I&#x2F;O请求进程加入到队列 中，使队列中距离远访问者总也得不到调度，产生所谓<strong>“饥饿”</strong>现象 </p>
<p><img src="/2024/11/06/OS-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241213020129155.png" alt="image-20241213020129155"></p>
<p>(3) SCAN </p>
<p>避免了饥饿现象。</p>
<p>由于这种算法使得磁臂移动规律颇似电梯的运动，因而也称为电梯算法 </p>
<p><img src="/2024/11/06/OS-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241213020201106.png" alt="image-20241213020201106"></p>
<p>(4) CSCAN </p>
<p>磁头”单向”读&#x2F;写运动</p>
<p><img src="/2024/11/06/OS-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241213020231735.png" alt="image-20241213020231735"></p>
]]></content>
      <tags>
        <tag>2024-2025-1课内笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>c++队列queue用法</title>
    <url>/2024/05/26/c-%E9%98%9F%E5%88%97queue%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#%E5%AE%9A%E4%B9%89">定义</a></li>
<li><a href="#%E4%B8%80-queue%E5%88%9D%E5%A7%8B%E5%8C%96">一、queue初始化</a></li>
<li><a href="#%E4%BA%8C-queue%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0">二、queue常用函数</a><ul>
<li><a href="#1%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0">1.常用函数</a></li>
<li><a href="#2%E5%87%BD%E6%95%B0%E8%BF%90%E7%94%A8%E7%A4%BA%E4%BE%8B">2.函数运用示例</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<p>[TOC]</p>
<h2><span id="定义">定义</span></h2><p>queue是一种容器转换器模板，调用#include&lt; queue&gt;即可使用队列类。</p>
<h2><span id="一-queue初始化">一、queue初始化</span></h2><p>queue&lt;Type, Container&gt; (&lt;数据类型，容器类型&gt;）<br>初始化时必须要有数据类型，容器可省略，省略时则默认为deque 类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">queue&lt;int&gt;q1;</span><br><span class="line"></span><br><span class="line">queue&lt;double&gt;q2; </span><br><span class="line"></span><br><span class="line">queue＜char＞q3；</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">queue＜char, list＜char＞＞q1；</span><br><span class="line">//用list容器实现的queue </span><br><span class="line"></span><br><span class="line">queue＜int, deque＜int＞＞q2；</span><br><span class="line"> //用deque容器实现的queue </span><br></pre></td></tr></table></figure>

<h2><span id="二-queue常用函数">二、queue常用函数</span></h2><h3><span id="1常用函数">1.常用函数</span></h3><ol>
<li>push() 在队尾插入一个元素</li>
<li>pop() 删除队列第一个元素</li>
<li>size() 返回队列中元素个数</li>
<li>empty() 如果队列空则返回true</li>
<li>front() 返回队列中的第一个元素</li>
<li>back() 返回队列中最后一个元素</li>
</ol>
<h3><span id="2函数运用示例">2.函数运用示例</span></h3><h4><span id="1push在队尾插入一个元素">（1）<strong>push（）在队尾插入一个元素</strong></span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">queue &lt;string&gt; q;</span><br><span class="line">   q.push(&quot;first&quot;);</span><br><span class="line">   q.push(&quot;second&quot;);</span><br><span class="line">   cout&lt;&lt;q.front()&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p>输出 first</p>
<h4><span id="2pop-将队列中最靠前位置的元素删除没有返回值">（2）<strong>pop() 将队列中最靠前位置的元素删除，没有返回值</strong></span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">queue &lt;string&gt; q;</span><br><span class="line">	q.push(&quot;first&quot;);</span><br><span class="line">	q.push(&quot;second&quot;);</span><br><span class="line">	q.pop();</span><br><span class="line">	cout&lt;&lt;q.front()&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p>输出 second</p>
<h4><span id="3size-返回队列中元素个数">（3）<strong>size() 返回队列中元素个数</strong></span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">queue &lt;string&gt; q;</span><br><span class="line">  q.push(&quot;first&quot;);</span><br><span class="line">  q.push(&quot;second&quot;);</span><br><span class="line">  cout&lt;&lt;q.size()&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p>输出2</p>
<h4><span id="4empty-如果队列空则返回true">（4）<strong>empty() 如果队列空则返回true</strong></span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">queue &lt;string&gt; q;</span><br><span class="line">    cout&lt;&lt;q.empty()&lt;&lt;endl;</span><br><span class="line">    q.push(&quot;first&quot;);</span><br><span class="line">    q.push(&quot;second&quot;);</span><br><span class="line">    cout&lt;&lt;q.empty()&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p>分别输出1和0</p>
<h4><span id="5front-返回队列中的第一个元素">（5）<strong>front() 返回队列中的第一个元素</strong></span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">queue &lt;string&gt; q;</span><br><span class="line">    q.push(&quot;first&quot;);</span><br><span class="line">    q.push(&quot;second&quot;);</span><br><span class="line">    cout&lt;&lt;q.front()&lt;&lt;endl;</span><br><span class="line">    q.pop();</span><br><span class="line">    cout&lt;&lt;q.front()&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p>第一行输出first；<br>第二行输出second</p>
<h4><span id="6back-返回队列中最后一个元素">（6）<strong>back() 返回队列中最后一个元素</strong></span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">queue &lt;string&gt; q;</span><br><span class="line">q.push(&quot;first&quot;);</span><br><span class="line">q.push(&quot;second&quot;);</span><br><span class="line">cout&lt;&lt;q.back()&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p>输出最后一个元素second</p>
]]></content>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>c++ map使用方法</title>
    <url>/2024/05/27/c-map%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>在浏览器上搜了一下相关的博文，整理了一部分相对基础的内容，有点难懂的另一部分等以后遇到案例了再重新整理</p>
<!-- toc -->

<ul>
<li><a href="#%E4%B8%80-%E8%AF%B4%E6%98%8E">一、说明</a><ul>
<li><a href="#1%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A">1.名词解释</a></li>
<li><a href="#2%E5%AE%9A%E4%B9%89">2.定义</a></li>
<li><a href="#3%E5%85%83%E7%B4%A0%E7%9A%84%E8%AE%BF%E9%97%AE">3.元素的访问</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0">二、常用函数</a><ul>
<li><a href="#1find">1.find()</a></li>
<li><a href="#2erase">2.erase()</a></li>
<li><a href="#3size">3.size()</a></li>
<li><a href="#4clear">4.clear()</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<p>[TOC]</p>
<h2><span id="一-说明">一、说明</span></h2><h3><span id="1名词解释">1.名词解释</span></h3><ul>
<li><p>map是STL的一个关联容器，它以&lt;key,value&gt;一对一的形式存储，且map的内部自建一个红黑树，使得其可以自动排序(在map内部一切都是有序的)</p>
</li>
<li><p>key可以时任意的数据类型，比如int,char，包括用户自定义数据类型</p>
</li>
<li><p>value是该key对应的存储的值</p>
</li>
</ul>
<p><img src="/2024/05/27/c-map%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/8697326-1c3bfc38aacd4611.webp" alt="8697326-1c3bfc38aacd4611"></p>
<h3><span id="2定义">2.定义</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">map&lt;typename1, typename2&gt; mp;</span><br><span class="line">//例子</span><br><span class="line">map&lt;int string&gt; mis;</span><br><span class="line">map&lt;string, string&gt;mss;</span><br><span class="line">map&lt;float,int&gt; mfi;</span><br><span class="line">map&lt;double,long&gt; mdl;</span><br><span class="line">map&lt;person, int&gt;mpi;//创建一个key为person型、value为int类型的map对象</span><br><span class="line">map&lt;string, int&gt; mp;</span><br></pre></td></tr></table></figure>

<p>注：如果是字符串到整型的映射，必须使用<strong>string</strong>而不能使用char数组。</p>
<h3><span id="3元素的访问">3.元素的访问</span></h3><h4><span id="1通过下标访问">（1）通过下标访问</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">map&lt;char, int&gt; mp;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    mp[&#x27;a&#x27;]=1;</span><br><span class="line">    mp[&#x27;c&#x27;]=2;    </span><br><span class="line">    cout&lt;&lt;mp[&#x27;c&#x27;];</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">返回：2</span><br></pre></td></tr></table></figure>

<h4><span id="2通过迭代器访问">（2）通过迭代器访问</span></h4><p>定义迭代器：</p>
<p>map&lt;typename1, typename2&gt;::iterator it;</p>
<p>map可以使用it-&gt;first来访问键，使用it-&gt;second来访问值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">map&lt;char, int&gt; mp;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    mp[&#x27;a&#x27;]=1;</span><br><span class="line">    mp[&#x27;c&#x27;]=2;    </span><br><span class="line">    mp[&#x27;b&#x27;]=3;</span><br><span class="line">    for(map&lt;char, int&gt;::iterator it=mp.begin();it!=mp.end();it++)&#123;</span><br><span class="line">        cout&lt;&lt;it-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;it-&gt;second&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">返回：</span><br><span class="line">a 1</span><br><span class="line">b 3</span><br><span class="line">c 2</span><br></pre></td></tr></table></figure>

<p><strong>map会以键从小到大的顺序自动排序</strong>，这种方法可以用于遍历</p>
<h2><span id="二-常用函数">二、常用函数</span></h2><h3><span id="1find">1.find()</span></h3><p>find（key）返回键值为key的映射的迭代器，时间复杂度为O（logN），N为map中映射的个数。</p>
<p>如果find()找不到，将返回NULL</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"> #include &lt;map&gt;</span><br><span class="line"> using namespace std;</span><br><span class="line"> map&lt;char, int&gt; mp;</span><br><span class="line"> int main()</span><br><span class="line"> &#123;</span><br><span class="line">     mp[&#x27;a&#x27;]=1;</span><br><span class="line">     mp[&#x27;c&#x27;]=2;    </span><br><span class="line">     mp[&#x27;b&#x27;]=3;</span><br><span class="line">     map&lt;char, int&gt;::iterator it=mp.find(&#x27;c&#x27;);</span><br><span class="line">     cout&lt;&lt;it-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;it-&gt;second;</span><br><span class="line">     return 0;</span><br><span class="line"> &#125;</span><br><span class="line">输出结果：</span><br><span class="line">c 2</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当map的第一个元素是int类型时候，可以这样操作</span><br><span class="line"></span><br><span class="line">map&lt;int, int&gt;mp1;</span><br><span class="line">int sum = 100;</span><br><span class="line">sum += mp1[10];//mp1中不存在关键字10，所以mp1返回的值为0，sum累加后是100</span><br><span class="line"></span><br><span class="line">map&lt;int,int&gt; mp2;</span><br><span class="line">mp2[20]++;//因关键字20不存在，增加一个关键字20，其值从0自增到1， 效果相当于mp2增加一个元素&lt;20,1&gt;</span><br></pre></td></tr></table></figure>



<h3><span id="2erase">2.erase()</span></h3><p>erase()可以删除单个元素，也可以删除一个区间的所有元素。</p>
<h4><span id="1删除单个元素">（1）删除单个元素</span></h4><p>mp.erase(it)，it为需要删除的元素的迭代器，时间复杂度为O(1)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> #include &lt;iostream&gt;</span><br><span class="line"> #include &lt;map&gt;</span><br><span class="line"> using namespace std;</span><br><span class="line"> map&lt;char, int&gt; mp;</span><br><span class="line"> int main()</span><br><span class="line"> &#123;</span><br><span class="line">     mp[&#x27;a&#x27;]=1;</span><br><span class="line">     mp[&#x27;c&#x27;]=2;    </span><br><span class="line">     mp[&#x27;b&#x27;]=3;</span><br><span class="line">     map&lt;char, int&gt;::iterator it=mp.find(&#x27;c&#x27;);</span><br><span class="line">     mp.erase(it);</span><br><span class="line">     for(map&lt;char, int&gt;::iterator it=mp.begin();it!=mp.end();it++)&#123;</span><br><span class="line">             cout&lt;&lt;it-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;it-&gt;second&lt;&lt;endl;</span><br><span class="line">     &#125;</span><br><span class="line">     return 0;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">a 1</span><br><span class="line"></span><br><span class="line">b 3</span><br></pre></td></tr></table></figure>

<p>mp.erase(key)，key为欲删除的映射的键。时间复杂度为O(logN)，N为map内元素的个数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> #include &lt;iostream&gt;</span><br><span class="line"> #include &lt;map&gt;</span><br><span class="line"> using namespace std;</span><br><span class="line"> map&lt;char, int&gt; mp;</span><br><span class="line"> int main()</span><br><span class="line"> &#123;</span><br><span class="line">     mp[&#x27;a&#x27;]=1;</span><br><span class="line">     mp[&#x27;c&#x27;]=2;    </span><br><span class="line">     mp[&#x27;b&#x27;]=3;</span><br><span class="line">     mp.erase(&#x27;c&#x27;);</span><br><span class="line">     for(map&lt;char, int&gt;::iterator it=mp.begin();it!=mp.end();it++)&#123;</span><br><span class="line">             cout&lt;&lt;it-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;it-&gt;second&lt;&lt;endl;</span><br><span class="line">     &#125;</span><br><span class="line">     return 0;</span><br><span class="line"> &#125;</span><br><span class="line">输出结果：</span><br><span class="line">a 1</span><br><span class="line"></span><br><span class="line">b 3</span><br></pre></td></tr></table></figure>

<h4><span id="2删除一个区间内的所有元素">（2）删除一个区间内的所有元素</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"> #include &lt;map&gt;</span><br><span class="line"> using namespace std;</span><br><span class="line"> map&lt;char, int&gt; mp;</span><br><span class="line"> int main()</span><br><span class="line"> &#123;</span><br><span class="line">     mp[&#x27;a&#x27;]=1;</span><br><span class="line">     mp[&#x27;c&#x27;]=2;    </span><br><span class="line">     mp[&#x27;b&#x27;]=3;</span><br><span class="line">     map&lt;char, int&gt;::iterator it=mp.find(&#x27;c&#x27;);    //令it指向键为c的值 </span><br><span class="line">     mp.erase(it, mp.end());    //删除it之后的所有映射 </span><br><span class="line">     for(map&lt;char, int&gt;::iterator it=mp.begin();it!=mp.end();it++)&#123;</span><br><span class="line">             cout&lt;&lt;it-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;it-&gt;second&lt;&lt;endl;</span><br><span class="line">     &#125;</span><br><span class="line">     return 0;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">a 1</span><br><span class="line"></span><br><span class="line">b 3　</span><br></pre></td></tr></table></figure>

<h3><span id="3size">3.size()</span></h3><p>size()用来获得map中映射的对数，时间复杂度为O(1)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> #include &lt;iostream&gt;</span><br><span class="line"> #include &lt;map&gt;</span><br><span class="line"> using namespace std;</span><br><span class="line"> map&lt;char, int&gt; mp;</span><br><span class="line"> int main()</span><br><span class="line"> &#123;</span><br><span class="line">     mp[&#x27;a&#x27;]=1;</span><br><span class="line">     mp[&#x27;c&#x27;]=2;    </span><br><span class="line">     mp[&#x27;b&#x27;]=3;</span><br><span class="line">     cout&lt;&lt;mp.size();</span><br><span class="line">     return 0;</span><br><span class="line"> &#125;</span><br><span class="line">输出结果：</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<h3><span id="4clear">4.clear()</span></h3><p>clear()用来清除map中的所有元素，时间复杂度为O(N)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> #include &lt;iostream&gt;</span><br><span class="line"> #include &lt;map&gt;</span><br><span class="line"> using namespace std;</span><br><span class="line"> map&lt;char, int&gt; mp;</span><br><span class="line"> int main()</span><br><span class="line"> &#123;</span><br><span class="line">     mp[&#x27;a&#x27;]=1;</span><br><span class="line">     mp[&#x27;c&#x27;]=2;    </span><br><span class="line">     mp[&#x27;b&#x27;]=3;</span><br><span class="line">     mp.clear();    //清空map </span><br><span class="line">     cout&lt;&lt;mp.size();</span><br><span class="line">     return 0;</span><br><span class="line"> &#125;</span><br><span class="line">输出结果：</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2024/03/11/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2><span id="quick-start">Quick Start</span></h2><h3><span id="create-a-new-post">Create a new post</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3><span id="run-server">Run server</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3><span id="generate-static-files">Generate static files</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3><span id="deploy-to-remote-sites">Deploy to remote sites</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>html与css基础</title>
    <url>/2024/06/30/html%E4%B8%8Ecss%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#%E6%A0%87%E7%AD%BE">标签</a><ul>
<li><a href="#%E6%96%87%E5%AD%97%E6%A0%87%E7%AD%BE-%E6%94%B9%E5%8F%98%E9%A2%9C%E8%89%B2">文字标签-改变颜色</a></li>
<li><a href="#%E5%9D%97%E6%A0%87%E7%AD%BE">块标签</a></li>
<li><a href="#%E5%9B%BE%E5%83%8F%E6%A0%87%E7%AD%BE">图像标签</a></li>
<li><a href="#%E8%B6%85%E9%93%BE%E6%8E%A5%E6%A0%87%E7%AD%BE">超链接标签</a></li>
<li><a href="#%E5%88%97%E8%A1%A8%E6%A0%87%E7%AD%BE">列表标签</a></li>
<li><a href="#%E8%A1%A8%E6%A0%BC%E6%A0%87%E7%AD%BE">表格标签</a></li>
<li><a href="#%E8%A1%A8%E5%8D%95%E6%A0%87%E7%AD%BE">表单标签</a></li>
<li><a href="#%E6%A1%86%E6%9E%B6%E6%A0%87%E7%AD%BE">框架标签</a></li>
<li><a href="#%E6%8C%89%E5%88%97">按列</a></li>
</ul>
</li>
<li><a href="#%E9%80%89%E6%8B%A9%E5%99%A8">选择器</a></li>
</ul>
<!-- tocstop -->

<p>[TOC]</p>
<h2><span id="标签">标签</span></h2><h3><span id="文字标签-改变颜色">文字标签-改变颜色</span></h3><p><img src="/2024/06/30/html%E4%B8%8Ecss%E5%9F%BA%E7%A1%80/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240630125858.jpg" alt="微信图片_20240630125858"></p>
<h3><span id="块标签">块标签</span></h3><p><img src="/2024/06/30/html%E4%B8%8Ecss%E5%9F%BA%E7%A1%80/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240630130017.jpg" alt="微信图片_20240630130017"></p>
<h3><span id="图像标签">图像标签</span></h3><p><img src="/2024/06/30/html%E4%B8%8Ecss%E5%9F%BA%E7%A1%80/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240630130133.jpg" alt="微信图片_20240630130133"></p>
<p><img src="/2024/06/30/html%E4%B8%8Ecss%E5%9F%BA%E7%A1%80/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240630130651.png" alt="微信截图_20240630130651"></p>
<h3><span id="超链接标签">超链接标签</span></h3><p><img src="/2024/06/30/html%E4%B8%8Ecss%E5%9F%BA%E7%A1%80/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240630130327.jpg" alt="微信图片_20240630130327"></p>
<p><img src="/2024/06/30/html%E4%B8%8Ecss%E5%9F%BA%E7%A1%80/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240630130558.png" alt="微信截图_20240630130558"></p>
<h3><span id="列表标签">列表标签</span></h3><p><img src="/2024/06/30/html%E4%B8%8Ecss%E5%9F%BA%E7%A1%80/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240630130207.jpg" alt="微信图片_20240630130207"></p>
<h3><span id="表格标签">表格标签</span></h3><p><img src="/2024/06/30/html%E4%B8%8Ecss%E5%9F%BA%E7%A1%80/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240630130801.jpg" alt="微信图片_20240630130801"></p>
<p><img src="/2024/06/30/html%E4%B8%8Ecss%E5%9F%BA%E7%A1%80/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240630130846.png" alt="微信截图_20240630130846"></p>
<h3><span id="表单标签">表单标签</span></h3><p><img src="/2024/06/30/html%E4%B8%8Ecss%E5%9F%BA%E7%A1%80/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240630142238.jpg" alt="微信图片_20240630142238"></p>
<p><img src="/2024/06/30/html%E4%B8%8Ecss%E5%9F%BA%E7%A1%80/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240630142328.png" alt="微信截图_20240630142328"></p>
<h3><span id="框架标签">框架标签</span></h3><h4><span id="按行">按行</span></h4><p><img src="/2024/06/30/html%E4%B8%8Ecss%E5%9F%BA%E7%A1%80/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240630143133.png" alt="微信截图_20240630143133"></p>
<h3><span id="按列">按列</span></h3><p><img src="/2024/06/30/html%E4%B8%8Ecss%E5%9F%BA%E7%A1%80/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240630143324.png" alt="微信截图_20240630143324"></p>
<p><img src="/2024/06/30/html%E4%B8%8Ecss%E5%9F%BA%E7%A1%80/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240630143109.jpg" alt="微信图片_20240630143109"></p>
<h2><span id="选择器">选择器</span></h2>]]></content>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>java面向对象设计 复习笔记</title>
    <url>/2024/11/08/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#%E7%AC%AC%E5%85%AD%E8%AE%B2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%9D%E6%AD%A5">第六讲 面向对象初步</a><ul>
<li><a href="#61-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">6.1 类和对象的基本概念</a><ul>
<li><a href="#611-%E4%BD%BF%E7%94%A8%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%9E%84%E9%80%A0%E5%AF%B9%E8%B1%A1">6.1.1 使用构造方法构造对象</a></li>
<li><a href="#612-%E9%80%9A%E8%BF%87%E5%BC%95%E7%94%A8%E5%8F%98%E9%87%8F%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1">6.1.2 通过引用变量访问对象</a></li>
<li><a href="#613-%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%95%B0%E6%8D%AE%E5%92%8C%E6%96%B9%E6%B3%95">6.1.3 访问对象的数据和方法</a></li>
</ul>
</li>
<li><a href="#62-%E4%BD%BF%E7%94%A8java%E5%BA%93%E4%B8%AD%E7%9A%84%E7%B1%BB">6.2 使用java库中的类</a><ul>
<li><a href="#621-date%E7%B1%BB">6.2.1 Date类</a></li>
<li><a href="#622-random%E7%B1%BB">6.2.2 Random类</a></li>
<li><a href="#623-math%E7%B1%BB">6.2.3 Math类</a></li>
</ul>
</li>
<li><a href="#63-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98-%E5%AE%9E%E4%BE%8B%E6%88%90%E5%91%98">6.3 静态成员、实例成员</a><ul>
<li><a href="#631-%E5%AE%9E%E4%BE%8B%E6%88%90%E5%91%98">6.3.1 实例成员</a></li>
<li><a href="#632-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98">6.3.2 静态成员</a></li>
</ul>
</li>
<li><a href="#64-%E7%B1%BB%E6%88%90%E5%91%98%E7%9A%84%E6%8E%A7%E5%88%B6%E8%AE%BF%E9%97%AE">6.4 类成员的控制访问</a><ul>
<li><a href="#641-%E5%8F%AF%E8%A7%81%E6%80%A7%E4%BF%AE%E9%A5%B0%E7%AC%A6">6.4.1 可见性修饰符</a></li>
<li><a href="#642-%E6%95%B0%E6%8D%AE%E5%9F%9F%E5%B0%81%E8%A3%85">6.4.2 数据域封装</a></li>
<li><a href="#643-this%E5%BC%95%E7%94%A8">6.4.3 this引用</a></li>
</ul>
</li>
<li><a href="#65-%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84">6.5 对象数组</a></li>
</ul>
</li>
<li><a href="#%E7%AC%AC%E4%B8%83%E8%AE%B2-%E5%AD%97%E7%AC%A6%E4%B8%B2">第七讲 字符串</a><ul>
<li><a href="#71-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%93%8D%E4%BD%9C">7.1 字符串的操作</a><ul>
<li><a href="#711-%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1">7.1.1 创建字符串对象</a></li>
<li><a href="#712-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83">7.1.2 字符串比较</a></li>
<li><a href="#713-%E8%8E%B7%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A6">7.1.3 获取字符串长度</a></li>
<li><a href="#714-%E8%8E%B7%E5%8F%96%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E7%9A%84%E5%AD%97%E7%AC%A6">7.1.4 获取指定位置的字符</a></li>
<li><a href="#715%E8%8E%B7%E5%8F%96%E5%AD%90%E4%B8%B2">7.1.5获取子串</a></li>
<li><a href="#716-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%BD%AC%E6%8D%A2">7.1.6 字符串的转换</a></li>
<li><a href="#717-%E6%9F%A5%E6%89%BE%E6%8C%87%E5%AE%9A%E7%9A%84%E5%AD%97%E7%AC%A6%E6%88%96%E5%AD%97%E7%AC%A6%E4%B8%B2">7.1.7 查找指定的字符或字符串</a></li>
<li><a href="#718-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%86%E5%89%B2">7.1.8 字符串的分割</a></li>
</ul>
</li>
<li><a href="#72-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">7.2 字符串类型转换</a></li>
</ul>
</li>
<li><a href="#%E7%AC%AC%E5%85%AB%E8%AE%B2-%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81">第八讲 继承和多态</a><ul>
<li><a href="#81-%E4%BD%BF%E7%94%A8super%E5%85%B3%E9%94%AE%E5%AD%97">8.1 使用super关键字</a><ul>
<li><a href="#811-%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95">8.1.1 调用父类的构造方法</a></li>
<li><a href="#812-%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95">8.1.2 调用父类的方法</a></li>
<li><a href="#813-%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99">8.1.3 方法重写</a></li>
<li><a href="#814-%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD">8.1.4 方法重载</a></li>
</ul>
</li>
<li><a href="#82-tostring%E6%96%B9%E6%B3%95">8.2 toString()方法</a></li>
<li><a href="#83-%E5%AF%B9%E8%B1%A1%E8%BD%AC%E6%8D%A2">8.3 对象转换</a></li>
<li><a href="#84-%E5%A4%9A%E6%80%81">8.4 多态</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<p>[TOC]</p>
<h1><span id="第六讲-面向对象初步">第六讲 面向对象初步</span></h1><h2><span id="61-类和对象的基本概念">6.1 类和对象的基本概念</span></h2><ul>
<li>**对象(object)**表示现实世界中可以明确识别的实体。</li>
</ul>
<p>例如，学生、圆、按钮等。对象具有状态和行为。</p>
<ul>
<li>**类(class)**定义了同一类对象共有的属性和方法。</li>
</ul>
<p>类是对象的模板、蓝图。对象是类的实例。</p>
<p><strong>面向对象的三大特征：封装、继承、多态。</strong></p>
<h3><span id="611-使用构造方法构造对象">6.1.1 使用构造方法构造对象</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Circle &#123;</span><br><span class="line"> double radius = 1.0;//数据域</span><br><span class="line"></span><br><span class="line"> Circle() &#123;</span><br><span class="line">  radius = 1.0;</span><br><span class="line"> &#125;//构造方法</span><br><span class="line"> Circle(double r) &#123;</span><br><span class="line">  radius = r;</span><br><span class="line"> &#125;//构造方法</span><br><span class="line"></span><br><span class="line"> double getArea() &#123;</span><br><span class="line">  return radius * radius * 3.14159;</span><br><span class="line"> &#125;//实例方法</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>如果不写构造方法，系统会赠送一个无参的构造方法。</p>
<p><strong>构造方法与一般方法有三点不同：</strong></p>
<p>1：构造方法必须与所在类具有相同的名字。</p>
<p>2：构造方法没有返回类型，甚至连void也没有。</p>
<p>3：一般方法的调用是显示调用（方法名后面跟实参），而构造方法是隐式调用，其调用时机是在使用new操作符创建对象时。</p>
<h3><span id="612-通过引用变量访问对象">6.1.2 通过引用变量访问对象</span></h3><p>对象是引用类型，通过引用变量进行访问，引用变量中存储的是对象的引用(reference)。</p>
<p>在java中，数组被看作是对象。</p>
<h4><span id="1声明引用变量">（1）声明引用变量</span></h4><p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Circle myCircle;</span><br></pre></td></tr></table></figure>

<h4><span id="2引用变量赋值">（2）引用变量赋值</span></h4><p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">myCircle = new Circle();</span><br></pre></td></tr></table></figure>

<h4><span id="3使用new操作符创建对象">（3）使用new操作符创建对象</span></h4><p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new Circle(); //调用无参构造方法</span><br><span class="line">new Circle(5); //调用带有一个参数的构造方法</span><br><span class="line"></span><br><span class="line">Scanner input = new Scanner(System.in);</span><br></pre></td></tr></table></figure>

<h3><span id="613-访问对象的数据和方法">6.1.3 访问对象的数据和方法</span></h3><h4><span id="1访问对象实例的属性">（1）访问对象实例的属性</span></h4><p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">myCircle.radius</span><br></pre></td></tr></table></figure>

<h4><span id="2调用对象的方法">（2）调用对象的方法：</span></h4><p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">myCircle.getArea()</span><br></pre></td></tr></table></figure>

<h2><span id="62-使用java库中的类">6.2 使用java库中的类</span></h2><h3><span id="621-date类">6.2.1 Date类</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.util.Date;</span><br></pre></td></tr></table></figure>

<h4><span id="1构造方法">(1）构造方法</span></h4><p>Date():以当前时间毫秒值创建Date对象<br>Date(long time):以指定的毫秒值创建Date对象</p>
<h4><span id="2成员方法">(2）成员方法</span></h4><p>long getTime():获取Date对象的毫秒值<br>setTime(long time):设置Data对象的毫秒值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.util.Date date = new java.util.Date();</span><br><span class="line">System.out.println(date.getTime());</span><br><span class="line">System.out.println(date.toString());</span><br></pre></td></tr></table></figure>

<p>输出：毫秒数&#x2F;字符串时间</p>
<h3><span id="622-random类">6.2.2 Random类</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.util.Random;</span><br></pre></td></tr></table></figure>

<h4><span id="1构造方法">(1）构造方法</span></h4><p>Random():以当前时间毫秒值作为种子，创建Random对象<br>Random(long seed):以指定种子创建Random对象</p>
<h4><span id="2成员方法">(2）成员方法</span></h4><p>nextInt():生成1个int类型范围的随机数<br>nextInt(int n):产生1个[0,n-1]范围内的随机数</p>
<h4><span id="3生成0~n之间的数">(3)生成0~n之间的数</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">①(int)Math.random()*(n+1)</span><br><span class="line">②Random r  = new Random();</span><br></pre></td></tr></table></figure>

<p>r.nextInt(m)表示生成[0,m-1]之间的随机数，也就是说random.nextInt(m+1)，将生成[0,m]之间的随机整数。<br>r.nextInt(n+1)</p>
<h4><span id="4生成n~m之间的随机数">(4)生成n~m之间的随机数</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">①n+(int)(Math.random()*(m+1-n));</span><br><span class="line">②Random r = new Random();</span><br></pre></td></tr></table></figure>

<p>r.nextInt(m+1-n)+n;</p>
<h3><span id="623-math类">6.2.3 Math类</span></h3><p>abs(int a):绝对值<br>ceil(double d):向上取整<br>floor(double d):向下取整<br>max(int a,int b):最大值<br>pow(double a,double b):a的b次幂<br>random():随机数[0.0,1.0]<br>round(float f):四舍五入<br>sqrt(double d):算术平方根</p>
<h2><span id="63-静态成员-实例成员">6.3 静态成员、实例成员</span></h2><p>类中的成员有变量和方法，称为成员变量和成员方法。</p>
<p>对于这些成员，如果有static修饰符，则称为静态成员，</p>
<p>否则称为实例成员。</p>
<p><strong>使用原则：</strong></p>
<ul>
<li>方法紧密关联于具体的对象实例——实例；</li>
<li>方法与实例五关——静态。</li>
</ul>
<h3><span id="631-实例成员">6.3.1 实例成员</span></h3><p>实例变量和实例方法是属于类的某个特定实例的，对于类中定义的实例成员，其不同的对象实例都是各自独立，位于不同的内存区域。</p>
<p>只能通过引用变量访问，即：<strong>对象名.实例成员</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">  String name;</span><br><span class="line">  public Student(String studentName) &#123;</span><br><span class="line">   name = studentName;</span><br><span class="line">  &#125;</span><br><span class="line">  public String getName() &#123;</span><br><span class="line">   return name;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;//name是实例成员</span><br><span class="line"> </span><br><span class="line"> Student s1 = new Student(&quot;张三&quot;);</span><br><span class="line"> Student s2 = new Student(&quot;李四&quot;);</span><br></pre></td></tr></table></figure>

<h3><span id="632-静态成员">6.3.2 静态成员</span></h3><ul>
<li><p>静态变量被类的所有实例共享。<br> 静态方法并不绑定到某个特定的对象。</p>
</li>
<li><p>调用静态成员的方式是<strong>类名.静态变量</strong>或<strong>类名.静态方法</strong>。</p>
</li>
<li><p>静态方法中可以直接访问静态成员，但不能直接访问实例成员；</p>
<p>而实例方法中访问静态和实例成员都不受限制。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static int num;</span><br><span class="line"></span><br><span class="line">static int number()&#123;</span><br><span class="line">return num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final static double PI=3.14;</span><br></pre></td></tr></table></figure>

<h2><span id="64-类成员的控制访问">6.4 类成员的控制访问</span></h2><p>类中代码可以访问自身的所有成员。</p>
<h3><span id="641-可见性修饰符">6.4.1 可见性修饰符</span></h3><p>其它类中的代码访问成员，受可见性修饰符的限制：</p>
<ul>
<li>private 只能当前类自身可以访问。</li>
<li>默认 无访问修饰符的成员，只有相同包中的代码可以访问。</li>
<li>protected 子类、同一包中的类可以访问。</li>
<li>public 所有其它类都可以访问。</li>
</ul>
<h3><span id="642-数据域封装">6.4.2 数据域封装</span></h3><p>•为了避免直接修改数据域（属性），应该将数据域的这些成员变量设为私有的；同时提供getter(读取器)和setter（修改器）。这称为数据域封装（ecapsulation）。</p>
<p>•假设成员变量名为xxx，getter方法和setter方法通用的命名规则为getXxx()和setXxx(参数列表)，对于布尔型的读取器一般命名为isXxx()。</p>
<p><strong>get方法返回值，set方法设置值。</strong></p>
<p><strong>其实就只是命名改了而已。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Circle &#123;</span><br><span class="line">  private double radius; </span><br><span class="line">  public double getRadius() &#123;</span><br><span class="line">   return radius;</span><br><span class="line">  &#125;//get方法//////</span><br><span class="line"></span><br><span class="line">  public void setRadius(double newRadius) &#123;</span><br><span class="line">   if (newRadius &gt; 0) &#123;</span><br><span class="line">    radius = newRadius;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">    System.out.println(&quot;半径设置有误&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;//set方法/////</span><br><span class="line">  </span><br><span class="line">  public Circle() &#123;</span><br><span class="line">   radius = 1.0;</span><br><span class="line">  &#125;</span><br><span class="line">  public Circle(double newRadius) &#123;</span><br><span class="line">   radius = newRadius;</span><br><span class="line">  &#125;</span><br><span class="line">  double getArea() &#123;</span><br><span class="line">   return radius * radius * Math.PI;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3><span id="643-this引用">6.4.3 this引用</span></h3><ul>
<li><p>this表示当前对象实例</p>
<p>set方法经常把数据域名用作参数名，这个时候数据域就被隐藏。</p>
<p>如果一个局部变量和一个类变量具有相同的名字，那么局部变量优先，同名的类变量被隐藏。</p>
<p>实例变量被局部变量或方法参数隐藏，可以通过this.x访问实例变量。（隐藏的静态变量用“类名.静态变量”引用即可）。</p>
</li>
<li><p>调用类的其它构造方法。</p>
</li>
</ul>
<h2><span id="65-对象数组">6.5 对象数组</span></h2><p>与基本数据类型一样，可以声明并创建对象数组。</p>
<p>当创建对象数组时，数组元素的缺省初值为null。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Circle[] circleArray = new Circle[10];</span><br><span class="line">for(int i = 0; i &lt; circleArray.length; i++) &#123;</span><br><span class="line"> circleArray[i] = new Circle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1><span id="第七讲-字符串">第七讲 字符串</span></h1><h2><span id="71-字符串的操作">7.1 字符串的操作</span></h2><p>String对象是不可改变的，字符串一旦创建，内容不能再改变。</p>
<h3><span id="711-创建字符串对象">7.1.1 创建字符串对象</span></h3><h4><span id="1常规形式创建字符串">（1）常规形式创建字符串</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String s1 = new String(&quot;Welcome to java&quot;);</span><br></pre></td></tr></table></figure>

<h4><span id="2简写形式">（2）简写形式</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String s2 = &quot;Welcome to java&quot;;</span><br></pre></td></tr></table></figure>

<h4><span id="3用字符数组创建字符串">（3）用字符数组创建字符串</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char[] charArray = &#123;&#x27;G&#x27;,&#x27;O&#x27;,&#x27;O&#x27;,&#x27;D&#x27;,&#x27; &#x27;,&#x27;D&#x27;,&#x27;A&#x27;,&#x27;Y&#x27;&#125;;</span><br><span class="line"></span><br><span class="line">String s3 = new String(charArray);</span><br></pre></td></tr></table></figure>

<p>上述中，s1&#x3D;&#x3D;s2为false。</p>
<h3><span id="712-字符串比较">7.1.2 字符串比较</span></h3><p><strong>注意：</strong>&#x3D;&#x3D;比较的是字符串地址，equals方法比较的是字符串内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;java&quot;.euqals(&quot;java&quot;);</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F;如果这个字符串等于括号内字符串，返回true</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;java&quot;.euqalsIgnoreCase(&quot;JAVA&quot;);</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F;无视大小写的euqals方法，返回true</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;java&quot;.compareTo(&quot;java&quot;);</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F;比较这个字符串和括号内字符串的大小，返回值为int(大于&gt;0，小于&lt;0，等于&#x3D;&#x3D;0)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;java&quot;.compareToIgnoreCase(&quot;JAVA&quot;);</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F;无视大小写的compareTo方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;java&quot;.startsWith(&quot;j&quot;);</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F;如果这个字符串以指定前缀开始则返回true</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;java&quot;.endsWith(&quot;a&quot;);</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F;如果这个字符串以指定前缀结束则返回true</p>
<h3><span id="713-获取字符串长度">7.1.3 获取字符串长度</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s1=&quot;Welcome&quot;;</span><br><span class="line"></span><br><span class="line">s1.length();</span><br></pre></td></tr></table></figure>

<p>返回7</p>
<h3><span id="714-获取指定位置的字符">7.1.4 获取指定位置的字符</span></h3><p>•charAt(index)方法可以获取指定位置的字符。index是字符串的下标值，index的值必须在0到s.length()-1之间。</p>
<p>•例如，message.charAt(0)返回’W’,messageCharAt(14)返回’a’。</p>
<h3><span id="715获取子串">7.1.5获取子串</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String s1 = &quot;Welcome to java&quot;;</span><br><span class="line"></span><br><span class="line">String s2 = s1.substring(0,11);</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F;开始到结束区间为：左闭右开</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String s3 = s1.substring(0);</span><br></pre></td></tr></table></figure>

<p>值为：s2&#x3D;”Welcome to “;  s3&#x3D;”Welcome to java”;</p>
<h3><span id="716-字符串的转换">7.1.6 字符串的转换</span></h3><p>•toLowerCase将字符串转换成小写形式</p>
<p>•toUpperCase将字符串转换成大写形式</p>
<p>•trim删除两端的空格</p>
<p>例如：</p>
<p>“ Welcome “.trim()返回一个新字符串Welcome。</p>
<h3><span id="717-查找指定的字符或字符串">7.1.7 查找指定的字符或字符串</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;Welcome to java&quot;.indexOf(&#x27;x&#x27;);</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F;查找不到x，返回-1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;Welcome to java&quot;.indexOf(&#x27;e&#x27;);</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F;只查找第一个e，返回1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;Welcome to java&quot;.indexOf(&#x27;e&#x27;,2);</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F;规定查找的起始位置，返回6</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;Welcome to java&quot;.indexOf(&quot;come&quot;);</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F;可以查找字符串，返回3</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;Welcome to java&quot;.lastIndexOf(&quot;e&quot;);</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F;从后往前查找，找到字符串中最后一个e的位置，返回6</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;Welcome to java&quot;.lastIndexOf(&quot;e&quot;,0);</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F;返回-1</p>
<h4><span id="应用如何获取用户的后缀名">应用：如何获取用户的后缀名？</span></h4><p>后缀名是紧随在”.”后的字符串，先用lastIndexOf(“.”)获取”.”在文件名中的索引位置k，然后使用subString(k+1)就可以得到完整的后缀名</p>
<h3><span id="718-字符串的分割">7.1.8 字符串的分割</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;Java#HTML#Ruby&quot;.split(&quot;#&quot;);</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F;其参数为String类型，代表用于分割字符串的定界符，返回结果就是字符串数组</p>
<p>&#x2F;&#x2F;返回”Java”,”HTML”,”Ruby”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;Java.HTML.Ruby&quot;.split(&quot;.&quot;);</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F;返回值为空</p>
<h2><span id="72-字符串类型转换">7.2 字符串类型转换</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int intValue = Integer.parseInt(intString);</span><br><span class="line">int i = Integer.parseInt(s:&quot;45&quot;);</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F;i:45</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">double doubleValue = Double.parseDouble(doubleString);</span><br><span class="line">double d = Double.parseDouble(s:&quot;23.4&quot;);</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F;d:23.4</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String s = doubleValue + **&quot;&quot;**; </span><br><span class="line">String s1 = &quot; &quot;+45.6</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F;s1:45.6</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Integer.ToString(intValue);</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String.valueOf(intValue);</span><br><span class="line"></span><br><span class="line">String s3 = String.valueOf(34);</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F;s3:34</p>
<h1><span id="第八讲-继承和多态">第八讲 继承和多态</span></h1><h2><span id="81-使用super关键字">8.1 使用super关键字</span></h2><ul>
<li>父类的构造方法不能被继承。</li>
<li>它们被显式或隐式地调用。</li>
<li>使用super关键字显式调用。</li>
</ul>
<p>构造方法可以调用重载的构造方法或它的父类的构造方法。如果它们都没有被显式调用，那编译器就会自动地将super()作为构造方法的第一条语句。</p>
<h3><span id="811-调用父类的构造方法">8.1.1 调用父类的构造方法</span></h3><p>为了保证父类的构造方法第一时间得到运行， super的语句一定要是子类构造方法中的第一条语句，这是显式调用父类构造方法的唯一方式。</p>
<p><strong>public</strong> Circle(<strong>double</strong> radius,<br>        String color, <strong>boolean</strong> filled) {<br>  <strong>this</strong>.<strong>radius</strong> &#x3D; radius;<br>  <u>setColor(color);</u><br>  <u>setFilled(filled);</u><br> }</p>
<p>等价于——</p>
<p><strong>public</strong> Circle(<strong>double</strong> radius,<br>        String color, <strong>boolean</strong> filled) {<br>  <u><strong>super</strong>(color,filled);</u><br>  <strong>this</strong>.<strong>radius</strong> &#x3D; radius;  </p>
<h3><span id="812-调用父类的方法">8.1.2 调用父类的方法</span></h3><p>•super.方法名(参数)</p>
<p><strong>public void</strong> printCircle() {<br>  System.<strong>out</strong>.println(<strong>“The circle is created “</strong> +<br>    <u>getDateCreated()</u> +<br>    <strong>“ and the radius is “</strong> + <strong>radius</strong>);<br> }</p>
<p>等价于——</p>
<p><strong>public void</strong> printCircle() {<br>  System.<strong>out</strong>.println(<strong>“The circle is created “</strong> +<br>    <u><strong>super</strong>.getDateCreated()</u> +<br>    <strong>“ and the radius is “</strong> + <strong>radius</strong>);<br> }</p>
<h3><span id="813-方法重写">8.1.3 方法重写</span></h3><p>要重写一个方法，需要在子类中使用和父类一样的签名以及一样的返回值类型来对该方法进行定义。</p>
<p>方法名、参数、返回值相同。</p>
<p>super.toString()</p>
<p>重写意味着在子类中提供一个对父类已有方法的新的实现。</p>
<p>方法重写发生在通过继承而相关的不同类中。</p>
<h3><span id="814-方法重载">8.1.4 方法重载</span></h3><p>重载意味着使用同样的名字但是不同的方法签名来定义多个方法。</p>
<p>方法重载可以发生在同一个类中，也可以发生在通过继承而相关的不同类中。</p>
<p>重写标注：@Override</p>
<h2><span id="82-tostring方法">8.2 toString()方法</span></h2><p>•在Object类中定义了public属性的toString()方法，而Object是所有类的直接或间接父类，该方法会被子类继承。</p>
<p>•默认的toString()方法返回的结果，是类似于类名@15037e5这样的字符串。</p>
<p>调用一个对象的toString()方法，会返回一个描述该对象的字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Loan loan = new Loan();</span><br><span class="line">System.out.println(loan.toString());</span><br></pre></td></tr></table></figure>

<h2><span id="83-对象转换">8.3 对象转换</span></h2><p>•可以使用转换把一种类类型的对象转换为继承体系结构中的另一种类类型的对象。</p>
<p>•在基本数据类型转换中有隐式转换和强制转换，对象转换也有类似概念。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object o = new Student()</span><br></pre></td></tr></table></figure>

<p> &#x2F;&#x2F; 隐式转换，也称为向上转型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Student b = (Student)O; </span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F;显式转换，用于子类实例转换为父类实例，即向上转换</p>
<p>•使用<strong>instanceof运算符</strong>来检测一个对象是否是一个类的实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Fruit f = new Apple();</span><br></pre></td></tr></table></figure>

<p> 那么</p>
<p> f instanceof Apple 将返回 true</p>
<p> f instanceof Orange 将返回false</p>
<h2><span id="84-多态">8.4 多态</span></h2><p><strong>含义：</strong></p>
<p>多态意味着父类的变量可以指向子类对象 ，当调用该父类变量的一些成员方法，其行为可以表现为子类同名方法的行为特征，而不是父类同名方法的特征。</p>
<p>这样就会出现这样一个情况：相同类型的变量，调用同一个方法时呈现出不同的行为特征，所以称为多态。</p>
<p><strong>实现多态要点：</strong></p>
<p>1、父类定义需要被重写的方法；</p>
<p>2、子类重写父类的方法；</p>
<p>3、将子类的对象实例赋值给父类类型的变量，则可通过该变量调用被重写的方法，自动调用子类的不同的重写版本。</p>
]]></content>
      <tags>
        <tag>2024-2025-1课内笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>控制角色移动</title>
    <url>/2024/03/19/unity-%E6%8E%A7%E5%88%B6%E8%A7%92%E8%89%B2%E7%A7%BB%E5%8A%A8/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line">//控制角色移动、生命、动画等</span><br><span class="line">public class NewBehaviourScript : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    public float speed = 5f;//移动速度</span><br><span class="line">    // Start is called before the first frame update</span><br><span class="line">    void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Update is called once per frame</span><br><span class="line">void Update()</span><br><span class="line">&#123;</span><br><span class="line">    float moveX = Input.GetAxisRaw(&quot;Horizontal&quot;);//控制水平方向移动，A：-1，D：1,0</span><br><span class="line">    float moveY = Input.GetAxisRaw(&quot;Vertical&quot;);//控制垂直方向W1 S-1 0</span><br><span class="line"></span><br><span class="line">    Vector2 position = transform.position;</span><br><span class="line">    position.x +=moveX * speed * Time.deltaTime;</span><br><span class="line">    position.y +=moveY * speed * Time.deltaTime;</span><br><span class="line">    transform.position = position;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>unity2d</tag>
      </tags>
  </entry>
  <entry>
    <title>java题库（上）</title>
    <url>/2024/10/24/java%E9%A2%98%E5%BA%93%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    <content><![CDATA[<p>1.一个字节包含  ____<strong><strong>8</strong></strong> 位.</p>
<p>2.Which of  the following statements is correct?(以下哪个陈述是正确的？)</p>
<p>&#x3D;&#x3D;【line】行；【statement】语句；【comment】注释；【method】方法&#x3D;&#x3D;</p>
<p>A.Every  <strong>line</strong> in a program must end with a semicolon(程序中的每一行都必须以分号结尾)</p>
<p><u>B.Every  <strong>statement</strong> in a program must end with a semicolon(程序中的每个语句都必须以分号结尾)</u></p>
<p>C.Every <strong>comment</strong> line must end with a semicolon(每个注释行必须以分号结尾)</p>
<p>D.Every  <strong>method</strong> must end with a semicolon(每个方法都必须以分号结尾)</p>
<p>3.java字节码文件的后缀是.<strong>class</strong></p>
<p>4.Java  <em><strong>applets</strong></em>_____ can run from a Web browser(Java <em><strong>小程序</strong></em>_____ 可以从 Web 浏览器运行)</p>
<p>&#x3D;&#x3D;【applets】小程序&#x3D;&#x3D;</p>
<p>5.Every  statement in Java ends with <strong>a  semicolon (;)</strong>(Java 中的每个语句都以 <strong>分号</strong> 结尾)</p>
<p>6.Computer  can execute the code in ______<em><strong>machine  language</strong></em>.(计算机可以在 <strong><strong><strong>机器语言</strong></strong></strong> 中执行代码。)</p>
<p>7.<em><em><strong><strong><strong>A  compiler</strong></strong></strong></em>  translates high-level language program into machine language program(</em><em><strong><strong><strong>编译器</strong></strong></strong></em> 将高级语言程序翻译成机器语言程序)</p>
<p>&#x3D;&#x3D;【compiler】编译器&#x3D;&#x3D;</p>
<p>8.属于解释性程序是___java_____</p>
<p>9.Which  JDK command is correct to run a Java application in ByteCode.class?</p>
<p><u><strong>java  ByteCode</strong></u></p>
<p>(在 ByteCode.class 中运行 Java 应用程序时，哪个 JDK 命令是正确的？)</p>
<p>10.Suppose  you define a Java class as follows:     </p>
<p><u>public class</u> Test {     </p>
<p>}     </p>
<p>In order to compile this program, the source code should be stored in a  file named</p>
<p>“假设您按如下方式定义一个 Java 类：<br>public 类 Test {<br>}<br>为了编译此程序，源代码应存储在名为 ”</p>
<p><strong><u>Test.java</u></strong></p>
<p>11.Suppose  you define a Java class as follows:     </p>
<p><u>class</u> Test { </p>
<p>​    }     </p>
<p>In order to compile this program, the source code should be stored in a  file named</p>
<p><strong>Any  name with extension .java</strong></p>
<p>12.main函数声明正确的是<strong>public  static void main(String[] args)</strong></p>
<p>13.JDK是(<strong>一种程序开发辅助工具</strong> )</p>
<p>14.JDK命令编译Test.java,正确的是?<strong>java  Test.java</strong></p>
<p>15._____<em><strong>Java  virtual machine</strong></em>  is a software that interprets Java bytecode(_______Java 虚拟机 是一个解释 Java 字节码的软件)</p>
<p>16.<strong><strong><strong><strong>java</strong></strong>  is Architecture-Neutral(</strong></strong>____ 是架构中立的)</p>
<p>17.____<strong><strong>Java  language specification</strong></strong>  is a technical definition of the language that includes the syntax and  semantics of the Java programming language(____<strong>Java 语言规范</strong> 是语言的技术定义，包括 Java 编程语言的语法和语义)</p>
<p>18.<strong><strong><strong><strong>Java  JDK</strong></strong>  provides an integrated development environment (IDE) for rapidly developing  Java programs. Editing, compiling, building, debugging, and online help are  integrated in one graphical user interface(</strong></strong>____ 为快速开发 Java 程序提供了一个集成开发环境 （IDE）。编辑、编译、构建、调试和在线帮助集成在一个图形用户界面中)</p>
<p>19.Java程序的执行过程中用到一套JDK工具,其中java.exe是指( <strong>Java解释器</strong> )</p>
<p>20.Java语言具有许多优点和特点,哪个反映了Java程序并行机制的特点?(<strong>多线性</strong></p>
<p>21.下列关于Java语言的特点,描述错误的是( )          Java是<strong>面向过程</strong>的编程语言</p>
<p>正确的有：Java是跨平台的编程语言、Java支持分布式计算、Java支持多线程</p>
<p>22.在 Java  中,由Java编译器自动导入,而无需在程序中用import导入的包是(    <strong>java.lang</strong> )</p>
<p>23.运行下段代码后,z的结果为??       </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a = 1, z=0;      </span><br><span class="line"></span><br><span class="line">do &#123;</span><br><span class="line"></span><br><span class="line">​       ++z; </span><br><span class="line"></span><br><span class="line">​       &#125; while(a &lt; 0);</span><br></pre></td></tr></table></figure>

<p><strong>z&#x3D;1</strong></p>
<p>24.运行下段代码后,x的结果为?</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   int x = 3; </span><br><span class="line"></span><br><span class="line">​    int y = 2; </span><br><span class="line"></span><br><span class="line">​    x *= y + 1;</span><br></pre></td></tr></table></figure>

<p><strong>x&#x3D;9</strong></p>
<p>25.有如下程序段: </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> int total = 0;</span><br><span class="line"></span><br><span class="line">​     for ( int i = 0; i &lt; 4; i++ )&#123; </span><br><span class="line"></span><br><span class="line">​    if ( i == 1) continue; </span><br><span class="line"></span><br><span class="line">​    if ( i == 2) break; </span><br><span class="line"></span><br><span class="line">​    total += i; </span><br><span class="line"></span><br><span class="line">​    &#125;    </span><br></pre></td></tr></table></figure>

<p> 则执行完该程序段后total的值为:<strong>total&#x3D;0</strong></p>
<p>26.有关类的说法正确的是?  ( )<strong>类具有封装性,但可以通过类的公共接口访问类中的数据</strong></p>
<p>27.以下关于构造函数的描述错误的是      <strong>构造函数的返回类型只能是void型</strong></p>
<p>正确的有：构造函数是类的一种特殊函数,它的方法名必须与类名相同</p>
<p>构造函数的主要作用是完成对类的对象的初始化工作</p>
<p>一般在创建新对象时,系统会自动调用构造函数</p>
<p>28.下述概念中不属于面向对象方法的是<strong>过程调用</strong></p>
<p>29.下面的选项中,哪一项不属于”汽车类”的行为   <strong>速度</strong></p>
<p>30.下列说法中,不正确的是(  )<strong>一个java源程序编译通过后,得到的结果文件数也只有一个</strong></p>
<p>正确的有：一个java源程序经过编译后,得到的文件的扩展名一定是.class</p>
<p>一个java源程序只能有一个public  class类定义,且源文件的名字与public class的类名相同,扩展名必须是.java</p>
<p>一个java源程序可以包含多个class类</p>
<p>31.下列说法正确的有(  )</p>
<p><strong>constructor在一个对象被new时执行</strong></p>
<p>32.设已声明了一个类A的两个对象a1,a2,为了初始化  a1和a2,下面语句正确的是</p>
<p><strong>a1&#x3D;new  A();a2&#x3D;new A();</strong>      </p>
<p>33.若JAVA程序中定义了3个类,编译后可生成(<strong>2</strong>)个字节码文件.</p>
<p>34.哪个关键字修饰的变量和方法不能从其他类访问?<strong>private</strong></p>
<p>35.不是构造函数特点的是(   )<strong>构造函数带有返回类型</strong></p>
<p>特点有：构造函数与类名相同、构造函数可带参数也可不带、构造函数主要完成对类对象的初始工作</p>
<p>36.哪个关键字声明一个常量?<strong>final</strong></p>
<p>37.哪个表达式的结果为0.5?<strong>(double)  1 &#x2F; 2</strong></p>
<p>38.编译Java Application  源程序文件将产生相应的字节码文件,这些字节码文件的扩展名为( <strong>.class</strong>  ).</p>
<p>39.You  have a public class called myclass with the main method defined as  follows</p>
<p>​       </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   public static void main(String parm[])&#123;</span><br><span class="line"></span><br><span class="line">​              System.out.println(parm[0]);</span><br><span class="line"></span><br><span class="line">​          &#125; </span><br></pre></td></tr></table></figure>

<p>​         If you attempt to compile the class and run the program as follows</p>
<p>​          java myclass hello </p>
<p>​         What will happen?</p>
<p>“你有一个名为 myclass 的公共类，其 main 方法定义如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main（String parm[]）&#123;</span><br><span class="line">    System.out.println（parm[0]）;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果您尝试编译该类并按如下方式运行程序<br>Java MyClass 你好<br>会发生什么事？</p>
<p><strong>Compilation  and output of hello</strong></p>
<p>40.Which  specifier essentially declares a variable a global variable?哪个说明符实质上将变量声明为全局变量？</p>
<p><strong>static</strong></p>
<p>41.Which of  the following statement prints smith\exam1\test.txt?以下哪项语句打印 smithexam1test.txt？</p>
<p>System.out.println(“smith\exam1\test.txt”);</p>
<p>用双斜杠\、\exam1\、\</p>
<p>42.Which of  the following is the correct expression of character 4?以下哪一项是字符 4 的正确表达方式？</p>
<p><strong>‘4’</strong></p>
<p>43.Which of the following is not an advantage of using <u>methods</u>?以下哪项不是使用方法的优势？</p>
<p><strong>Using  methods makes program run faster</strong>使用方法使程序运行得更快</p>
<p>44.Which  of the following can be placed in the blank line in the following code?     </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class &lt;u&gt;Test&lt;/u&gt; &#123;</span><br><span class="line"></span><br><span class="line">​      private static int id;</span><br><span class="line"></span><br><span class="line">​      &lt;u&gt;public static void m1()&lt;/u&gt; &#123;</span><br><span class="line"></span><br><span class="line">​       ___Test__.id = 45; </span><br><span class="line"></span><br><span class="line">​     &#125;</span><br><span class="line"></span><br><span class="line">​     &#125;</span><br></pre></td></tr></table></figure>

<p>“以下哪项可以放在以下代码的空行中？<strong>Test</strong></p>
<p>45.Which  of the following can be placed in the blank line in the following code?     </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">​      private int id;</span><br><span class="line"></span><br><span class="line">​      &lt;u&gt;public void m1()&lt;/u&gt; &#123;</span><br><span class="line"></span><br><span class="line">​       **this**_____.id = 45;</span><br><span class="line"></span><br><span class="line">​      &#125;</span><br><span class="line"></span><br><span class="line">​     &#125;</span><br></pre></td></tr></table></figure>

<p>“以下哪项可以放在以下代码的空行中？<strong>this</strong></p>
<p>46.Which  access specifier allows class members to be accessed by any class in its own  package?哪个访问说明符允许类成员由其自己的包中的任何类访问？</p>
<p>&#x3D;&#x3D;【access】访问&#x3D;&#x3D;</p>
<p><strong>default</strong></p>
<p>47.What  is the value of b after execution? </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">       int x, b=0; </span><br><span class="line"></span><br><span class="line">​     for(x = 0; x &lt;= 5; ++x)&#123;</span><br><span class="line"></span><br><span class="line">​       if (x == 2) break;</span><br><span class="line"></span><br><span class="line">​       ++b;</span><br><span class="line"></span><br><span class="line">​      &#125;</span><br></pre></td></tr></table></figure>

<p><strong>b&#x3D;2</strong></p>
<p>48.What  is the value of b after execution?</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">            int x, b=0;</span><br><span class="line"></span><br><span class="line">​           for(x = 0; x &lt;= 5; ++x)&#123; </span><br><span class="line"></span><br><span class="line">​           if (x == 2) continue; </span><br><span class="line"></span><br><span class="line">​           ++b; </span><br><span class="line"></span><br><span class="line">​          &#125;</span><br></pre></td></tr></table></figure>

<p><strong>b&#x3D;5</strong></p>
<p>49.What is  the printout of the following code:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   double x = 5.5;</span><br><span class="line"></span><br><span class="line">​     int y = (int)x; </span><br><span class="line"></span><br><span class="line">​    System.out.println(&quot;x is &quot; + x + &quot; and y is &quot; + y);</span><br></pre></td></tr></table></figure>

<p><strong>x is  5.5 and y is 5</strong></p>
<p>50.What  code may be filled in the blank without causing syntax or runtime  errors:  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   public class Test &#123;</span><br><span class="line"></span><br><span class="line">​      java.util.Date date; </span><br><span class="line"></span><br><span class="line">​     public static void main(String[] args)  &#123; </span><br><span class="line"></span><br><span class="line">​      Test test = new Test(); </span><br><span class="line"></span><br><span class="line">​        System.out.println(_________________);</span><br><span class="line"></span><br><span class="line">​      &#125;</span><br><span class="line"></span><br><span class="line">​     &#125;</span><br></pre></td></tr></table></figure>

<p>哪些代码可以填空而不会导致语法或运行时错误     <strong>test.date</strong></p>
<p>51.To  improve readability and maintainability, you should declare ___<em><strong><strong>constants</strong></strong></em> instead  of using</p>
<p>​           literal values such as 3.14159.</p>
<p>“为了提高可读性和可维护性，你应该声明 ___<em><strong><strong>constants</strong></strong></em> 而不是使用<br>文本值，例如 3.14159。</p>
<p>52.To  declare a constant MAX_LENGTH inside a method with value 99.98, you write</p>
<p>要在值为 99.98 的方法中声明常量 MAX_LENGTH，您可以编写</p>
<p><strong>final  double MAX_LENGTH &#x3D; 99.98;</strong></p>
<p>53.To add  number to sum, you write</p>
<p><strong>sum +&#x3D;  number;</strong></p>
<p>54.The  default value for data field of <u>a boolean type, numeric type, object type</u> is  ___________, respectively</p>
<p>布尔型、数值型、对象型的数据字段默认值分别为 ___________</p>
<p><strong>false,  0, null</strong></p>
<p>55.Test.java程序代码如下:     </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1) public class Test&#123; </span><br><span class="line">2) ​     public static void main(String[] args)&#123;</span><br><span class="line">3) ​     System.out.println(args[1]);</span><br><span class="line">4) ​     &#125; </span><br><span class="line">5) ​     &#125; </span><br></pre></td></tr></table></figure>

<p>​    以上程序编译后用java Test 2 3 4 5运行的输出结果是什么? (  <strong>3</strong>  )</p>
<p>56.System.out.println(“5”  + 2);的输出结果应该是         <strong>52</strong></p>
<p>57.Suppose  x is a char variable with a value <u>‘b’</u>. What is the printout of the statement  </p>
<p>System.out.println(++x)?</p>
<p><strong>c</strong></p>
<p>58.Main()方法的返回类型是:<strong>void</strong></p>
<p>59.Java的字符类型采用的是Unicode编码方案,每个Unicode码占用( <strong>16</strong> )个比特位</p>
<p>60.In the  program segment below, which line prints? </p>
<p>​         </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   int x=3, y=5;</span><br><span class="line"></span><br><span class="line">​           if (x &lt; y)  </span><br><span class="line"></span><br><span class="line">​          System.out.println(&quot;X= &quot;+x);</span><br><span class="line"></span><br><span class="line">​           System.out.println(&quot;Y= &quot;+y);</span><br></pre></td></tr></table></figure>

<p><strong>Both</strong></p>
<p>61.How  many times will the print statement execute?</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">       for (x=0; x&lt;=5; ++x) &#123;</span><br><span class="line"></span><br><span class="line">​       System.out.println(&quot;X=  &quot;+x);</span><br><span class="line"></span><br><span class="line">​        --x;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>An  infinite number of times</strong></p>
<p>62.Given:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. public void go() &#123;          </span><br><span class="line">2. String o = &quot;&quot;;          </span><br><span class="line">3.  z:          </span><br><span class="line">4. for(int x = 0; x &lt; 3; x++) &#123;          </span><br><span class="line">5. for(int y = 0; y &lt; 2; y++) &#123;          </span><br><span class="line">6. if(x==1) break;          </span><br><span class="line">7. if(x=/=2 &amp;&amp; y==1) break z;          </span><br><span class="line">8. o = o + x + y;          </span><br><span class="line">9. &#125;          </span><br><span class="line">10.  &#125;          </span><br><span class="line">11. System.out.println(o);         </span><br><span class="line">12. &#125;   </span><br></pre></td></tr></table></figure>

<p>​      </p>
<p> What is the result when the go() method is invoked?</p>
<p><strong>000120</strong></p>
<p>63.Given: </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. public class TestString1 &#123;     </span><br><span class="line">  2. public static void main(String[] args) &#123;    </span><br><span class="line">  3. String str = &quot;420&quot;;     </span><br><span class="line">  4. str += 42;     </span><br><span class="line">  5. System.out.print(str);   </span><br><span class="line">  6. &#125;     </span><br><span class="line">  7. &#125;    </span><br></pre></td></tr></table></figure>

<p> What is the output?</p>
<p><strong>42042</strong></p>
<p>64.Given:          </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. public class Test &#123;          </span><br><span class="line">2. public static void main(String [] args) &#123;          </span><br><span class="line">3. int x = 5;          </span><br><span class="line">4. boolean b1 = true;          </span><br><span class="line">5. boolean b2 = false;          </span><br><span class="line">6. ​         </span><br><span class="line">7. if ((x == 4) &amp;&amp; !b2 )          </span><br><span class="line">8. System.out.print(&quot;1 &quot;);          //假</span><br><span class="line">9. System.out.print(&quot;2 &quot;);         </span><br><span class="line">10.  if ((b2 = true) &amp;&amp; b1 )          </span><br><span class="line">11. System.out.print(&quot;3 &quot;);          </span><br><span class="line">12. &#125;          </span><br><span class="line">13. &#125;     </span><br></pre></td></tr></table></figure>

<p> What is the result?</p>
<p><strong>2 3</strong></p>
<ol start="65">
<li></li>
</ol>
<p>Analyze  the following code: </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    public class Test &#123;</span><br><span class="line"></span><br><span class="line">​      public static void main(String[]  args) &#123;</span><br><span class="line"></span><br><span class="line">​       double radius; </span><br><span class="line"></span><br><span class="line">​      final double PI= 3.15169; </span><br><span class="line"></span><br><span class="line">​      double area = radius * radius *  PI;</span><br><span class="line"></span><br><span class="line">​       System.out.println(&quot;Area is  &quot; + area); </span><br><span class="line"></span><br><span class="line">​     &#125;</span><br><span class="line"></span><br><span class="line">​     &#125;</span><br></pre></td></tr></table></figure>

<p><strong>The  program has compile errors because the variable radius is not initialized</strong></p>
<p>程序出现编译错误，因为变量 <strong>radius</strong> 未初始化【A】</p>
<p>66.An  object is an instance of a ______<em><strong>class</strong></em>.</p>
<p>对象是________的实例。</p>
<p>67.A  variable that is declared inside a method is called <em><strong>a local</strong></em>__ variable</p>
<p>&#x3D;&#x3D;【variable】变量&#x3D;&#x3D;</p>
<p>在方法中声明的变量称为________变量</p>
<p>68.__<strong><strong><strong>An  object</strong></strong></strong>  represents an entity in the real world that can be distinctly identified.</p>
<p>____<em><strong>对象</strong></em> 表示现实世界中可以明确标识的实体。</p>
<p>69.____<strong><strong>The main  method</strong></strong>  is invoked to create an object</p>
<p>调用 ________ 创建对象</p>
<p>70.(double)(5&#x2F;2)的值为?</p>
<p><strong>2.0</strong></p>
<p>71.To  assign a value 1 to variable x, you write</p>
<p><strong>x&#x3D;1;</strong></p>
<ol start="72">
<li>45 &#x2F;  4的值为?</li>
</ol>
<p><strong>11</strong></p>
<p>73.在调用方法时,若要使方法改变实参的值,可以<strong>用对象作为参数</strong></p>
<p>74.下述哪一组方法,是一个类中方法重载的正确写法?  (  )</p>
<p>int  addValue( int a, int b ){return a+1;} </p>
<p>​        int addValue ( int b) {return ++b;}</p>
<p>【C】</p>
<p>75.下述哪个说法是不正确的?(   )<strong>局部变量在使用之前无需初始化,因为有该变量类型的默认值</strong></p>
<p>正确的有：类成员变量由系统自动进行初始化,也无需初始化</p>
<p>参数的作用域就是所在的方法</p>
<p>for语句中定义的变量,当for语句执行完时,该变量就消亡了</p>
<p>76.下面代码中，空白处应填  <strong><strong><strong><strong>void</strong></strong></strong></strong>__.   __</p>
<p>​          </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Test &#123; </span><br><span class="line">​          public static void main(String[]  args) &#123;</span><br><span class="line">​            System.out.print(&quot;The grade  is &quot;);</span><br><span class="line">​            printGrade(78.5); </span><br><span class="line">​                     System.out.print(&quot;The grade  is &quot;); </span><br><span class="line">​           printGrade(59.5);</span><br><span class="line">​           &#125; </span><br><span class="line">​                    public static ______  printGrade(double score) &#123;</span><br><span class="line">​            if (score &gt;= 90.0) &#123;</span><br><span class="line">​             System.out.println(&#x27;A&#x27;); </span><br><span class="line">​           &#125;</span><br><span class="line">​            else if (score &gt;= 80.0)  &#123; </span><br><span class="line">​            System.out.println(&#x27;B&#x27;);</span><br><span class="line">​            &#125; </span><br><span class="line">​           else if (score &gt;= 70.0)  &#123;</span><br><span class="line">​             System.out.println(&#x27;C&#x27;); </span><br><span class="line">​           &#125; </span><br><span class="line">​           else if (score &gt;= 60.0)  &#123;</span><br><span class="line">​             System.out.println(&#x27;D&#x27;);</span><br><span class="line">​            &#125;</span><br><span class="line">​            else &#123;</span><br><span class="line">​             System.out.println(&#x27;F&#x27;); </span><br><span class="line">​           &#125; </span><br><span class="line">​          &#125; </span><br><span class="line">​         &#125;</span><br></pre></td></tr></table></figure>



<p>77.下列方法头中哪一个不与其他方法形成重载(overload)关系?</p>
<p><strong>int mm()</strong></p>
<p>78.若在某一个类定义中定义有如下的方法:abstract  void performDial( );该方法属于</p>
<p><strong>抽象方法</strong></p>
<p>79.面哪个函数是public  void aMethod(){…}的重载函数?</p>
<p><strong><u>public  void</u> aMethod ( int m){…}</strong>          </p>
<p>80.假设A类有如下定义,设a是A类的一个实例,下列语句调用哪个是错误的?<strong>A.method1();</strong></p>
<p>​     class A</p>
<p>​          { int i;</p>
<p>​          static String s;</p>
<p>​     void method1() { }</p>
<p>​     static void method2() { }</p>
<p>​     }</p>
<p>正确的有：System.out.println(a.i);</p>
<p>a.method1();</p>
<p>A.method2();</p>
<p>81.You  should add the static keyword in the place of ? in Line ________ in the  following code:<strong>in  line 4</strong></p>
<p>​      1 public class Test {</p>
<p>​      2  private int age;</p>
<p>​      3</p>
<p>​      4  public ? int square(int n) {</p>
<p>​      5   return n * n;</p>
<p>​      6  } </p>
<p>​      7 </p>
<p>​      8  public ? int getAge() {return  age;</p>
<p>​      9 }</p>
<p>​     10}</p>
<p>82.Which of  the following should be defined as a void method?</p>
<p>以下哪项应定义为 void 方法？</p>
<p><strong>Write a  method that prints integers from 1 to 100</strong></p>
<p>83.Which of  the following are legal declaration and definition of a method</p>
<p>以下哪项是方法的法律声明和定义</p>
<p><strong>void  method() {};</strong></p>
<p>84.Which  method names follow the JavaBeans standard?</p>
<p>哪些方法名称遵循 JavaBeans 标准？</p>
<p><strong>getCust</strong></p>
<p>85.When  you invoke a method with a parameter, the value of the argument is passed to  the parameter. This is referred to as _______</p>
<p>使用参数调用方法时，参数的值将传递给参数。这称为 _______<strong>pass by  value</strong></p>
<p>86.When  invoking a method with an object argument, ___________ is passed</p>
<p>当调用带有 object 参数的方法时，<em><strong>the  reference of the object</strong></em>_____</p>
<p>87.What  will happen if you try to compile and run the following code                     public class MyClass {</p>
<p>​            public static void main(String arguments[]) {</p>
<p>​           amethod(arguments);  }</p>
<p>​             public void amethod(String[]  arguments) {</p>
<p>​           System.out.println(arguments);</p>
<p>​            System.out.println(arguments[1]); </p>
<p>​             }}</p>
<p><strong>error  Can’t make static reference to void amethod</strong></p>
<p>错误 无法对 void amethod 进行静态引用</p>
<p>88.What  is the value of times displayed?       <strong>0</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Test &#123; </span><br><span class="line">​        public static void main(String[]  args) &#123;</span><br><span class="line">​            Count myCount = new Count();</span><br><span class="line">​            int times = 0;</span><br><span class="line">​                      for (int i=0; i&lt;100;  i++)</span><br><span class="line">​             increment(myCount, times);</span><br><span class="line">​            System.out.println(&quot;times =  &quot;+ times);</span><br><span class="line">​           &#125; </span><br><span class="line">​         public static void increment(Count  c, int times) &#123;</span><br><span class="line">​            c.count++; </span><br><span class="line">​           times++; </span><br><span class="line">​          &#125; </span><br><span class="line">​         &#125;</span><br><span class="line">​          class Count &#123;</span><br><span class="line">​           int count;</span><br><span class="line">​           Count(int c) &#123; </span><br><span class="line">​           count = c;</span><br><span class="line">​           &#125; </span><br><span class="line">​          Count() &#123; </span><br><span class="line">​           count = 1; </span><br><span class="line">​          &#125;</span><br><span class="line">​          &#125;</span><br></pre></td></tr></table></figure>



<p>89.What  is the printout of the second println statement in the main method?    </p>
<p><strong>f2.i  is 1 f2.s is 2</strong>      </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Foo &#123;</span><br><span class="line">​           int i; </span><br><span class="line">​          static int s;</span><br><span class="line">​          public static void main(String[]  args) &#123;</span><br><span class="line">​            Foo f1 = new Foo();</span><br><span class="line">​            System.out.println(&quot;f1.i is  &quot; + f1.i + &quot; f1.s is &quot; + f1.s);</span><br><span class="line">​            Foo f2 = new Foo();</span><br><span class="line">​            System.out.println(&quot;f2.i is  &quot; + f2.i + &quot; f2.s is &quot; + f2.s);</span><br><span class="line">​           &#125; </span><br><span class="line">​            public Foo() &#123;</span><br><span class="line">​            i++;</span><br><span class="line">​            s++;</span><br><span class="line">​           &#125; </span><br><span class="line">​         &#125;</span><br></pre></td></tr></table></figure>



<p>90.The  signature of a method consists of ________<strong>method  name and parameter list</strong></p>
<p>方法的签名由 ________</p>
<p>91.Suppose  your method does <u>not</u> return any value, which of the following keywords can be  used as a return type?</p>
<p>假设你的方法没有返回任何值，那么以下哪个关键字可以用作返回类型？</p>
<p><strong>void</strong></p>
<p>92.Suppose  you wish to provide an accessor method for a boolean property finished, what  signature of the method should be?</p>
<p>假设你希望为布尔属性 finished 提供一个访问器方法，该方法的签名应该是什么？</p>
<p><strong>public  boolean isFinished()</strong></p>
<p>93.Suppose  the xMethod() is invoked from a main method in a class as follows, xMethod()  is _________ in the class.</p>
<p>假设 xMethod（） 是从类中的 main 方法调用的，如下所示，xMethod（） 在类中______a  <strong>static method</strong>___。</p>
<p>​          public static void main(String[] args) {</p>
<p>​      xMethod(); </p>
<p>​    }</p>
<p>94.Given: </p>
<p>​         <strong>true  true</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Fizz &#123; </span><br><span class="line">​         int x = 5; </span><br><span class="line">​         public static void main(String[] args) &#123;</span><br><span class="line">​          final Fizz f1 = new Fizz();</span><br><span class="line">​          Fizz f2 = new Fizz(); </span><br><span class="line">​         Fizz f3 = FizzSwitch(f1,f2);</span><br><span class="line">​          System.out.println((f1 == f3) + &quot; &quot; + (f1.x == f3.x));</span><br><span class="line">​          &#125; </span><br><span class="line">​         static Fizz FizzSwitch(Fizz x, Fizz y) &#123;</span><br><span class="line">​          final Fizz z = x; </span><br><span class="line">​         z.x = 6; </span><br><span class="line">​         return z;</span><br><span class="line">​          &#125; &#125;</span><br></pre></td></tr></table></figure>

<p>​          What is the result?</p>
<p>95.Given: </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Dark &#123;</span><br><span class="line">int x = 3; </span><br><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line"> new Dark().go1();</span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> void go1() &#123;</span><br><span class="line">int x; </span><br><span class="line"> go2(++x);</span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> void go2(int y) &#123;</span><br><span class="line">nt x = ++y;</span><br><span class="line">System.out.println(x)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​          What is the result?</p>
<p><strong>Compilation  fails</strong></p>
<p>96.Given:          </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Pass &#123;          </span><br><span class="line">public static void main(String [] args) &#123;         </span><br><span class="line">int x = 5;          </span><br><span class="line">Pass p = new Pass();          </span><br><span class="line">p.doStuff(x);          </span><br><span class="line">System.out.print(&quot; main x = &quot; + x);          </span><br><span class="line">&#125;          </span><br><span class="line">​         </span><br><span class="line">void doStuff(int x) &#123;          </span><br><span class="line">System.out.print(&quot; doStuff x = &quot; + x++);          </span><br><span class="line">&#125;          </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p> What is the result?</p>
<p><strong>doStuff  x &#x3D; 5 main x &#x3D; 5</strong></p>
<p>97.Given:          </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 public class Frodo extends Hobbit &#123;         </span><br><span class="line">2 public static void main(String[] args) &#123;          </span><br><span class="line">3 Short myGold = 7;          </span><br><span class="line">4 System.out.println(countGold(myGold, 6));          </span><br><span class="line">5 &#125;         </span><br><span class="line">6 &#125;          </span><br><span class="line"></span><br><span class="line">7 class Hobbit &#123;          </span><br><span class="line">8 int countGold(int x, int y) &#123; return x + y; &#125;          </span><br><span class="line">9 &#125;  </span><br></pre></td></tr></table></figure>

<p>​      What is the result?</p>
<p><strong>Compilation  fails due to an error on line 4</strong></p>
]]></content>
      <tags>
        <tag>java面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>《图解密码技术》 读书笔记</title>
    <url>/2024/04/17/%E3%80%8A%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF%E3%80%8B-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2><span id="基础概念">基础概念</span></h2><h3><span id="1-1-基本名词解释">1-1 基本名词解释</span></h3><p>1.密钥（key）：加密和解密所需的媒介。</p>
<p>2.对称密码：在加密和解密时使用同一密钥的解密方式。</p>
<p>3.公钥密码：在加密和解密时使用不同密钥的解密方式。又叫非对称密码。</p>
<p>4.混合密码系统：结合了对称密码和非对称密码的优势。</p>
<p>5.单向散列函数：是一种保证完整性的密码技术。</p>
<p>为了防止软件被篡改，一些发布者会在发布软件的同时发布该软件的散列值，下载该软件的人自行下载散列值，如果后者与前者的值相等，说明下载的软件是正版的。</p>
<p>6.消息认证码：是一种能够保证完整性和提供认证的密码技术。</p>
<p>为了确认消息是否来自所期望的通信对象，可以使用消息认证码。</p>
<p>7.数字签名：</p>
<p>（1）伪装：第三方伪造发送者的身份传达消息。</p>
<p>（2）篡改：消息在传输的过程中遭到第三方修改。</p>
<p>（3）否认：发送者在事后推翻自己先前的主张。</p>
<p>防止伪装、篡改、否认等威胁的技术，就是数字签名。</p>
<p>8.伪随机数生成器</p>
<p>9.隐写术：密码隐藏的是内容，而隐写术隐藏的是消息本身</p>
<h2><span id="历史密码">历史密码</span></h2><h3><span id="2-1凯撒密码">2-1凯撒密码</span></h3><h4><span id="1概念">1.概念</span></h4><p>通过将明文中所使用的字母表按照一定的字数”平移“来进行加密的密码。</p>
<p>如A→F，B→G</p>
<p>在此例中，密钥为5</p>
<h4><span id="2解密">2.解密</span></h4><p>将所有可能的密钥全部尝试一遍，这种方法称为<strong>暴力破解</strong>。由于这种方法的本质是从所有的密钥中找出正确的密钥，因此又称为<strong>穷举搜索</strong>。</p>
<h3><span id="2-2简单替换密码">2-2简单替换密码</span></h3><h4><span id="1概念">1.概念</span></h4><p>将明文中所使用的字母表替换为另一套字母表的密码。</p>
<h4><span id="2加密">2.加密</span></h4><p>依次将明文中的每一个字母按照替换表替换成另一个字母。</p>
<p>如A→B，B→Z</p>
<h4><span id="3解密">3.解密</span></h4><p>简单替换密码很难通过暴力破解来破译。</p>
<p>一种密码能够使用的所有密钥的集合称为密钥空间。</p>
<p>密钥空间越大，暴力破解越困难。</p>
<p>计算：n!(n是密码所用到的字符的种类)</p>
<p><strong>频率分析法</strong></p>
<p>①明文中的字母的出现频率&#x3D;密文中的字母的出现频率</p>
<p>②除了高频字母以外，低频字母也能够成为线索</p>
<p>③搞清开头和结尾能够成为线索，搞清单词之间的分隔也能成为线索</p>
<p>④密文越长越容易破译</p>
<p>⑤同一个字母连续出现能够成为线索（这是因为在简单替换密码中，某个字母在替换表中所对应的另一个字母是固定的）</p>
]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>【unity2d】【脚本】人物的移动、跳跃、动画</title>
    <url>/2024/08/08/%E3%80%90unity2d%E3%80%91%E3%80%90%E8%84%9A%E6%9C%AC%E3%80%91%E4%BA%BA%E7%89%A9%E7%9A%84%E7%A7%BB%E5%8A%A8%E3%80%81%E8%B7%B3%E8%B7%83%E3%80%81%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class PlayerController : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    Rigidbody2D rbody;//Rigidbody2D类型的变量</span><br><span class="line">    float axisH = 0.0f;//输入</span><br><span class="line">    public float speed = 3.0f;//移动速度</span><br><span class="line"></span><br><span class="line">    public float jump = 9.0f;//跳跃力</span><br><span class="line">    public LayerMask groundLayer;//可以落脚的层</span><br><span class="line">    bool goJump = false;//跳跃开始的旗标</span><br><span class="line">    bool onGround = false;//立于地面的旗标</span><br><span class="line">    Animator animator;//画师</span><br><span class="line">    public string stopAnime = &quot;PlayerStop&quot;;</span><br><span class="line">    public string moveAnime = &quot;PlayerMove&quot;;</span><br><span class="line">    public string jumpAnime = &quot;PlayerJump&quot;;</span><br><span class="line">    public string goalAnime = &quot;PlayerGoal&quot;;</span><br><span class="line">    public string deadAnime = &quot;PlayerDead&quot;;</span><br><span class="line">    string nowAnime = &quot;&quot;;</span><br><span class="line">    string oldAnime = &quot;&quot;;</span><br><span class="line">    </span><br><span class="line">    public static string gameState = &quot;playing&quot;;//游戏的状态</span><br><span class="line">    </span><br><span class="line">    // Start is called before the first frame update</span><br><span class="line">    void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        //取得Rugidbody2D</span><br><span class="line">        rbody = this.GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line">        gameState = &quot;playing&quot;;//设为游戏中</span><br><span class="line">        //取得Animator</span><br><span class="line">        animator = GetComponent&lt;Animator&gt;();</span><br><span class="line">        nowAnime = stopAnime;</span><br><span class="line">        oldAnime = stopAnime;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Update is called once per frame</span><br><span class="line">    void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        if (gameState != &quot;playing&quot;) return;</span><br><span class="line">        //检查水平方向的输入</span><br><span class="line">        axisH = Input.GetAxisRaw(&quot;Horizontal&quot;);</span><br><span class="line">        //方向调整</span><br><span class="line">        if (axisH &gt; 0.0f)</span><br><span class="line">        &#123;</span><br><span class="line">            //向右移动</span><br><span class="line">            Debug.Log(&quot;向右移动&quot;);</span><br><span class="line">            transform.localScale = new Vector2(1, 1);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (axisH &lt; 0.0f) &#123;</span><br><span class="line">            //向左移动</span><br><span class="line">            Debug.Log(&quot;向左移动&quot;);</span><br><span class="line">            transform.localScale = new Vector2(-1, 1);//左右翻转</span><br><span class="line">        &#125;</span><br><span class="line">        if (Input.GetButtonDown(&quot;Jump&quot;))</span><br><span class="line">        &#123;</span><br><span class="line">            Jump();//跳跃</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void FixedUpdate()</span><br><span class="line">    &#123;</span><br><span class="line">        if (gameState != &quot;playing&quot;) return;</span><br><span class="line">        //地面判定</span><br><span class="line">         bool onGround = Physics2D.Linecast(transform.position, transform.position - (transform.up * 0.1f), groundLayer);</span><br><span class="line">        if (onGround || axisH != 0)</span><br><span class="line">        &#123;</span><br><span class="line">            //在地面上或速度不为0</span><br><span class="line">            //更新速度</span><br><span class="line">            rbody.velocity = new Vector2(axisH * speed, rbody.velocity.y);</span><br><span class="line">        &#125;</span><br><span class="line">        if (goJump)//if(onGround &amp;&amp;goJump)</span><br><span class="line">        &#123;</span><br><span class="line">            //在地面上按下了跳跃键</span><br><span class="line">            //跳起来</span><br><span class="line">            Debug.Log(&quot;跳跃！&quot;);</span><br><span class="line">            Vector2 jumpPw = new Vector2(0, jump);//新建用于跳跃的向量</span><br><span class="line">            rbody.AddForce(jumpPw, ForceMode2D.Impulse);//施加瞬间的力</span><br><span class="line">            goJump = false;//取下跳跃旗标</span><br><span class="line">        &#125;</span><br><span class="line">        if (axisH != 0 || axisH == 0)//if(onGround)</span><br><span class="line">        &#123;</span><br><span class="line">            //在地面上</span><br><span class="line">            if (axisH == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                nowAnime = stopAnime;//停止</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                nowAnime = moveAnime;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            //空中</span><br><span class="line">            nowAnime = jumpAnime;</span><br><span class="line">        &#125;</span><br><span class="line">        if (nowAnime != oldAnime)</span><br><span class="line">        &#123;</span><br><span class="line">            oldAnime = nowAnime;</span><br><span class="line">            animator.Play(nowAnime);//播放动画效果</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //跳跃</span><br><span class="line">    public void Jump()</span><br><span class="line">    &#123;</span><br><span class="line">        goJump = true;</span><br><span class="line">        Debug.Log(&quot;按下了跳跃键！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //接触开始</span><br><span class="line">    void OnTriggerEnter2D(Collider2D collision)</span><br><span class="line">    &#123;</span><br><span class="line">        if (collision.gameObject.tag == &quot;Goal&quot;)&#123;</span><br><span class="line">            Goal();</span><br><span class="line">        &#125;else if (collision.gameObject.tag == &quot;Dead&quot;)</span><br><span class="line">        &#123;</span><br><span class="line">            GameOver(); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //到达终点</span><br><span class="line">    public void Goal()</span><br><span class="line">    &#123;</span><br><span class="line">        animator.Play(goalAnime);</span><br><span class="line">        gameState = &quot;gameclear&quot;;</span><br><span class="line">        GameStop();//游戏停止</span><br><span class="line">    &#125;</span><br><span class="line">    //游戏失败</span><br><span class="line">    public void GameOver()</span><br><span class="line">    &#123;</span><br><span class="line">        animator.Play(deadAnime);</span><br><span class="line">        gameState = &quot;gameover&quot;;</span><br><span class="line">        GameStop();</span><br><span class="line">        GetComponent&lt;CapsuleCollider2D&gt;().enabled=false;</span><br><span class="line">        rbody.AddForce(new Vector2(0,5),ForceMode2D.Impulse);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">//游戏停止</span><br><span class="line">void GameStop()</span><br><span class="line">    &#123;</span><br><span class="line">    Rigidbody2D rbody = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line">    rbody.velocity = new Vector2(0, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>unity2d</tag>
      </tags>
  </entry>
  <entry>
    <title>OS复习笔记 划重点版</title>
    <url>/2024/12/16/OS%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%88%92%E9%87%8D%E7%82%B9%E7%89%88/</url>
    <content><![CDATA[<h2><span id="第一章">第一章</span></h2><h3><span id="选择题">【选择题】</span></h3><p><strong>1.操作系统的功能</strong></p>
<p>①<u>存储器</u>管理功能——内存分配、地址映射、内存保护、内存扩充。</p>
<p>②<u>处理机</u>管理功能——作业和进程调度、进程通信。</p>
<p>③<u>设备</u>管理功能——缓冲区管理、设备分配、设备驱动、设备无关性。</p>
<p>④<u>文件</u>管理功能——文件存储空间的管理、目录管理、文件的读写管理和存取控制。</p>
<p>⑤<u>用户接口</u>——命令界面、图形界面、程序界面。</p>
<p><strong>2.各个操作系统都注重什么特征</strong></p>
<p>①多道批处理操作系统——多道、成批。</p>
<p>②分时操作系统——交互。同时性（多个用户运行）、交互性、独占性、及时性。</p>
<p>③实时操作系统——严格要求响应时间、可靠性。</p>
<p>④嵌入式操作系统——小、精简、专用性。</p>
<h3><span id="简答题">【简答题】</span></h3><p>&#x3D;&#x3D;<strong>1.什么是操作系统</strong>&#x3D;&#x3D;</p>
<p>①是最基本和最重要的<u>系统软件</u>。</p>
<p>②<u>管理和控制了计算机系统资源</u>。</p>
<p>③为用户<u>提供服务</u>。</p>
<p>&#x3D;&#x3D;<strong>2.操作系统的目标</strong>&#x3D;&#x3D;</p>
<p>①<u>方便性</u>：用户操作只需要输入命令或者用鼠标点击就可以了。</p>
<p>②<u>有效性</u>：计算机系统资源得到有效使用。</p>
<p>③<u>可扩展性</u>：操作系统的功能会不断升级。</p>
<p>**&#x3D;&#x3D;3.操作系统的特征&#x3D;&#x3D;**（并发和共享导致了异步）</p>
<p>①<u>并发性</u>：宏观上多道程序<u>同时运行</u>。</p>
<p>（并发指的是宏观上并行、微观上交替；区别于并行）</p>
<p>②<u>异步性</u>：各个程序<u>不是一直在运行</u>的，什么时候运行、运行多久是不可预知的。</p>
<p>③<u>资源共享性</u>：资源可以被访问者<u>共同使用</u>。分为互斥共享方式和同步共享方式。</p>
<h2><span id="第三章">第三章</span></h2><h3><span id="选择题">【选择题】</span></h3><p><strong>1.进程的概念</strong></p>
<p>（1）一些很细碎的概念</p>
<p><u>多道程序设计</u>是操作系统最重要的思想（本质是共享）。</p>
<p>现代操作系统的重要特点是<u>程序的并发执行、系统所拥有的资源被共享、系统用户随机地使用</u>。</p>
<p>操作系统的重要任务之一是使用户充分、有效地利用系统资源。</p>
<p><u>进程：计算机程序的执行过程、共享资源的基本单位。</u></p>
<p>程序的顺序性和计算机的顺序性是一致的。</p>
<p>程序的顺序执行的特点：顺序性、封闭性（结果由初始条件决定）、可再现性。</p>
<p>程序的并发执行的特点：间断性、失去封闭性、不可再现性。（一个程序的开始在另一个程序的结束之前，就是并发）</p>
<p>多道程序系统中程序执行环境的特点：独立性、随机性、资源共享。</p>
<p>（2）进程的描述</p>
<p>进程：程序在一个数据集合上的<u>运行过程</u>，是系统进行<u>资源分配</u>和调度的一个独立单位。</p>
<p>进程的特征：动态、并行、<u>独立、异步</u>、结构性。</p>
<p><strong>&#x3D;&#x3D;2.进程状态及其转换&#x3D;&#x3D;</strong></p>
<p>&#x3D;&#x3D;<strong>（1）状态转换图</strong>&#x3D;&#x3D;</p>
<img src="/2024/12/16/OS%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%88%92%E9%87%8D%E7%82%B9%E7%89%88/2820621e20b50021112272c76b66deb.jpg" alt="2820621e20b50021112272c76b66deb" style="zoom: 33%;">

<p><strong>（2）各状态的说明</strong></p>
<p>①运行——进程已获得CPU，正在运行。（在单处理机系统只有一个进程能够处于运行状态）</p>
<p>②就绪——进程已经获得除了CPU以外的所有必要资源，只要CPU在就可以立即运行。</p>
<p>③阻塞&#x2F;等待&#x2F;睡眠——正在运行的进程由于某种突发事件（如IO请求、申请缓冲区失败）而暂时无法运行。</p>
<p>④新建——对应于进程被创建时的状态，尚未进入就绪队列。</p>
<p>⑤完成——进程正常或非正常终止。</p>
<p><strong>&#x3D;&#x3D;（3）状态转换（<u>CPU空闲的三种情况：时间片到、等待事件发生、终止</u>）&#x3D;&#x3D;</strong></p>
<p>①新建→就绪：为新进程分配资源。</p>
<p>②就绪→运行：进程得到了CPU。</p>
<p>③运行→就绪：时间片（系统限定的最长时间）到了、出现比当前进程优先级高的进程。</p>
<p>④运行→阻塞：等待使用资源&#x2F;等待事件发生。</p>
<p>⑤阻塞→就绪：资源得到满足&#x2F;事件发生。</p>
<p>⑥运行→完成：释放资源。</p>
<h3><span id="简答题">【简答题】</span></h3><p><strong>&#x3D;&#x3D;1.进程的特征&#x3D;&#x3D;</strong></p>
<p>①异步性</p>
<p>②独立性</p>
<p>③并行性</p>
<p>④动态性</p>
<p>⑤结构性</p>
<p><strong>&#x3D;&#x3D;2.进程和程序的区别&#x3D;&#x3D;</strong></p>
<p>①进程具有<u>动态性</u>，强调执行过程；</p>
<p>程序具有<u>静态性</u>，是指令的有序集合。</p>
<p>②进程是<u>并行</u>的，程序不是。</p>
<p>③ <u>进程是竞争计算机系统资源的基本单位</u>，从而其并行性受到系统资源的制约。</p>
<p>④不同的进程可以对应不同程序，也可以为同一程序（只要所对应的数据集不同。</p>
<p>⑤作为被控制和管理的实体，除程序本身和所需数据集之外，应包括控制和管理信息。</p>
<p>&#x3D;&#x3D;3.进程状态及其转换&#x3D;&#x3D;</p>
<p>（看上面）</p>
<h2><span id="第四章">第四章</span></h2><h3><span id="选择题">【选择题】</span></h3><p><strong>1.多道程序设计</strong></p>
<p>多道程序设计引起资源共享，因此<u>对共享的资源进行调度</u>是必要的。</p>
<p>即使利用了中断，CPU仍有可能未得到充分的利用，因此需要允许多道用户程序同时处于活动状态。</p>
<p>多道程序设计的程度决定何时创建一个进程——创建的进程越多，每个进程可能执行的时间平均就越少。</p>
<p><strong>2.高级、中级和低级调度</strong></p>
<p>（1）高级调度——决定是否把进程添加到当前活跃的进程集合中（决定哪些进程进内存）。<u>作业调度、宏观调度</u>。</p>
<p>（2）中级调度——①属于<u>交换</u>（Swapping）功能的一部分。②在<u>内存和外存之间</u>。③<u>系统的并发度过高时，就将某些进程暂时交换到外存。</u>缓解内存空间紧张。</p>
<p>并发度的提高会：提高系统资源利用率；增加系统开销，降低进程速度，激烈资源竞争，死锁。</p>
<p>（3）低级调度——<u>真正</u>决定下一次执行哪一个就绪进程。<u>进程调度、处理机调度</u>。</p>
<p>低级调度的产生时机：一个进程执行结束、当前进程由于请求I&#x2F;O进入阻塞、以及分时系统中时间片到。</p>
<p><strong>3.实现实时调度的基本条件</strong></p>
<p>①提供必要的信息——就绪时间、开始截止时间和完成截止时间、处理时间、资源要求、优先级</p>
<p>②系统处理能力</p>
<p>③采用抢占式调度机制</p>
<p>④具有快速切换机制</p>
<p>4.实时调度的算法分类</p>
<p>(1) 根据任务性质：硬实时、软实时 </p>
<p>(2) <u>按调度方式</u>：非抢占式、抢占式 </p>
<p>(3) 按调度时间：静态、动态 </p>
<p>(4) 多处理机环境：集中式、分布式</p>
<p><strong>5.实时调度算法</strong>（待补充例题）</p>
<p>最重要的参考依据是：截止时间。</p>
<p>①最早截止时间优先EDF</p>
<p>根据任务的开始截止时间确定优先级。截止时间越早优先级越高。</p>
<p>②最低松弛度优先LLF</p>
<p>根据任务紧急的程度确定优先级。</p>
<p>松弛度&#x3D;必须完成的时间点-其本身需要的运行时间-当前时间</p>
<h3><span id="简答题">【简答题】</span></h3><p><strong>&#x3D;&#x3D;各种调度算法的侧重点和优缺点&#x3D;&#x3D;</strong></p>
<p><strong>①先来先服务FIFO——侧重于作业在系统的等待时间。</strong></p>
<p>优点：有利于长作业和CPU繁忙型作业。</p>
<p>缺点：可能造成CPU和IO设备都没有充分发挥。</p>
<p><strong>②短作业&#x2F;进程优先SJF——侧重于作业自身的估计运行时间。</strong></p>
<p>优点：提高整体性能，有利于短作业。</p>
<p>缺点：需要事先知道每个作业所需的处理机时间、长作业可能饿死、不利于分时系统（因为不可抢占）。</p>
<p><strong>③最高响应比HRP——侧重于响应时间比。</strong></p>
<p>优点：结合了先来先服务和短作业优先的特点，对待长短作业均衡，不会饿死。</p>
<p>缺点：大量计算，消耗CPU时间。不适合作业调度。</p>
<p><strong>④最短剩余时间SRT——侧重于预期剩余时间。抢占。</strong></p>
<p>优点：好于前面的非抢占式算法。</p>
<p>缺点：存在饥饿现象，不利于长作业。</p>
<p>⑤轮转RR——基于先来先服务和时钟</p>
<p>优点：主要用于分时系统中的进程调度。公平对待长短作业。</p>
<p>缺点：如果时间片太小，吞吐量会降低。不适合作业调度。</p>
<p><strong>⑥多级反馈队列MFQ</strong></p>
<p>优点：有利于IO繁忙型作业。</p>
<p>缺点：可能导致饥饿。</p>
<p><strong>⑦多级队列</strong></p>
<p><strong>⑧优先级法</strong></p>
<p>静态优先级、动态优先级（优先级应随着等待时间的增加而提高）</p>
<p>优点：资源利用率提高，公平性较好。</p>
<p>缺点：系统开销大，实现比较复杂，存在 “饥饿”现象。</p>
<h3><span id="计算题">【计算题】</span></h3><p>&#x3D;&#x3D;进程调度算法&#x3D;&#x3D;</p>
<p><strong>1.公式</strong></p>
<p>周转时间T&#x3D;<u>结束时间-到达时间</u></p>
<p>平均周转时间</p>
<p>带权周转时间W&#x3D;<u>周转时间 &#x2F; 服务时间</u>（也叫实际运行时间）</p>
<p>响应比R&#x3D;<u>（响应时间+运行时间）&#x2F;运行时间</u></p>
<p>响应时间&#x3D; <u>上个作业的结束时间-到达时间</u></p>
<p>系统响应时间&#x3D;时间片*就绪队列中进程的数目</p>
<p>2.先来先服务FCFS（不考）</p>
<p>3.短作业&#x2F;进程优先SJF</p>
<p>服务时间短的优先，同时需要考虑进程结束后下一个进程是否到达</p>
<p>4.最高响应比HRP</p>
<p>5.最短剩余时间SRT——抢占式版本的SJF</p>
<p>6.轮转RR</p>
<p>响应时间&#x3D;时间片长度*进程数</p>
<h2><span id="第五章">第五章</span></h2><h3><span id="选择题">【选择题】</span></h3><p>信号量的初值（初值应≥0，只能赋值一次）、进程释放后当前资源情况（比如几个进程在等待）</p>
<p>信号量的概念：信号量是一个记录型数据结构</p>
<p>除初始化外，仅能通过两个原子操作wait(S)和signal(S)来访问信号量，前者为P操作， 后者为V操作</p>
<p>信号量 S 的物理含义： </p>
<p>(1) S&gt;0——表示有S个资源可用</p>
<p>(2) S&#x3D;0——表示无资源可用 </p>
<p>(3) S&lt;0——则 |S| 表示等待队列中进程的个数</p>
<h3><span id="简答题">【简答题】</span></h3><p>临界区和进程互斥</p>
<p>&#x3D;&#x3D;<strong>临界区、临界资源、原则</strong>&#x3D;&#x3D;</p>
<p><strong>（1）临界资源：</strong>一次只允许一个进程使用的资源。</p>
<p><strong>（2）临界区：</strong>访问临界资源的那段程序。</p>
<p>相关临界区：多个进程的临界区。</p>
<p><strong>（3）原则：</strong></p>
<p>①<u>空闲让进</u>——当无进程在互斥区时，任何有权使用互斥区的进程都可进入。</p>
<p>②<u>忙则等待</u>——禁止两个以上的进程同时进入互斥区。</p>
<p>③<u>有限等</u><u>待</u>——任何进入互斥区的要求应在有限时间内得到满足。</p>
<p>④<u>让权等待</u>——让出CPU使用权，处于等待状态的进程应放弃CPU。以免进程陷入“忙等”。</p>
<p>【大题】——PV操作</p>
<h2><span id="第六章">第六章</span></h2><p>死锁中不可能只有一个进程。</p>
<h3><span id="选择题">【选择题】</span></h3><p>死锁的预防、避免、处理</p>
<p>当前是否安全（安全→不死锁，不安全→可能死锁可能不死锁）</p>
<p>资源分配图</p>
<h3><span id="简答题">【简答题】</span></h3><p><strong>1.死锁的必要条件</strong></p>
<p>①互斥条件</p>
<p>②请求和保持条件</p>
<p>③非剥夺条件</p>
<p>④循环等待条件</p>
<p><strong>2.死锁的预防</strong></p>
<p>①互斥条件——不能破坏，必须保持</p>
<p>②请求和保持条件——采用预先分配策略，一次性给（缺点：资源利用率低、可能饥饿）</p>
<p>③非剥夺条件——收回已分给进程且尚未使用完的资源</p>
<p>④循环等待条件——采用有序分配策略</p>
<p><strong>3.死锁的处理</strong></p>
<p>(1) 避免策略（预防、避免） 死锁不会发生 </p>
<p>(2) 解决策略（检测、解除） 死锁可能发生</p>
<p>4.死锁的避免</p>
<p>【大题】——银行家算法</p>
<p>1.当前是否死锁</p>
<p>2.找出安全序列</p>
<p>3.可分配？</p>
<h2><span id="第七章">第七章</span></h2><h3><span id="选择题">【选择题】</span></h3><p>程序的链接</p>
<p>程序的加载（加载后不一定是物理地址）</p>
<p>连续分配方式</p>
<p>【简答题】</p>
<p>基本分页分配方式（逻辑分页、物理分块，物理块之间可不连续）</p>
<p>分页、分段的区别</p>
<p>可变分区分配的4个算法</p>
<p>【大题】——和第八章一起考</p>
<p>逻辑地址转换为物理地址</p>
<p>十进制、十六进制、缺页率</p>
<p>一个在内存不用调入，一个不在内存要调入（用到页面置换算法，LRU,CLOCK,FIFO）</p>
<p>第八章</p>
<p>【选择题】</p>
<p>最优页面置换</p>
<p>先进先出置换</p>
<p>最近最少使用置换</p>
<p>时钟算法</p>
<p>【简答题】</p>
<p>伙伴算法</p>
<p>第九章</p>
<p>【简答题】</p>
<p>IO设备数据传输控制方式（程序直接、中断、DMA、通道）</p>
<p>磁盘访问时间的组成</p>
<p>SPOOLING系统</p>
<p>【大题】</p>
<p>磁盘调度算法</p>
<p>第十章</p>
<p>【简答题】</p>
<p>FAT</p>
<p>位示图</p>
<p>UNIX成组链接（只适用磁盘管理）</p>
<p>【大题】</p>
<p>索引结构+文件占用大小</p>
]]></content>
      <tags>
        <tag>2024-2025-1课内笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>【python】数据采集的基本知识</title>
    <url>/2024/05/29/%E3%80%90python%E3%80%91%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>记录了在书上看到的一些方法，大体有用，不过代码本身有点老</p>
<!-- toc -->

<ul>
<li><a href="#%E4%BD%BF%E7%94%A8request%E5%BA%93%E8%AF%B7%E6%B1%82%E7%BD%91%E7%AB%99">使用request库请求网站</a><ul>
<li><a href="#%E4%B8%80-%E7%88%AC%E8%99%AB%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86">一、爬虫的基本原理</a></li>
<li><a href="#%E4%BA%8C-%E4%BD%BF%E7%94%A8get%E6%96%B9%E5%BC%8F%E6%8A%93%E5%8F%96%E6%95%B0%E6%8D%AE">二、使用GET方式抓取数据</a></li>
<li><a href="#%E4%B8%89-%E4%BD%BF%E7%94%A8post%E6%96%B9%E5%BC%8F%E6%8A%93%E5%8F%96%E6%95%B0%E6%8D%AE">三、使用POST方式抓取数据</a></li>
</ul>
</li>
<li><a href="#%E4%BD%BF%E7%94%A8beautiful-soup%E8%A7%A3%E6%9E%90%E7%BD%91%E9%A1%B5">使用Beautiful Soup解析网页</a><ul>
<li><a href="#1%E7%94%A8get%E6%8A%93%E5%8F%96%E6%95%B0%E6%8D%AE">1.用get抓取数据</a></li>
<li><a href="#2%E6%8F%90%E5%8F%96%E6%95%B0%E6%8D%AE">2.提取数据</a></li>
<li><a href="#3%E5%A4%84%E7%90%86%E7%BD%91%E9%A1%B5%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98">3.处理网页编码问题</a></li>
<li><a href="#4%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E5%BC%82%E5%B8%B8">4.处理网络异常</a></li>
<li><a href="#5%E7%BD%91%E9%A1%B5%E6%95%B0%E6%8D%AE%E6%8F%90%E5%8F%96%E6%8A%80%E5%B7%A7">5.网页数据提取技巧</a></li>
<li><a href="#6%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97">6.数据清洗</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<p>[TOC]</p>
<h1><span id="使用request库请求网站">使用request库请求网站</span></h1><h3><span id="一-爬虫的基本原理">一、爬虫的基本原理</span></h3><h4><span id="1网页请求的过程">1.网页请求的过程</span></h4><p>（1）Request（请求）</p>
<p>（2）Response（相应）</p>
<h4><span id="2网页请求的方式">2.网页请求的方式</span></h4><p>（1）GET：参数设置在URL中，是大多数网站的使用方式，只需一次发送和返回，响应速度快</p>
<p>（2）POST：通过request body传递参数，相比GET，可发送请求的信息大</p>
<h3><span id="二-使用get方式抓取数据">二、使用GET方式抓取数据</span></h3><p>复制任意一条首页首条新闻的标题，在源码页面按ctrl+F调出搜索框，将标题粘贴到搜索框，按回车。</p>
<p>标题在源码可以被搜索到，请求对象是www.***.cn，请求方式是GET。</p>
<p>确定好请求对象和方式后，输入代码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests #导入reques包</span><br><span class="line">url=&#x27;https://www3.nhk.or.jp/news/&#x27; #这里选择的是NHK新闻网</span><br><span class="line">strhtml=requests.get(url) #GET方式，并把获取到的数据保存在strhtml变量</span><br><span class="line">print(strhtml.text)</span><br></pre></td></tr></table></figure>

<p><img src="/2024/05/29/%E3%80%90python%E3%80%91%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240529161828.png" alt="微信截图_20240529161828"></p>
<h3><span id="三-使用post方式抓取数据">三、使用POST方式抓取数据</span></h3><p>进入某翻译页面，按快捷键ctrl+shift+i进入开发者模式（F12也可以），在翻译页面输入文本并点击翻译。</p>
<p>在开发者模式中点击“网络”→“XHR”，在“负载”中找到翻译数据，单击“标头”，发现请求数据的方式为POST。</p>
<p>找到数据所在之处并且明确请求方式之后，接下来开始写代码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import json</span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line"># POST请求的目标URL</span><br><span class="line">def get_translate_date(word=None):</span><br><span class="line">    url = &quot;https://dict.youdao.com/webtranslate&quot;</span><br><span class="line">    Form_data = &#123;</span><br><span class="line">        &quot;type&quot;:&quot;AUTO&quot;,</span><br><span class="line">        &quot;i&quot;:&quot;i love python&quot;,</span><br><span class="line">        &quot;doctype&quot;:&quot;json&quot;,</span><br><span class="line">        &quot;xmlVersion&quot;:&quot;1.8&quot;,</span><br><span class="line">        &quot;keyfrom&quot;:&quot;fanyi.web&quot;,</span><br><span class="line">        &quot;ue&quot;:&quot;UTF-8&quot;,</span><br><span class="line">        &quot;action&quot;:&quot;FY_BY_ENTER&quot;,</span><br><span class="line">        &quot;typoResult&quot;:&quot;true&quot;</span><br><span class="line">&#125;</span><br><span class="line">    #使用requests.post请求表单数据</span><br><span class="line">    response = requests.post(url, data=Form_data)</span><br><span class="line">    #将字符串格式转换成json格式的数据，并提取打印</span><br><span class="line">    content = json.loads(response.text)</span><br><span class="line">    print(content[&#x27;translateResult&#x27;][0][0][&#x27;tgt&#x27;])</span><br><span class="line"></span><br><span class="line">get_translate_date(&#x27;好的&#x27;)</span><br></pre></td></tr></table></figure>



<h1><span id="使用beautiful-soup解析网页">使用Beautiful Soup解析网页</span></h1><h3><span id="1用get抓取数据">1.用get抓取数据</span></h3><h3><span id="2提取数据">2.提取数据</span></h3><p>用选择器（select）定位数据：把鼠标光标移动到要定位的标题-右键-检查-复制selector</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#调用bs4库</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line"></span><br><span class="line">import requests</span><br><span class="line">url=(&#x27;https://www3.nhk.or.jp/shutoken-news/nhk_shutoken.xml?_=1716982796021&#x27;)</span><br><span class="line">strhtml=requests.get(url)</span><br><span class="line">print(strhtml.text)</span><br><span class="line"></span><br><span class="line">#使用lxml解析网页文档</span><br><span class="line">soup=BeautifulSoup(strhtml.text,&#x27;lxml&#x27;)</span><br><span class="line">data=soup.select(&#x27;#main &gt; article.module.module--news-main.index-main &gt; &#x27;</span><br><span class="line">                 &#x27;section &gt; div.content--header &gt; div &gt; h1 &gt; a &gt; em&#x27;)</span><br><span class="line">print(data)</span><br></pre></td></tr></table></figure>

<p><img src="/2024/05/29/%E3%80%90python%E3%80%91%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240529195222.png" alt="微信截图_20240529195222"></p>
<h3><span id="3处理网页编码问题">3.处理网页编码问题</span></h3><p>当爬取网页时，经常会遇到不同网页使用不同编码格式的情况。在处理网页编码问题时，我们可以使用 Requests 库的编码自动识别功能。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 处理网页编码问题</span><br><span class="line">response.encoding = response.apparent_encoding</span><br><span class="line">print(response.text)</span><br></pre></td></tr></table></figure>

<h3><span id="4处理网络异常">4.处理网络异常</span></h3><p>在实际应用中，网络异常是常见的情况。为了保证爬虫的稳定性，应该对网络异常进行适当处理。我们可以使用 Try-Except 来捕获异常情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">    response = requests.get(url)</span><br><span class="line">    response.raise_for_status()</span><br><span class="line">except requests.exceptions.RequestException as e:</span><br><span class="line">    print(&quot;Error: %s&quot; % e)</span><br></pre></td></tr></table></figure>



<h3><span id="5网页数据提取技巧">5.网页数据提取技巧</span></h3><h4><span id="1提取文本信息">（1）提取文本信息</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line">url = &#x27;https://example.com&#x27;</span><br><span class="line">response = requests.get(url)</span><br><span class="line">soup = BeautifulSoup(response.content, &#x27;html.parser&#x27;)</span><br><span class="line">text = soup.get_text()</span><br><span class="line">print(text)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4><span id="2提取图片信息">（2）提取图片信息</span></h4><p>将输出网页中所有图片的链接地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line">url = &#x27;https://example.com&#x27;</span><br><span class="line">response = requests.get(url)</span><br><span class="line">soup = BeautifulSoup(response.content, &#x27;html.parser&#x27;)</span><br><span class="line">images = soup.find_all(&#x27;img&#x27;)</span><br><span class="line">for img in images:</span><br><span class="line">    print(img[&#x27;src&#x27;])</span><br></pre></td></tr></table></figure>

<h4><span id="3提取表格信息">（3）提取表格信息</span></h4><p>按行或按列提取表格数据中的内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line">url = &#x27;https://example.com&#x27;</span><br><span class="line">response = requests.get(url)</span><br><span class="line">soup = BeautifulSoup(response.content, &#x27;html.parser&#x27;)</span><br><span class="line">table = soup.find(&#x27;table&#x27;)</span><br><span class="line">rows = table.find_all(&#x27;tr&#x27;)</span><br><span class="line">for row in rows:</span><br><span class="line">    cells = row.find_all(&#x27;td&#x27;)</span><br><span class="line">    for cell in cells:</span><br><span class="line">        print(cell.text)</span><br></pre></td></tr></table></figure>

<h4><span id="4将数据保存在文件">（4）将数据保存在文件</span></h4><p>将数据保存到名为 <code>data.txt</code> 的文本文件中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data = [&#x27;data1&#x27;, &#x27;data2&#x27;, &#x27;data3&#x27;]</span><br><span class="line"></span><br><span class="line">with open(&#x27;data.txt&#x27;, &#x27;w&#x27;) as file:</span><br><span class="line">    for item in data:</span><br><span class="line">        file.write(item + &#x27;\n&#x27;)</span><br></pre></td></tr></table></figure>

<h4><span id="5将数据保存在数据库">（5）将数据保存在数据库</span></h4><p>数据存储到名为 <code>data.db</code> 的 SQLite 数据库表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import sqlite3</span><br><span class="line"></span><br><span class="line">conn = sqlite3.connect(&#x27;data.db&#x27;)</span><br><span class="line">cursor = conn.cursor()</span><br><span class="line"></span><br><span class="line">cursor.execute(&#x27;&#x27;&#x27;CREATE TABLE IF NOT EXISTS data_table (data text)&#x27;&#x27;&#x27;)</span><br><span class="line"></span><br><span class="line">data = [&#x27;data1&#x27;, &#x27;data2&#x27;, &#x27;data3&#x27;]</span><br><span class="line"></span><br><span class="line">for item in data:</span><br><span class="line">    cursor.execute(&quot;INSERT INTO data_table (data) VALUES (?)&quot;, (item,))</span><br><span class="line"></span><br><span class="line">conn.commit()</span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure>

<h4><span id="6将数据保存在表格中">（6）将数据保存在表格中</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line">data = &#123;&#x27;A&#x27;: [1, 2, 3], &#x27;B&#x27;: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]&#125;</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"></span><br><span class="line">df.to_excel(&#x27;data.xlsx&#x27;, index=False)</span><br></pre></td></tr></table></figure>



<h3><span id="6数据清洗">6.数据清洗</span></h3><h4><span id="处理提取数据中的异常情况">处理提取数据中的异常情况</span></h4><p>在爬虫过程中，数据有可能存在缺失、重复或异常格式等问题，需要进行各种异常情况处理，以下是一些常见的数据异常情况处理方法：</p>
<ul>
<li>数据去重：使用集合或字典对数据进行去重处理。</li>
<li>缺失值处理：填充缺失值、删除缺失值、插值填充等方法。</li>
<li>异常值处理：判断异常值的范围或利用异常检测算法进行处理。</li>
</ul>
<h4><span id="数据清洗技巧">数据清洗技巧</span></h4><p>数据清洗是数据分析中至关重要的一环，有效的数据清洗可以提高数据质量和分析结果的准确性。以下是一些数据清洗的常用技巧：</p>
<ul>
<li>删除重复数据：通过唯一标识符或全部字段的对比删除重复数据。</li>
<li>处理缺失值：填充缺失值、删除缺失值或使用聚合值填充方法。</li>
<li>格式统一化：统一日期格式、字符串格式等，方便后续分析。</li>
<li>异常值处理：判断异常值的来源及处理方式，避免对结果产生误导。</li>
</ul>
<h4><span id="使用正则表达式辅助数据清洗">使用正则表达式辅助数据清洗</span></h4><p>正则表达式在数据清洗中起到了关键的作用，它可以帮助我们快速匹配和提取符合规则的数据。以下是一些正则表达式在数据清洗中的应用场景：</p>
<ul>
<li>提取文本中的特定模式数据，如手机号码、邮箱地址等。</li>
<li>对文本进行分割、替换和匹配，提取需要的信息。</li>
<li>清洗特殊字符，去除无效信息或格式化数据。</li>
</ul>
]]></content>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>上标、下标的字符显示</title>
    <url>/2024/04/02/%E4%B8%8A%E6%A0%87%E3%80%81%E4%B8%8B%E6%A0%87%E7%9A%84%E5%AD%97%E7%AC%A6%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<h3><span id></span></h3><h3><span id="一-上标">一、上标</span></h3><h4><span id="1数字">1.数字</span></h4><p>¹²³⁴⁵⁶⁷⁸⁹⁰⁺⁻⁼˂˃⁽⁾˙*′˙ⁿº</p>
<h4><span id="2字母">2.字母</span></h4><p>ᵃᵇᶜᵈᵉᶠᵍʰⁱʲᵏˡᵐⁿᵒᵖʳˢᵗᵘᵛʷˣʸᶻ</p>
<p>ᴬᴮᒼᴰᴱᶠᴳᴴᴵᴶᴷᴸᴹᴺᴼᴾᴼ̴ᴿˢᵀᵁⱽᵂˣᵞᙆ</p>
<h4><span id="3其他">3.其他</span></h4><p>ᵃ ᵇ ᶜ ᵈ ᵉ ᵍ ʰ ⁱ ʲ ᵏ ˡ ᵐ ⁿ ᵒ ᵖ ᵒ⃒ ʳ ˢ ᵗ ᵘ ᵛ ʷ ˣ ʸ ᙆ ᴬ ᴮ ᒼ ᴰ ᴱ ᴳ ᴴ ᴵ ᴶ ᴷ ᴸ ᴹ ᴺ ᴼ ᴾ ᴼ̴ ᴿ ˢ ᵀ ᵁ ᵂ ˣ ᵞ ᙆ ꝰ ˀ ˁ ˤ ꟸ ꭜ ʱ ꭝ ꭞ ʴ ʵ ʶ ꭟ ˠ ꟹ ᴭ ᴯ ᴲ ᴻ ᴽ ᵄ ᵅ ᵆ ᵊ ᵋ ᵌ ᵑ ᵓ ᵚ ᵝ ᵞ ᵟ ᵠ ᵡ ᵎ ᵔ ᵕ ᵙ ᵜ ᶛ ᶜ ᶝ ᶞ ᶟ ᶡ ᶣ ᶤ ᶥ ᶦ ᶧ ᶨ ᶩ ᶪ ᶫ ᶬ ᶭ ᶮ ᶯ ᶰ ᶱ ᶲ ᶳ ᶴ ᶵ ᶶ ᶷ ᶸ ᶹ ᶺ ᶼ ᶽ ᶾ ᶿ ꚜ ꚝ ჼ ᒃ ᕻ ᑦ ᒄ ᕪ ᑋ ᑊ ᔿ ᐢ ᣕ ᐤ ᣖ ᣴ ᣗ ᔆ ᙚ ᐡ ᘁ ᐜ ᕽ ᙆ ᙇ ᒼ ᣳ ᒢ ᒻ ᔿ ᐤ ᣖ ᣵ ᙚ ᐪ ᓑ ᘁ ᐜ ᕽ ᙆ ᙇ </p>
<h3><span id="二-下标">二、下标</span></h3><h4><span id="1数字">1.数字</span></h4><p>₀ ₁ ₂ ₃ ₄ ₅ ₆ ₇ ₈ ₉ ₊ ₋ ₌ ₍ ₎ ₐ ₑ ₒ ₓ ₔ ₕ ₖ ₗ ₘ ₙ ₚ ₛ ₜ</p>
<h4><span id="2字母">2.字母</span></h4><p>ₐ ₔ ₑ ₕ ᵢ ⱼ ₖ ₗ ₘ ₙ ₒ ₚ ᵣ ₛ ₜ ᵤ ᵥ ₓ ᙮ ᵤ ᵩ ᵦ ₗ ˪ ៳ ៷ ₒ ᵨ ₛ ៴ ᵤ ᵪ ᵧ</p>
]]></content>
      <tags>
        <tag>素材</tag>
      </tags>
  </entry>
  <entry>
    <title>stack容器基本知识</title>
    <url>/2024/04/03/stack%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>写作业的时候看到有人用stack容器做题，试了下效率起飞，二话不说记录一下XD</p>
<!-- toc -->

<ul>
<li><a href="#1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">1.基础知识</a><ul>
<li><a href="#%E5%A4%B4%E6%96%87%E4%BB%B6"><strong>头文件</strong></a></li>
<li><a href="#%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><strong>常用操作</strong></a></li>
<li><a href="#stack%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0">stack对象的默认构造</a></li>
<li><a href="#stack%E7%9A%84%E5%87%BA%E6%A0%88%E5%92%8C%E8%BF%9B%E6%A0%88">stack的出栈和进栈</a></li>
<li><a href="#stack%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E4%B8%8E%E8%B5%8B%E5%80%BC">stack的拷贝构造与赋值</a></li>
<li><a href="#stack%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96">stack的数据存取</a></li>
<li><a href="#stack%E7%9A%84%E5%A4%A7%E5%B0%8F">stack的大小</a></li>
</ul>
</li>
<li><a href="#2%E4%BE%8B%E9%A2%98">2.例题</a><ul>
<li><a href="#7-2-%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D"><strong>7-2 括号匹配</strong></a></li>
<li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">代码实现</a></li>
<li><a href="#7-3-%E5%9B%9E%E6%96%87%E5%88%A4%E6%96%AD"><strong>7-3 回文判断</strong></a></li>
<li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1">代码实现</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<p>[TOC]</p>
<h2><span id="1基础知识">1.基础知识</span></h2><h3><span id="头文件"><strong>头文件</strong></span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stack&gt;</span><br></pre></td></tr></table></figure>



<h3><span id="常用操作"><strong>常用操作</strong></span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stack&lt;int&gt; q;	//以int型为例</span><br><span class="line">int x;</span><br><span class="line">q.push(x);		//将x压入栈顶</span><br><span class="line">q.top();		//返回栈顶的元素</span><br><span class="line">q.pop();		//删除栈顶的元素</span><br><span class="line">q.size();		//返回栈中元素的个数</span><br><span class="line">q.empty();		//检查栈是否为空,若为空返回true,否则返回false</span><br></pre></td></tr></table></figure>

<h3><span id="stack对象的默认构造">stack对象的默认构造</span></h3><p>stack对象的默认构造形式： stack <t> stkT;  </t></p>
<p>尖括号里面还可以设置指针或者其他数据类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stack &lt;int&gt; stkInt;            //一个存放int的stack容器。</span><br><span class="line"></span><br><span class="line">stack &lt;float&gt; stkFloat;     //一个存放float的stack容器。</span><br><span class="line"></span><br><span class="line">stack &lt;string&gt; stkString;     //一个存放string的stack容器。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3><span id="stack的出栈和进栈">stack的出栈和进栈</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stack.push(elem);            //往栈头添加元素</span><br><span class="line"></span><br><span class="line">stack.pop();                     //往栈头移除第一个元素</span><br></pre></td></tr></table></figure>

<h3><span id="stack的拷贝构造与赋值">stack的拷贝构造与赋值</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stack(const stack &amp;stk);                  //拷贝构造函数</span><br><span class="line"></span><br><span class="line">stack&amp; operator = (const stack &amp;stk);          //重载等号操作符</span><br><span class="line"></span><br><span class="line">stack&lt;int&gt;stkIntB(stkIntA);            //拷贝构造</span><br><span class="line">stack&lt;int&gt;stkIntC;</span><br><span class="line">stkIntC = stkIntA;                     //赋值</span><br></pre></td></tr></table></figure>

<h3><span id="stack的数据存取">stack的数据存取</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stack.top();     //返回最后一个压入栈元素</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stack&lt;int&gt; stkIntA;</span><br><span class="line"></span><br><span class="line">stkIntA.push(1);</span><br><span class="line"></span><br><span class="line">stkIntA.push(3);</span><br><span class="line"></span><br><span class="line">stkIntA.push(5);</span><br><span class="line"></span><br><span class="line">stkIntA.push(7);</span><br><span class="line"></span><br><span class="line">stkIntA.push(9);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">int iTop = stkIntA.top(); //9</span><br><span class="line"></span><br><span class="line">stkIntA.top() = 19; //19</span><br></pre></td></tr></table></figure>

<h3><span id="stack的大小">stack的大小</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stack.empty();                    //判断堆栈是否为空</span><br><span class="line"></span><br><span class="line">stack.size();                        //返回堆栈的大小</span><br></pre></td></tr></table></figure>



<h2><span id="2例题">2.例题</span></h2><h3><span id="7-2-括号匹配"><strong>7-2 括号匹配</strong></span></h3><p>给定一串字符，不超过100个字符，可能包括括号、数字、字母、标点符号、空格，编程检查这一串字符中的( ) ,[ ],{ }是否匹配。</p>
<p><strong>输入格式:</strong></p>
<p>输入在一行中给出一行字符串，不超过100个字符，可能包括括号、数字、字母、标点符号、空格。</p>
<p><strong>输出格式:</strong></p>
<p>如果括号配对，输出yes，否则输出no。</p>
<p><strong>输入样例1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sin(10+20)</span><br></pre></td></tr></table></figure>

<p><strong>输出样例1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yes</span><br></pre></td></tr></table></figure>

<p><strong>输入样例2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;[&#125;]</span><br></pre></td></tr></table></figure>

<p><strong>输出样例2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">no</span><br></pre></td></tr></table></figure>

<p><strong>输入样例3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(()())</span><br></pre></td></tr></table></figure>

<p><strong>输出样例3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yes</span><br></pre></td></tr></table></figure>

<h3><span id="代码实现">代码实现</span></h3><p>c&#x2F;c++ strlen(str)和str.length()和str.size()都可以求字符串长度。<br>其中**str.length()<strong>和</strong>str.size()**是用于求string类对象的成员函数<br>**strlen(str)*<em>是用于求字符数组的长度，其参数是char</em>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include&lt;stack&gt; //stack头文件</span><br><span class="line">int judge(string s)&#123;</span><br><span class="line">    stack&lt;char&gt;stk;//设置一个存放char的stack容器</span><br><span class="line">    for(int i=0;i&lt;s.length();i++)&#123;</span><br><span class="line">        switch(s[i])&#123;</span><br><span class="line">                case&#x27;(&#x27;:</span><br><span class="line">                   stk.push(s[i]);//左括号，进栈</span><br><span class="line">                break;</span><br><span class="line">                case&#x27;[&#x27;:</span><br><span class="line">                   stk.push(s[i]);</span><br><span class="line">                break;</span><br><span class="line">                case&#x27;&#123;&#x27;:</span><br><span class="line">                   stk.push(s[i]);</span><br><span class="line">                break;</span><br><span class="line">                case&#x27;)&#x27;:</span><br><span class="line">                   if(stk.empty()) return 0;//如果栈空，返回0</span><br><span class="line">                   if (stk.top() == &#x27;(&#x27;) stk.pop();</span><br><span class="line">                   //如果栈顶是左括号，配对成功，将其出栈，进行下一步</span><br><span class="line">                   else return 0;</span><br><span class="line">                break;</span><br><span class="line">                case&#x27;]&#x27;:</span><br><span class="line">                   if(stk.empty()) return 0;</span><br><span class="line">                   if (stk.top() == &#x27;[&#x27;) stk.pop();</span><br><span class="line">                   else return 0;</span><br><span class="line">                break;</span><br><span class="line">                case&#x27;&#125;&#x27;:</span><br><span class="line">                   if(stk.empty()) return 0;</span><br><span class="line">                   if (stk.top() == &#x27;&#123;&#x27;) stk.pop();</span><br><span class="line">                   else return 0;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return stk.empty();//最终若括号一一配对，栈空，返回1值</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    string s;</span><br><span class="line">    getline(cin,s);</span><br><span class="line">    if(judge(s)==1)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;yes&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        cout&lt;&lt;&quot;no&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="7-3-回文判断"><strong>7-3 回文判断</strong></span></h3><p>回文是指正读反读均相同的字符序列，如“abba”和“abdba”均是回文，但“good”不是回文。编写一个程序，使用栈判定给定的字符序列是否为回文。</p>
<p>若用C++，可借助STL的容器实现。</p>
<p><strong>输入格式:</strong></p>
<p>输入待判断的字符序列，按回车键结束，字符序列长度&lt;20。</p>
<p><strong>输出格式:</strong></p>
<p>若字符序列是回文，输出“YES”；否则，输出“NO”。</p>
<p><strong>输入样例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abdba</span><br></pre></td></tr></table></figure>

<p><strong>输出样例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">YES</span><br></pre></td></tr></table></figure>

<h3><span id="代码实现">代码实现</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">    string s;</span><br><span class="line">    int flag;</span><br><span class="line">    getline(cin,s);</span><br><span class="line">    stack&lt;char&gt;stk;</span><br><span class="line">    for(int i=0;i&lt;s.length();i++)&#123;</span><br><span class="line">        stk.push(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    for(int i=0;i&lt;s.length()/2;i++)&#123;</span><br><span class="line">        flag=0;</span><br><span class="line">        if(s[i]==stk.top())&#123;</span><br><span class="line">            stk.pop();</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;</span><br><span class="line">            flag=1;</span><br><span class="line">            break;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(flag==0) cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>【离散数学】集合、关系</title>
    <url>/2024/05/26/%E3%80%90%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E3%80%91%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#%E4%B8%80-%E9%9B%86%E5%90%88%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E8%A1%A8%E7%A4%BA">一、集合的概念和表示</a><ul>
<li><a href="#%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A">名词解释</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C-%E9%9B%86%E5%90%88%E8%BF%90%E7%AE%97">二、集合运算</a><ul>
<li><a href="#1%E8%BF%90%E7%AE%97">1.运算</a></li>
<li><a href="#2%E6%80%A7%E8%B4%A8">2.性质</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89-%E5%8C%85%E5%90%AB%E6%8E%92%E6%96%A5%E5%8E%9F%E7%90%86">三、包含排斥原理</a><ul>
<li><a href="#1%E6%A6%82%E5%BF%B5">1.概念</a></li>
<li><a href="#2%E4%BE%8B%E9%A2%98">2.例题</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9B-%E5%BA%8F%E5%81%B6%E4%B8%8E%E7%AC%9B%E5%8D%A1%E5%B0%94%E7%A7%AF">四、序偶与笛卡尔积</a><ul>
<li><a href="#1%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A%E5%92%8C%E5%8E%9F%E7%90%86">1.名词解释和原理</a></li>
<li><a href="#2%E4%BE%8B%E9%A2%98-1">2.例题</a></li>
</ul>
</li>
<li><a href="#%E4%BA%94-%E5%85%B3%E7%B3%BB%E5%8F%8A%E5%85%B6%E8%A1%A8%E7%A4%BA">五、关系及其表示</a><ul>
<li><a href="#1%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A%E5%92%8C%E5%8E%9F%E7%90%86-1">1.名词解释和原理</a></li>
<li><a href="#2%E4%BE%8B%E9%A2%98-2">2.例题</a></li>
</ul>
</li>
<li><a href="#%E5%85%AD-%E5%85%B3%E7%B3%BB%E7%9A%84%E6%80%A7%E8%B4%A8">六、关系的性质</a><ul>
<li><a href="#%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A-1">名词解释</a></li>
<li><a href="#%E4%BE%8B%E9%A2%98">例题</a></li>
</ul>
</li>
<li><a href="#%E4%B8%83-%E5%A4%8D%E5%90%88%E5%85%B3%E7%B3%BB%E5%92%8C%E9%80%86%E5%85%B3%E7%B3%BB">七、复合关系和逆关系</a><ul>
<li><a href="#1%E5%90%8D%E8%AF%8D%E5%92%8C%E5%AE%9A%E7%90%86">1.名词和定理</a></li>
<li><a href="#2%E4%BE%8B%E9%A2%98-3">2.例题</a></li>
</ul>
</li>
<li><a href="#%E5%85%AB-%E9%97%AD%E5%8C%85%E8%BF%90%E7%AE%97">八、闭包运算</a></li>
</ul>
<!-- tocstop -->

<p>[TOC]</p>
<h2><span id="一-集合的概念和表示">一、集合的概念和表示</span></h2><h3><span id="名词解释">名词解释</span></h3><h4><span id="集合">集合</span></h4><p>把具有共同性质的一些东西汇集成一个整体，就形成一个集合。</p>
<h4><span id="元素">元素</span></h4><p>汇集成集合的事物叫元素。</p>
<p>描述：元素x属于集合A</p>
<p>记作：x∈A</p>
<h4><span id="子集">子集</span></h4><p>描述：A集合是B集合的子集</p>
<p>记作：A ⊆ B</p>
<h4><span id="真子集">真子集</span></h4><p>描述 : A集合是B集合的子集 , 并且 A &#x3D;̸ B，则称A集合是B集合的真子集</p>
<p>记作 : A ⊂ B</p>
<p><u>真包含关系的性质：</u></p>
<ul>
<li><strong>反自反性</strong>: A ⊄ A</li>
<li><strong>反对称性</strong>: 如果 A ⊂ B，那么 B ⊄ A</li>
<li><strong>传递性</strong>: 如果 A ⊂ B, 并且 B ⊂ C, 那么 A ⊂ C</li>
</ul>
<h4><span id="非真子集">非真子集</span></h4><p>描述 : 存在元素x是集合A的元素，不是集合B的元素，并且A、B不相等，则称A集合不是B集合的真子集</p>
<p>记作 : A ⊄ B</p>
<h4><span id="空集">空集</span></h4><p>描述 : 没有任何元素的集合 , 称为空集合 , 简称为空集 </p>
<p>记作 : ∅</p>
<ul>
<li>x无解→空集</li>
<li>空集是一切集合的子集</li>
<li>空集是唯一的</li>
<li>{∅} ≠ ∅</li>
<li>对任何一个集合A，∅ ⊆ A</li>
</ul>
<h4><span id="全集">全集</span></h4><p>限定所讨论的集合 , 都是某个集合的子集 , 则称该集合为全集 , 记作 E</p>
<h4><span id="幂集">幂集</span></h4><p>描述 : A集合的全体子集组成的集合称为 A的幂集 ;</p>
<p>记作 : P ( A )</p>
<p>幂集个数定理 : 集合 A中的元素个数∣ A ∣ &#x3D; n ，则 A的 幂集个数 ∣ P ( A ) ∣ &#x3D; 2ⁿ</p>
<h4><span id="外延性原理">外延性原理</span></h4><p>两个集合是相等的，当且仅当它们有相同的成员。（两个集合A和B相等，记作A &#x3D; B）</p>
<p>集合A和集合B相等的充分必要条件是这两个集合互为子集。</p>
<h2><span id="二-集合运算">二、集合运算</span></h2><h3><span id="1运算">1.运算</span></h3><p><img src="/2024/05/26/%E3%80%90%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E3%80%91%E9%9B%86%E5%90%88/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240526213445.png" alt="微信图片_20240526213445"></p>
<h3><span id="2性质">2.性质</span></h3><p><img src="/2024/05/26/%E3%80%90%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E3%80%91%E9%9B%86%E5%90%88/e2067441ba7746f0b650c1e43d9e64ef.png" alt="在这里插入图片描述"></p>
<p><img src="/2024/05/26/%E3%80%90%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E3%80%91%E9%9B%86%E5%90%88/87c29f238b2a41818fd3187d7829d652.png" alt="在这里插入图片描述"></p>
<p><img src="/2024/05/26/%E3%80%90%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E3%80%91%E9%9B%86%E5%90%88/dd8be408e0b24359b25f7ddefbf425eb.png" alt="在这里插入图片描述"></p>
<p><img src="/2024/05/26/%E3%80%90%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E3%80%91%E9%9B%86%E5%90%88/5dda146382eb4276a8a6ec029c2d4b42.png" alt="在这里插入图片描述"></p>
<p><img src="/2024/05/26/%E3%80%90%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E3%80%91%E9%9B%86%E5%90%88/8fdd73e243d841179f607fba34a9e141.png" alt="在这里插入图片描述"></p>
<p><img src="/2024/05/26/%E3%80%90%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E3%80%91%E9%9B%86%E5%90%88/255afd2714574225b2e84a5f04b48c5e.png" alt="在这里插入图片描述"></p>
<p><img src="/2024/05/26/%E3%80%90%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E3%80%91%E9%9B%86%E5%90%88/80456386fbfb4c72b4f4144838eea10d.png" alt="在这里插入图片描述"></p>
<p><img src="/2024/05/26/%E3%80%90%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E3%80%91%E9%9B%86%E5%90%88/0da7a50fde1f474d8f18293ee9f488ef.png" alt="在这里插入图片描述"></p>
<h2><span id="三-包含排斥原理">三、包含排斥原理</span></h2><h3><span id="1概念">1.概念</span></h3><p><img src="/2024/05/26/%E3%80%90%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E3%80%91%E9%9B%86%E5%90%88/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240526213441.png" alt="微信图片_20240526213441"></p>
<p><img src="/2024/05/26/%E3%80%90%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E3%80%91%E9%9B%86%E5%90%88/7d8cec1b0d80461b967e6d29f39c7288.png" alt="在这里插入图片描述"></p>
<p><img src="/2024/05/26/%E3%80%90%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E3%80%91%E9%9B%86%E5%90%88/97dfee6601d240678de51b656d2e2269.png" alt="在这里插入图片描述"></p>
<p><img src="/2024/05/26/%E3%80%90%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E3%80%91%E9%9B%86%E5%90%88/d260fc358e8a4abfbec140f60d714566.png" alt="在这里插入图片描述"></p>
<h3><span id="2例题">2.例题</span></h3><p><img src="/2024/05/26/%E3%80%90%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E3%80%91%E9%9B%86%E5%90%88/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240526212553.png" alt="微信截图_20240526212553"></p>
<h2><span id="四-序偶与笛卡尔积">四、序偶与笛卡尔积</span></h2><h3><span id="1名词解释和原理">1.名词解释和原理</span></h3><h4><span id="序偶">序偶</span></h4><p>有序二元组的称呼，可以看作一个有顺序的集合，记作&lt;A,B&gt;</p>
<p>序偶不同于集合的是序偶是有顺序的，&lt;A,B&gt; !&#x3D; &lt;B,A&gt;</p>
<h4><span id="n元组">n元组</span></h4><p><img src="/2024/05/26/%E3%80%90%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E3%80%91%E9%9B%86%E5%90%88/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240526212700.png" alt="微信截图_20240526212700"></p>
<h4><span id="笛卡尔积">笛卡尔积</span></h4><p>A与B是集合，那么A与B的笛卡尔积相当于A X B，表示&lt;a,b&gt;,其中：a∈A ,b∈B</p>
<p>笛卡尔积一般不满足交换律和结合律（并、交差运算除外）</p>
<p><img src="/2024/05/26/%E3%80%90%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E3%80%91%E9%9B%86%E5%90%88/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240526215607.png" alt="微信截图_20240526215607"></p>
<p><img src="/2024/05/26/%E3%80%90%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E3%80%91%E9%9B%86%E5%90%88/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240526215637.png" alt="微信截图_20240526215637"></p>
<h3><span id="2例题">2.例题</span></h3><p>笛卡尔积的计算</p>
<p><img src="/2024/05/26/%E3%80%90%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E3%80%91%E9%9B%86%E5%90%88/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240526215742.png" alt="微信截图_20240526215742"></p>
<h2><span id="五-关系及其表示">五、关系及其表示</span></h2><h3><span id="1名词解释和原理">1.名词解释和原理</span></h3><h4><span id="关系">关系</span></h4><p>对于一个二元关系R，R里面的任意一个序偶&lt;x,y&gt;可以记作**&lt;x,y&gt;∈R **或 <strong>xRy</strong></p>
<p>A X B的子集R称为一个从A到B的二元关系</p>
<h4><span id="前域-值域-域">前域、值域、域</span></h4><p><img src="/2024/05/26/%E3%80%90%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E3%80%91%E9%9B%86%E5%90%88/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240526220618.png" alt="微信截图_20240526220618"></p>
<h4><span id="空关系">空关系</span></h4><p>A X B的平凡子集∅，称为A到B的空关系。</p>
<h4><span id="全域关系">全域关系</span></h4><p>A X B的平凡子集A X B称为A到B的全域关系。</p>
<h4><span id="恒等关系">恒等关系</span></h4><p>设Iₓ是X上的二元关系，且满足Iₓ &#x3D; {&lt;x,x&gt;|x∈X}，则称Iₓ是X上的恒等关系。</p>
<h4><span id="关系矩阵"><strong>关系矩阵</strong></span></h4><p>我们有两个有限集合：X &#x3D; {x₁,x₂,x₃,……,xₘ}，Y&#x3D;{y₁,y₂,y₃,……,yₙ}，R是X到Y上的一个二元关系，那么就有相应的关系矩阵：M &#x3D; [rᵢ ⱼ]ₘₓₙ</p>
<p>rᵢ ⱼ&#x3D;1当且仅当&lt;aᵢ,bⱼ&gt;∈R</p>
<p>rᵢ ⱼ&#x3D;0当且仅当&lt;aᵢ,bⱼ&gt;!∈R</p>
<p><img src="/2024/05/26/%E3%80%90%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E3%80%91%E9%9B%86%E5%90%88/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240526221913.png" alt="微信截图_20240526221913"></p>
<h4><span id="关系图">关系图</span></h4><p><img src="/2024/05/26/%E3%80%90%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E3%80%91%E9%9B%86%E5%90%88/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240526222016.png" alt="微信截图_20240526222016"></p>
<h3><span id="2例题">2.例题</span></h3><h4><span id="关系矩阵的表示">关系矩阵的表示</span></h4><p><img src="/2024/05/26/%E3%80%90%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E3%80%91%E9%9B%86%E5%90%88/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240526221828.png" alt="微信截图_20240526221828"></p>
<h4><span id="笛卡尔积的幂集算法">笛卡尔积的幂集算法</span></h4><p><img src="/2024/05/26/%E3%80%90%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E3%80%91%E9%9B%86%E5%90%88/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240526221238.png" alt="微信图片_20240526221238"></p>
<h4><span id="关系图的表示">关系图的表示</span></h4><p><img src="/2024/05/26/%E3%80%90%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E3%80%91%E9%9B%86%E5%90%88/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240526222107.png" alt="微信截图_20240526222107"></p>
<h2><span id="六-关系的性质">六、关系的性质</span></h2><h3><span id="名词解释">名词解释</span></h3><h4><span id="自反的关系">自反的关系</span></h4><p>R是集合X上面的二元关系，如果对于每一个x ∈A,有xRx，即&lt;x,x&gt;∈R，就称R是自反的。</p>
<p>设集合S非空，S上的关系可以是自反的，是反自反的，也可以两者都不是。</p>
<p>Y是自反的，则：</p>
<ul>
<li>Iₓ ⊆ Y；（集合X上的恒等关系是自反关系，但自反关系却不一定是恒等关系）</li>
<li>Mᵧ主对角线上的元素都是1；</li>
<li>Gᵧ的每个结点均有环。</li>
</ul>
<h4><span id="反自反关系">反自反关系</span></h4><p>R是集合X上面的二元关系，如果对于每一个x ∈A,有xRx，即&lt;x,x&gt;!∈R，就称R是自反的。</p>
<p>Y是反自反的，则：</p>
<ul>
<li>Iₓ ∩ Y &#x3D;∅；</li>
<li>Mᵧ主对角线上的元素都是0；</li>
<li>Gᵧ的每个结点均无环。</li>
</ul>
<h4><span id="对称关系">对称关系</span></h4><p>对于关系里面x,y ∈ X，每当xRy，就有yRx，就X上面关系R是对称的。</p>
<p>Y是对称的，则：</p>
<ul>
<li>Mᵧ是对称的；</li>
<li>Gᵧ中任何两个结点之间若有有向边，必有两条方向相反的有向边。</li>
</ul>
<h4><span id="反对称关系">反对称关系</span></h4><p>对于关系里面x,y ∈ X，每当xRy和yRx，就有x&#x3D;y，就X上面关系R是反对称的。</p>
<ul>
<li>关系矩阵以对角线对称的元素不能同时为1，(但可为对称阵，同时为0)。</li>
<li>关系图中如果两个结点之间有有向弧，则不能成对出现。</li>
</ul>
<h4><span id="传递关系">传递关系</span></h4><p>对于x, y, z ∈ X，每当xRy, yRz时就有xRz,就称R在X上是传递的。</p>
<h4><span id="特殊关系的性质">特殊关系的性质</span></h4><p><strong>空关系</strong>： 反自反性，对称性，反对称性，传递性<br><strong>全域关系</strong>：自反性，对称性，传递性<br><strong>恒等关系</strong>：自反性，对称性，传递性</p>
<h4><span id="总结">总结</span></h4><ul>
<li>自反性：应该含有所有&lt;x, x&gt;<br>对称性：如果有&lt;x, y&gt;就应该有&lt;y, x&gt;<br>传递性：如果有&lt;x, y&gt;和&lt;y, z&gt;就应该有&lt;x, z&gt;</li>
<li>反自反性：不应该含有任何&lt;x, x&gt;<br>反对称性：如果有&lt;x, y&gt;就不应该有&lt;y, x&gt;</li>
</ul>
<h3><span id="例题">例题</span></h3><p><img src="/2024/05/26/%E3%80%90%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E3%80%91%E9%9B%86%E5%90%88/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240526231540.png" alt="微信截图_20240526231540"></p>
<p><img src="/2024/05/26/%E3%80%90%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E3%80%91%E9%9B%86%E5%90%88/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240526233116.png" alt="微信截图_20240526233116"></p>
<h2><span id="七-复合关系和逆关系">七、复合关系和逆关系</span></h2><h3><span id="1名词和定理">1.名词和定理</span></h3><h4><span id="复合关系">复合关系</span></h4><p>R是X到Y的关系，S是Y到Z的关系，则R和S的复合关系R°S称为R和S的复合关系，表示为: </p>
<p>RoS&#x3D;{&lt;x,z&gt;|x∈X且z∈Z(y∈Y ,&lt;x, y&gt;∈R且&lt;y,z&gt; ∈S)}</p>
<p>复合关系相当于一个个元素进行传递，看是否满足传递关系。</p>
<h4><span id="逆关系">逆关系</span></h4><p>R是X到Y的二元关系，把R中每一序偶的元素次序颠倒，得到的关系称为R的逆关系，记作Rᶜ</p>
<ul>
<li>xRy &#x3D;&#x3D; xRᶜy</li>
<li>互换R的关系矩阵的行和列，即得Rᶜ的关系矩阵（转置）</li>
<li>颠倒R的关系图中每条弧线的箭头方向，即得Rᶜ的关系图</li>
<li>空关系的逆是空关系</li>
<li>R&#x3D;Rᶜ，则说明R是对称的</li>
</ul>
<p><img src="/2024/05/26/%E3%80%90%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E3%80%91%E9%9B%86%E5%90%88/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240526235030.png" alt="微信截图_20240526235030"></p>
<p><img src="/2024/05/26/%E3%80%90%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E3%80%91%E9%9B%86%E5%90%88/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240526235224.png" alt="微信截图_20240526235224"></p>
<h4><span id="复合关系的结合律">复合关系的结合律</span></h4><p><img src="/2024/05/26/%E3%80%90%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E3%80%91%E9%9B%86%E5%90%88/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240526233655.png" alt="微信截图_20240526233655"></p>
<h4><span id="复合关系的幂集">复合关系的幂集</span></h4><p><img src="/2024/05/26/%E3%80%90%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E3%80%91%E9%9B%86%E5%90%88/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240526234315.png" alt="微信截图_20240526234315"></p>
<h4><span id="复合关系的矩阵表示">复合关系的矩阵表示</span></h4><p>（1）布尔加法 &#x3D;&#x3D; or</p>
<p>（2）布尔乘法 &#x3D;&#x3D; and</p>
<h3><span id="2例题">2.例题</span></h3><h4><span id="复合关系的矩阵表示">复合关系的矩阵表示</span></h4><p><img src="/2024/05/26/%E3%80%90%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E3%80%91%E9%9B%86%E5%90%88/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240526234530.png" alt="微信截图_20240526234530"></p>
<h2><span id="八-闭包运算">八、闭包运算</span></h2>]]></content>
      <tags>
        <tag>离散数学</tag>
      </tags>
  </entry>
  <entry>
    <title>urllib requests基础与实战</title>
    <url>/2024/06/30/urllib-requests%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#1urllib%E7%9A%84%E4%BD%BF%E7%94%A8">1.urllib的使用</a><ul>
<li><a href="#urlopen%E7%BD%91%E5%9D%80%E8%AF%B7%E6%B1%82">urlopen网址请求</a></li>
<li><a href="#%E7%BD%91%E9%A1%B5%E7%9A%84%E4%BF%9D%E5%AD%98%E5%92%8C%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">网页的保存和异常处理</a></li>
<li><a href="#%E6%9E%84%E9%80%A0%E8%AF%B7%E6%B1%82%E5%AF%B9%E8%B1%A1request">构造请求对象Request</a></li>
<li><a href="#%E6%B7%BB%E5%8A%A0%E8%AF%B7%E6%B1%82%E5%A4%B4">添加请求头</a></li>
<li><a href="#ssl%E8%AE%A4%E8%AF%81">SSL认证</a></li>
<li><a href="#%E5%BC%BA%E5%88%B6https%E8%AE%A4%E8%AF%81">强制https认证</a></li>
</ul>
</li>
<li><a href="#2requests%E4%B8%ADget%E7%9A%84%E7%94%A8%E6%B3%95">2.Requests中get的用法</a><ul>
<li><a href="#%E4%BB%A3%E7%A0%81%E8%8E%B7%E5%8F%96">代码获取</a></li>
<li><a href="#%E6%9E%84%E5%BB%BA%E8%AF%B7%E6%B1%82">构建请求</a></li>
<li><a href="#%E8%8E%B7%E5%8F%96cookie">获取cookie</a></li>
<li><a href="#%E6%B7%BB%E5%8A%A0%E8%AF%B7%E6%B1%82%E5%A4%B4-1">添加请求头</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<p>[TOC]</p>
<h2><span id="1urllib的使用">1.urllib的使用</span></h2><p>urllib.request ——打开和读取url</p>
<p>urllib.error ——包含urllib.request抛出的异常</p>
<p>urllib.parse ——用于解析url</p>
<p>urllib.robotparser ——用于解析robots.txt文件</p>
<h3><span id="urlopen网址请求">urlopen网址请求</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import urllib.request      </span><br><span class="line">#导入模块</span><br><span class="line">response = urllib.request.urlopen(&#x27;https://cn.bing.com/&#x27;)    </span><br><span class="line">#使用urlopen方法打开网页</span><br><span class="line">print(response.read().decode(&#x27;utf-8&#x27;))      </span><br><span class="line">#使用read方法读取网页，decode(&#x27;utf-8&#x27;)表示把utf-8设置为编码方式</span><br></pre></td></tr></table></figure>

<p>如果网速比较慢或者所请求的网站打开时比较缓慢，可以设置一个超时限制，这时需要加入timeout参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import urllib.request     </span><br><span class="line">response = urllib.request.urlopen(&#x27;https://cn.bing.com/&#x27;,timeout=10)    </span><br><span class="line">#设置超时时间为10s</span><br><span class="line">print(response.read().decode(&#x27;utf-8&#x27;))</span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/30/urllib-requests%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%AE%9E%E6%88%98/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240630230017.png" alt="微信截图_20240630230017"></p>
<h3><span id="网页的保存和异常处理">网页的保存和异常处理</span></h3><p>把代码保存到HTML，如网页打开时读取失败，则通过Exception捕获异常</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">    x=urllib.request.urlopen(&#x27;https://cn.bing.com/&#x27;)</span><br><span class="line">    #print(x.read())</span><br><span class="line">    save = open(&#x27;1.html&#x27;,&#x27;w&#x27;)</span><br><span class="line">    save.write(str(x.read()))</span><br><span class="line">    save.close()</span><br><span class="line">except Exception as e:</span><br><span class="line">    print(str(e))</span><br></pre></td></tr></table></figure>

<h3><span id="构造请求对象request">构造请求对象Request</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import urllib.request</span><br><span class="line">request = urllib.request.Request(&quot;https://cn.bing.com/&quot;)    </span><br><span class="line">#用Request构造Requests对象类</span><br><span class="line">response = urllib.request.urlopen(request)      </span><br><span class="line">#用urlopen打开网页</span><br><span class="line">print(response.read().decode(&#x27;utf-8&#x27;))     </span><br><span class="line">#用read打印内容</span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/30/urllib-requests%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%AE%9E%E6%88%98/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240630230017-1719760905458-2.png" alt="微信截图_20240630230017"></p>
<h3><span id="添加请求头">添加请求头</span></h3><p>构造的基本格式为：headers&#x3D;{‘User-Agent’:’请求头’}</p>
<p>找请求头：检查——网络——刷新——标头——User-Agent，将它复制出来</p>
<ul>
<li>请求网址url：当前打开的网页</li>
<li>代码方法：200 OK ，表示请求打开网址成功</li>
<li>cookie：用于识别用户身份</li>
<li>User-Agent：用户代理</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from urllib import request</span><br><span class="line">url=&#x27;https://sakitamarin.github.io/2024/06/29/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1-%E7%AC%94%E8%AE%B0/&#x27;</span><br><span class="line">headers=&#123;&#x27;User-Agent&#x27;:&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.0.0 Safari/537.36 Edg/126.0.0.0&#x27;&#125;</span><br><span class="line">req=request.Request(url=url,headers=headers)</span><br><span class="line">response=request.urlopen(req)</span><br><span class="line">print(response.read().decode(&#x27;utf-8&#x27;))</span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/30/urllib-requests%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%AE%9E%E6%88%98/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240630234746.png" alt="微信截图_20240630234746"></p>
<p>继续在请求头中添加cookie，这样便于身份识别。每一个用户登录一个网站都有对应的cookie。</p>
<h3><span id="ssl认证">SSL认证</span></h3><p>用于没有SSL证书的网站。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import urllib</span><br><span class="line">import urllib.request</span><br><span class="line"></span><br><span class="line">#对ssl进行设置，忽略警告，继续进行访问</span><br><span class="line">import ssl</span><br><span class="line">ssl._create_default_https_context = ssl._create_unverified_context</span><br><span class="line">#不带s不会进行认证的</span><br><span class="line">url = &#x27;http://agedmw2.com/acg/71844/4.html&#x27;</span><br><span class="line">response = urllib.request.urlopen(url=url)</span><br><span class="line">print(response.read().decode(&#x27;utf-8&#x27;))</span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/30/urllib-requests%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%AE%9E%E6%88%98/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240701004648.png" alt="微信截图_20240701004648"></p>
<h3><span id="强制https认证">强制https认证</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">#urllib3 官方强制验证https安全证书,解决警告</span><br><span class="line">import urllib3</span><br><span class="line">urllib3.disable_warnings()</span><br><span class="line"></span><br><span class="line">url = &#x27;https://www.12306.cn/mormhweb/&#x27;</span><br><span class="line">#requests操作起来简单   False不要进行认证</span><br><span class="line">response = requests.get(url=url,verify = False)</span><br><span class="line">#设置返回编码</span><br><span class="line">response.encoding = &#x27;utf-8&#x27;</span><br><span class="line">print(response.text)</span><br></pre></td></tr></table></figure>



<h2><span id="2requests中get的用法">2.Requests中get的用法</span></h2><p>模块安装命令：pip install request</p>
<h3><span id="代码获取">代码获取</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests </span><br><span class="line">r = requests.get(&#x27;https://cn.bing.com/?mkt=zh-CN&#x27;) </span><br><span class="line">print(r.text)</span><br></pre></td></tr></table></figure>

<p>status_code可以获取请求结果的状态，text方法以文本形式获取代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">u=requests.get(&#x27;https://www.weibo.com/&#x27;)</span><br><span class="line">print(u.status_code)#打印状态码</span><br><span class="line">print(u.text)#打印文本</span><br></pre></td></tr></table></figure>

<h3><span id="构建请求">构建请求</span></h3><p>origin：个人ip</p>
<p>url：读者请求的网址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests  </span><br><span class="line">r = requests.get(&#x27;http://httpbin.org/get&#x27;)</span><br><span class="line">print(r.text)</span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/30/urllib-requests%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%AE%9E%E6%88%98/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240701005748.png" alt="微信截图_20240701005748"></p>
<h3><span id="获取cookie">获取cookie</span></h3><ul>
<li>名字——name</li>
<li>值——value</li>
<li>过期时间——Expries&#x2F;Max-Age</li>
<li>作用路径——path</li>
<li>所在域名——domain</li>
<li>使用cookie进行安全连接——secure</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">headers=&#123;</span><br><span class="line">    &#x27;User-Agent&#x27;:&#x27;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.71 Safari/537.36&#x27;</span><br><span class="line">&#125;#请求头</span><br><span class="line">url=&#x27;https://www.csdn.net/?spm=1011.2124.3001.5359&#x27;</span><br><span class="line">r=requests.get(url=url,headers=headers)</span><br><span class="line">cookiejar = r.cookies</span><br><span class="line">cookiedict = requests.utils.dict_from_cookiejar(cookiejar)</span><br><span class="line">print (cookiejar)</span><br><span class="line">print(cookiedict)</span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/30/urllib-requests%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%AE%9E%E6%88%98/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240701010256.png" alt="微信截图_20240701010256"></p>
<h3><span id="添加请求头">添加请求头</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">headers = &#123;&#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36&#x27;</span><br><span class="line">&#125;</span><br><span class="line">r = requests.get(&quot;https://www.zhihu.com/explore&quot;, headers=headers)</span><br><span class="line">print(r.text)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>【动态规划-1】矩阵连乘问题</title>
    <url>/2024/10/16/%E3%80%90%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-1%E3%80%91%E7%9F%A9%E9%98%B5%E8%BF%9E%E4%B9%98%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#7-1-%E7%9F%A9%E9%98%B5%E9%93%BE%E7%9B%B8%E4%B9%98%E9%97%AE%E9%A2%98"><strong>7-1 矩阵链相乘问题</strong></a></li>
<li><a href="#7-2-%E6%9C%80%E5%A4%A7k%E4%B9%98%E7%A7%AF"><strong>7-2 最大k乘积</strong></a></li>
</ul>
<!-- tocstop -->

<p>[TOC]</p>
<h3><span id="7-1-矩阵链相乘问题"><strong>7-1 矩阵链相乘问题</strong></span></h3><p>矩阵的乘法定义如下：设<em>A</em>是<em>m</em>×<em>p</em>的矩阵，<em>B</em>是<em>p</em>×<em>n</em>的矩阵，则<em>A</em>与<em>B</em>的乘积为<em>m</em>×<em>n</em>的矩阵，记作<em>C</em>&#x3D;<em>AB</em>，其中，矩阵<em>C</em>中的第<em>i</em>行第<em>j</em>列元素<em>cij</em>可以表示为：<em>cij</em>&#x3D;Σ<em>k</em>&#x3D;1<em>p<strong>a</strong>ik</em>×<em>bkj</em>&#x3D;<em>ai</em>1<em>b</em>1<em>j</em>+<em>ai</em>2<em>b</em>2<em>j</em>+⋯+<em>a<strong>i</strong>p<strong>b</strong>pj</em>.</p>
<p>当多个矩阵相乘时，采用不同的计算顺序所需的乘法次数不相同。例如，<em>A</em>是50×10的矩阵，<em>B</em>是10×20的矩阵，<em>C</em>是20×5的矩阵，<br>计算<em>ABC</em>有两种方式：(<em>AB</em>)<em>C</em>和<em>A</em>(<em>BC</em>)，前一种需要15000次乘法计算，后一种则只需3500次。</p>
<p>设<em>A</em>1,<em>A</em>2,…,<em>An</em>为矩阵序列，<em>Ai</em>是阶为<em>Pi</em>−1∗<em>Pi</em>的矩阵(1≤<em>i</em>≤<em>n</em>)。试确定矩阵的乘法顺序，使得计算<em>A</em>1<em>A</em>2…<em>An</em>过程中元素相乘的总次数最少。</p>
<h4><span id="输入格式">输入格式:</span></h4><p>每个输入文件为一个测试用例，每个测试用例的第一行给出一个正整数<em>n</em>(1≤<em>n</em>≤500)，表示一共有<em>n</em>个矩阵<em>A</em>1,<em>A</em>2,…,<em>An</em>，第二行给出<em>n</em>+1个整数<em>P</em>0,<em>P</em>1…<em>Pn</em>，以空格分隔，其中1≤<em>Pi</em>≤100(0≤<em>i</em>≤<em>n</em>)，第<em>i</em>个矩阵<em>Ai</em>是阶为<em>Pi</em>−1∗<em>Pi</em>的矩阵。</p>
<h4><span id="输出格式">输出格式:</span></h4><p>获得上述矩阵的乘积，所需的最少乘法次数。</p>
<h4><span id="输入样例">输入样例:</span></h4><p>在这里给出一组输入。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">30 35 15 5 10 20</span><br></pre></td></tr></table></figure>

<h4><span id="输出样例">输出样例:</span></h4><p>在这里给出相应的输出。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11875</span><br></pre></td></tr></table></figure>

<h4><span id="算法步骤">算法步骤：</span></h4><p>1.初始化一个二维数组m，大小为n*n；</p>
<p>2.对于i&#x3D;1到n，设置m[i]_[i]&#x3D;0，即对角线上的元素置零;</p>
<p>3.自底到上、自左到右对对角线右边的空位进行填表，计算m[i]_[j]；</p>
<p>4.根据状态转移方程更新数组m；</p>
<p>5.最终m[1]_[n]即为最少数乘次数。</p>
<h4><span id="代码">代码：</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n;</span><br><span class="line">int p[10000];</span><br><span class="line">//因为可相乘矩阵要求RA=CB，所以p[i-1]代表矩阵行数，p[i]代表矩阵列数</span><br><span class="line">int m[10000][10000];//数组m记录Ai···Aj所需的最少数乘次数</span><br><span class="line">//int s[10000][10000];数组s用于记录最优断开位置</span><br><span class="line"></span><br><span class="line">int MatrixChain()&#123;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">        m[i][i]=0;//对角线元素计为0，因为i=j时只有一个矩阵，无需乘法</span><br><span class="line">    for(int i=n;i&gt;=1;i--)&#123;//自底而上填表</span><br><span class="line">        for(int j=i+1;j&lt;=n;j++)&#123;</span><br><span class="line">            m[i][j]=m[i+1][j]+p[i-1]*p[i]*p[j];//更新最小数乘次数</span><br><span class="line">            //s[i][j]=i;当前最优断点为i</span><br><span class="line">            for(int k=i+1;k&lt;j;k++)&#123;</span><br><span class="line">            //寻找最优次序中的断开位置，范围是i+1到j-1，因为这个断开位置既不会</span><br><span class="line">            是第一个矩阵也不会是最后一个矩阵</span><br><span class="line">                int t=m[i][k]+m[k+1][j]+p[i-1]*p[k]*p[j];</span><br><span class="line">                //p[i-1]*p[k]*p[j]是Ai···Ak与Ak+1···Aj的数乘次数</span><br><span class="line">                if(t&lt;m[i][j])&#123;</span><br><span class="line">                    m[i][j]=t;//如果当前值更优，更换m[i][j]</span><br><span class="line">                    //s[i][j]=k;更换最优断点</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return m[1][n];</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i=0;i&lt;n+1;i++)&#123;</span><br><span class="line">        cin&gt;&gt;p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    int result=MatrixChain();</span><br><span class="line">    cout&lt;&lt;result;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="7-2-最大k乘积"><strong>7-2 最大k乘积</strong></span></h3><p>设I是一个n位十进制整数。如果将I划分为k段，则可得到k个整数。这k个整数的乘积称为I的一个k乘积。试设计一个算法，对于给定的I和k，求出I的最大k乘积。</p>
<p>如3*12&#x3D;26</p>
<p>31*2&#x3D;62</p>
<p>此时最优解为62</p>
<h4><span id="输入格式">输入格式:</span></h4><p>第1 行中有2个正整数n和k。正整数n是序列的长度；正整数k是分割的段数。<br>接下来的一行中是一个n位十进制整数。（n&lt;&#x3D;10）</p>
<h4><span id="输出格式">输出格式:</span></h4><p>计算出的最大k乘积</p>
<h4><span id="输入样例1">输入样例1:</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 3</span><br><span class="line">3456</span><br></pre></td></tr></table></figure>

<h4><span id="输出样例1">输出样例1:</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1020</span><br></pre></td></tr></table></figure>

<h4><span id="输入样例2">输入样例2:</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 1</span><br><span class="line">15</span><br></pre></td></tr></table></figure>

<h4><span id="输出样例2">输出样例2:</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">15</span><br></pre></td></tr></table></figure>

<h4><span id="代码">代码：</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int dp[15][15];</span><br><span class="line"></span><br><span class="line">char numstr[15];</span><br><span class="line">int num[15];</span><br><span class="line"></span><br><span class="line">int getValue(int i,int j)&#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    for(int k = i;k &lt; j;k++)&#123;</span><br><span class="line">        sum += num[k];</span><br><span class="line">        sum *= 10;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum + num[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dpAlgo(int l,int k)&#123;</span><br><span class="line">    for(int i = 1;i &lt;= l;i++)</span><br><span class="line">        dp[i][1] = getValue(1,i);</span><br><span class="line">    for(int i = 0;i &lt;= l;i++)&#123;</span><br><span class="line">        for(int j = 2;j &lt;= k;j++)&#123;</span><br><span class="line">            int temp = 0;</span><br><span class="line">            for(int d = 1;d &lt; i;d++)</span><br><span class="line">                temp = max(temp,dp[d][j - 1] * getValue(d + 1,i));</span><br><span class="line">            dp[i][j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int l,k;</span><br><span class="line">    cin &gt;&gt; l &gt;&gt; k &gt;&gt; numstr;//输入长度l、分割段数k、字符串序列</span><br><span class="line">    for(int i = 0;i &lt; l;i++)</span><br><span class="line">        num[i + 1] = numstr[i] - &#x27;0&#x27;;//去掉空字符，将字符串转化成整数数组</span><br><span class="line">    dpAlgo(l,k);</span><br><span class="line">    cout &lt;&lt; dp[l][k];</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法分析与设计</tag>
      </tags>
  </entry>
  <entry>
    <title>图的表示和操作</title>
    <url>/2024/06/01/%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#%E4%B8%80-%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C">一、图的基本操作</a><ul>
<li><a href="#int-locatevex">int LocateVex();</a></li>
<li><a href="#int-firstadjvex">int FirstAdjVex();</a></li>
<li><a href="#int-nextadjvex">int NextAdjVex();</a></li>
<li><a href="#void-showmatrix">void showMatrix();</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C-%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84">二、图的存储结构</a></li>
<li><a href="#1%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5">1.邻接矩阵</a><ul>
<li><a href="#1%E6%97%A0%E5%90%91%E7%BD%91%E7%9A%84%E5%AE%9A%E4%B9%89">（1）无向网的定义</a></li>
<li><a href="#2%E6%97%A0%E5%90%91%E7%BD%91%E7%9A%84%E5%88%9B%E5%BB%BA">（2）无向网的创建</a></li>
</ul>
</li>
<li><a href="#2%E9%82%BB%E6%8E%A5%E8%A1%A8%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8">2.邻接表（链式存储）</a><ul>
<li><a href="#1%E5%AE%9A%E4%B9%89">（1）定义</a></li>
<li><a href="#2%E5%88%9B%E5%BB%BA">（2）创建</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89-%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86">三、图的遍历</a><ul>
<li><a href="#1%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86">1.深度优先遍历</a></li>
<li><a href="#2%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86">2.广度优先遍历</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<p>[TOC]</p>
<h2><span id="一-图的基本操作">一、图的基本操作</span></h2><h3><span id="int-locatevex">int LocateVex();</span></h3><p>&#x2F;&#x2F; 返回顶点u在图中的位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int LocateVex(MGraph G, VertexType u) &#123;</span><br><span class="line">	int i;</span><br><span class="line">	for (i = 0; i &lt; G.vexnum &amp;&amp; G.vexs[i] != u; i++);</span><br><span class="line">	return i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="int-firstadjvex">int FirstAdjVex();</span></h3><p>&#x2F;&#x2F; 返回图G中u的第一个邻接节点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int FirstAdjVex(MGraph G, VertexType u) &#123;</span><br><span class="line">	int index = LocateVex(G, u);</span><br><span class="line">	int i;</span><br><span class="line">	for (i = 0; i &lt; G.vexnum; i++) &#123;</span><br><span class="line">		if (G.arcs[index][i].adj != -1) break;</span><br><span class="line">	&#125;</span><br><span class="line">	if (i == G.vexnum) return -1;  // 没有临界点</span><br><span class="line">	else return i;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3><span id="int-nextadjvex">int NextAdjVex();</span></h3><p>&#x2F;&#x2F; 返回G中顶点v相对于u的下一邻接点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int NextAdjVex(MGraph G, VertexType v, VertexType u) &#123;</span><br><span class="line">	int indexV = LocateVex(G, v);</span><br><span class="line">	int indexU = LocateVex(G, u);</span><br><span class="line">	int index;</span><br><span class="line">	for (index = indexU + 1; index &lt; G.vexnum &amp;&amp; G.arcs[indexV][index].adj == -1; index++);</span><br><span class="line">	if (index == G.vexnum) return -1;</span><br><span class="line">	else return index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="void-showmatrix">void showMatrix();</span></h3><p>&#x2F;&#x2F; 打印图的邻接矩阵</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void showMatrix(MGraph G) &#123;</span><br><span class="line">	for (int i = 0; i &lt; G.vexnum; i++) &#123;</span><br><span class="line">		for (int j = 0; j &lt; G.vexnum; j++) cout &lt;&lt; G.arcs[i][j].adj &lt;&lt; &quot; &quot;;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="二-图的存储结构">二、图的存储结构</span></h2><h2><span id="1邻接矩阵">1.邻接矩阵</span></h2><p>图没有顺序存储结构，但可以利用二维数组来表示元素之间的关系，即邻接矩阵表示法。</p>
<p>邻接矩阵是表示顶点之间相邻关系的矩阵。</p>
<p><strong>无向图</strong></p>
<p><img src="/2024/06/01/%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E6%93%8D%E4%BD%9C/fd2a45a63a414cfdb6800122ecd6bb82.jpg" alt="fd2a45a63a414cfdb6800122ecd6bb82"></p>
<p><strong>有向网</strong></p>
<p><img src="/2024/06/01/%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E6%93%8D%E4%BD%9C/af06656474c14cfb839a5cb7e8cae998.jpg" alt="af06656474c14cfb839a5cb7e8cae998"></p>
<h3><span id="1无向网的定义">（1）无向网的定义</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define MAXINT 32767 //表示极大值，即∞</span><br><span class="line">#define MVnum 100 //最大顶点数</span><br><span class="line"></span><br><span class="line">typedef char VerTexType;//假设顶点为字符型</span><br><span class="line">typedef int ArcType; //假设边的权值为整型</span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line">	VerTexType vexs[MVnum]; //顶点表</span><br><span class="line">	ArcType arcs[MVnum][MVnum]; //邻接矩阵</span><br><span class="line">	int vexnum,arcnum; //图的当前点数和边数 </span><br><span class="line">&#125;AMGraph;</span><br></pre></td></tr></table></figure>

<h3><span id="2无向网的创建">（2）无向网的创建</span></h3><ul>
<li>输入总顶点数和总边数；</li>
<li>依次输入点的信息；</li>
<li>初始化邻接矩阵；</li>
<li>依次输入每条边（及其权值），<u>确定两个顶点在图中的位置之后</u>，使相应边赋予相应的权值，<u>同时使其对称边赋予相同的权值</u>。</li>
</ul>
<p><strong>创建。</strong></p>
<p>无向图的创建只需要删除w变量的部分，并把无穷改成1就好。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int CreateUDN(AMGraph &amp;G)&#123; </span><br><span class="line">	cin&gt;&gt;G.vexnum&gt;&gt;G.arcnum; //输入总点数和总边数</span><br><span class="line">	for(int i=0;i&lt;G.vexnum;i++)&#123;</span><br><span class="line"> 		cin&gt;&gt;G.vexs[i]; //输入点的信息</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=0;i&lt;G.arcnum;i++)</span><br><span class="line">	  for(int j=0;i&lt;G.arcnum;j++)</span><br><span class="line">	    G.arcs[i][j]=MAXINT; //初始化邻接矩阵，边的权值均置为∞ </span><br><span class="line">	for(int k=0;k&lt;G.arcnum;k++) &#123;  // 输入弧v1-v2的信息</span><br><span class="line">		VerTexType v1,v2;int w;</span><br><span class="line">		cin&gt;&gt;v1&gt;&gt;v2&gt;&gt;w; </span><br><span class="line">		int index1 = LocateVex(G, v1);</span><br><span class="line">		int index2 = LocateVex(G, v2);</span><br><span class="line">		G.arcs[index1][index2]= w; // w表示邻接的权值 </span><br><span class="line">		G.arcs[index2][index1] = G.arcs[index1][index2];  // 无向图对称构造</span><br><span class="line">	&#125;</span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>打印。</strong></p>
<pre><code>for(i = 0 ; i &lt; G.vexnum ; ++i)&#123;
    for(j = 0; j &lt; G.vexnum; ++j)&#123;
        if(j != G.vexnum - 1)&#123;
            if(G.arcs[i][j] != MaxInt)
                cout &lt;&lt; G.arcs[i][j] &lt;&lt; &quot;\t&quot;;
            else
                cout &lt;&lt; &quot;∞&quot; &lt;&lt; &quot;\t&quot;;
        &#125;
        else&#123;
            if(G.arcs[i][j] != MaxInt)
                cout &lt;&lt; G.arcs[i][j] &lt;&lt;endl;
            else
                cout &lt;&lt; &quot;∞&quot; &lt;&lt;endl;
        &#125;
    &#125;
&#125;//for
</code></pre>
<h2><span id="2邻接表链式存储">2.邻接表（链式存储）</span></h2><p><img src="/2024/06/01/%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E6%93%8D%E4%BD%9C/v2-917733c568ffe18d48b5493b1b327f05_r.jpg" alt="v2-917733c568ffe18d48b5493b1b327f05_r"></p>
<h3><span id="1定义">（1）定义</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#typedef MVNum 100 //最大顶点数 </span><br><span class="line">typedef struct ArcNode&#123; //边结点 </span><br><span class="line">	int adjvex; //该边所指向的顶点的位置</span><br><span class="line">	struct ArcNode *nextarc; //指向下一条边的指针</span><br><span class="line">	//InfoType info         //网的边权值 </span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line">typedef struct VNode&#123; //顶点表 </span><br><span class="line">	VertexType data; //顶点信息</span><br><span class="line">	ArcNode *firstarc; //指向第一天依附该结点的弧的指针 </span><br><span class="line">&#125;VNode,AdjList[MVNum];</span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line">	AdjList vertices;</span><br><span class="line">	int vexnum,arcnum; //图的当前顶点数和边数 </span><br><span class="line">&#125;ALGraph; </span><br></pre></td></tr></table></figure>

<h3><span id="2创建">（2）创建</span></h3><ul>
<li><p>输入总顶点数和总边数；</p>
</li>
<li><p>依次输入点的信息存在顶点表中，每个表头结点的指针域初始化为NULL；</p>
</li>
<li><p>创建邻接表，依次输入每条边依附的两个顶点，确定这两个顶点的序号i和j之后，将此边结点分别插入vi和vj</p>
</li>
<li><p>对应的两个边链表的头部。如果是有向图，只需生成一个序号为j的边结点，插入到vj的边链表头。</p>
<p>  int CreateUDG(ALGraph &amp;G){<br>  &#x2F;&#x2F;采用邻接表表示法，创建无向图G<br>  cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum;				&#x2F;&#x2F;输入总顶点数，总边数<br>  for(int i &#x3D; 0; i &lt; G.vexnum; ++i){          	&#x2F;&#x2F;输入各点，构造表头结点表<br>  cin &gt;&gt; G.vertices[i].data;           	&#x2F;&#x2F;输入顶点值<br>  G.vertices[i].firstarc&#x3D;NULL;			&#x2F;&#x2F;初始化表头结点的指针域为NULL<br>  }&#x2F;&#x2F;for<br>  for(int k &#x3D; 0; k &lt; G.arcnum;++k){        		&#x2F;&#x2F;输入各边，构造邻接表<br>  VerTexType v1 , v2;<br>  int i , j;<br>  cin &gt;&gt; v1 &gt;&gt; v2;                 		&#x2F;&#x2F;输入一条边依附的两个顶点<br>  i &#x3D; LocateVex(G, v1);  j &#x3D; LocateVex(G, v2);<br>  &#x2F;&#x2F;确定v1和v2在G中位置，即顶点在G.vertices中的序号<br><br>  ArcNode <em>p1&#x3D;new ArcNode;               	&#x2F;&#x2F;生成一个新的边结点</em>p1<br>  p1-&gt;adjvex&#x3D;j;                   		&#x2F;&#x2F;邻接点序号为j<br>  p1-&gt;nextarc&#x3D; G.vertices[i].firstarc;  G.vertices[i].firstarc&#x3D;p1;<br>  &#x2F;&#x2F;将新结点<em>p1插入顶点vi的边表头部<br><br>  ArcNode <em>p2&#x3D;new ArcNode;                &#x2F;&#x2F;生成另一个对称的新的边结点</em>p2<br>  p2-&gt;adjvex&#x3D;i;                   		&#x2F;&#x2F;邻接点序号为i<br>  p2-&gt;nextarc&#x3D; G.vertices[j].firstarc;  G.vertices[j].firstarc&#x3D;p2;<br>  &#x2F;&#x2F;将新结点</em>p2插入顶点vj的边表头部<br>  }&#x2F;&#x2F;for<br>  return 1;<br>  }</p>
</li>
</ul>
<h2><span id="三-图的遍历">三、图的遍历</span></h2><h3><span id="1深度优先遍历">1.深度优先遍历</span></h3><p>设置变量。</p>
<p>图的遍历和树的遍历类似，即从图中某一顶点出发遍历图中其余顶点，且使每一个顶点仅被访问一次。<br>为了避免同一顶点被访问多次，在遍历图的过程中，必须记下每个已被访问过的顶点。为此，我们可以设一个辅助数组Visited[N]来标记某一顶点是否被访问过了，初始化为False。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool visited[MVNum];           					//访问标志数组，其初值为&quot;false&quot; </span><br><span class="line">int FirstAdjVex(Graph G , int v);				//返回v的第一个邻接点</span><br><span class="line">int NextAdjVex(Graph G , int v , int w);		//返回v相对于w的下一个邻接点</span><br></pre></td></tr></table></figure>

<p>类似于树的先序遍历。</p>
<ul>
<li>从图中某个顶点v出发，访问v，并置visited[v]的值为1；</li>
<li>依次检查v的所有邻接点w，如果visited[w]的值为0，再从w出发进行遍历，直到图中所有顶点都被遍历过。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 图的深度优先遍历</span><br><span class="line">void DFSTraverse(MGraph G) &#123;</span><br><span class="line">	int* visited = new int[G.vexnum]; // 访问标志数组</span><br><span class="line">	for (int i = 0; i &lt; G.vexnum; i++) visited[i] = 0; // 初始化未被访问</span><br><span class="line">	for (int i = 0; i &lt; G.vexnum; i++) &#123;</span><br><span class="line">		if (!visited[i]) DFS(G, i, visited); // 对尚未访问的顶点i调用DFS，</span><br><span class="line">											 // 因为图G可能不是连通图</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 从图中第v个顶点开始进行深度优先遍历</span><br><span class="line">void DFS(MGraph G, int v, int* visited) &#123;</span><br><span class="line">	visited[v] = 1; //先访问顶点v</span><br><span class="line">	cout &lt;&lt; G.vexs[v] &lt;&lt; &quot; &quot;;</span><br><span class="line">	for (int w = FirstAdjVex(G, G.vexs[v]); w &gt;= 0; w = NextAdjVex(G, G.vexs[v], G.vexs[w])) &#123;</span><br><span class="line">		if (!visited[w]) DFS(G, w, visited); // 对v的尚未访问的邻接顶点w递归调用DFS</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="2广度优先遍历">2.广度优先遍历</span></h3><p><strong>广度优先搜索（Broadth First Search）</strong> 类似于树层次遍历的过程，即以v为初始点，由近即远，一次访问和v有路径相通且路径长度为1，2，…的顶点。此过程可借助于<code>队列</code>实现。</p>
<ul>
<li>从图中某个顶点出发，访问v，并置visited[v]的值为1，然后v进队；</li>
<li>只要队列不空，则：</li>
<li>队头顶点u出队；</li>
<li>依次检查u的所有邻接点w，如果visited[w]为0，访问w，并置其值为1，w进队。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void BFSTraverse(MGraph G) &#123;</span><br><span class="line">// 按照广度优先非递归遍历图G，使用辅助队列Q和访问标志数组visited。</span><br><span class="line">	int* visited = new int[G.vexnum];</span><br><span class="line">	queue&lt;int&gt; Q;</span><br><span class="line">	int i;</span><br><span class="line">	for (i = 0; i &lt; G.vexnum; i++) visited[i] = 0;</span><br><span class="line">	for (i = 0; i &lt; G.vexnum; i++) &#123;</span><br><span class="line">		if (!visited[i]) &#123; //访问顶点i</span><br><span class="line">			visited[i] = 1;</span><br><span class="line">			cout &lt;&lt; G.vexs[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">			Q.push(i);</span><br><span class="line">			while (!Q.empty()) &#123;</span><br><span class="line">				int u = Q.front();</span><br><span class="line">				Q.pop(); //取出对头顶点</span><br><span class="line">				for (int w = FirstAdjVex(G, G.vexs[u]); w &gt;= 0; w = NextAdjVex(G, G.vexs[u], G.vexs[w])) &#123;</span><br><span class="line">					if (!visited[w]) &#123;  // w为u的尚未访问的邻接顶点</span><br><span class="line">						visited[w] = 1;</span><br><span class="line">						cout &lt;&lt; G.vexs[w] &lt;&lt; &quot; &quot;;</span><br><span class="line">						Q.push(w);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>数据结构笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的表现</title>
    <url>/2024/05/28/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#%E4%B8%80-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E5%92%8C%E5%BB%BA%E7%AB%8B">一、二叉树的遍历和建立</a><ul>
<li><a href="#1%E5%AE%9A%E4%B9%89">1.定义</a></li>
<li><a href="#2%E5%BB%BA%E7%AB%8B%E6%8C%89%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E9%A1%BA%E5%BA%8F">2.建立（按先序遍历的顺序）</a></li>
<li><a href="#3%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86">3.中序遍历</a></li>
<li><a href="#4%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86">4.先序遍历</a></li>
<li><a href="#5%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86">5.后序遍历</a></li>
<li><a href="#6%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86">6.层序遍历</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C-%E5%A4%8D%E5%88%B6%E4%BA%8C%E5%8F%89%E6%A0%91">二、复制二叉树</a></li>
<li><a href="#%E4%B8%89-%E8%AE%A1%E7%AE%97%E4%BA%8C%E5%8F%89%E6%A0%91">三、计算二叉树</a><ul>
<li><a href="#1%E8%AE%A1%E7%AE%97%E6%B7%B1%E5%BA%A6">1.计算深度</a></li>
<li><a href="#2%E8%AE%A1%E7%AE%97%E9%AB%98%E5%BA%A6">2.计算高度</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9B-%E8%AE%A1%E7%AE%97%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%93%E7%82%B9%E6%95%B0">四、计算二叉树的结点数</a><ul>
<li><a href="#1%E8%AE%A1%E7%AE%97%E7%BB%93%E7%82%B9%E6%95%B0">1.计算结点数</a></li>
<li><a href="#2%E8%AE%A1%E7%AE%97%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9%E6%95%B0">2.计算叶子结点数</a></li>
</ul>
</li>
<li><a href="#%E4%BA%94-%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91">五、线索二叉树</a><ul>
<li><a href="#1%E5%AE%9A%E4%B9%89-1">1.定义</a></li>
<li><a href="#2%E5%88%9B%E5%BB%BA">2.创建</a></li>
<li><a href="#3%E7%BA%BF%E7%B4%A2%E5%8C%96">3.线索化</a></li>
<li><a href="#4%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86">4.中序遍历</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<p>[TOC]</p>
<h2><span id="一-二叉树的遍历和建立">一、二叉树的遍历和建立</span></h2><h3><span id="1定义">1.定义</span></h3><h4><span id="1顺序存储表示">（1）顺序存储表示</span></h4><p>仅适用于完全二叉树，层序存储</p>
<p>深度k个结点的二叉树（无论完全与否）都需要长度2^k-1的一维数组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define MAXTSIZE 100</span><br><span class="line">typedef TElemType SqBiTree[MAXTSIZE]; //0号单元存储根结点</span><br><span class="line">SqBiTree bt;</span><br></pre></td></tr></table></figure>

<h4><span id="2链式存储表示">（2）链式存储表示</span></h4><p>这里注意data的数据类型是char！不然是返回不了结点的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct BiTNode&#123;</span><br><span class="line">	char data;</span><br><span class="line">	struct BiTNode *lchild,*rchild; //左右孩子指针 </span><br><span class="line">&#125;BiTNode,*BiTree;</span><br></pre></td></tr></table></figure>

<h3><span id="2建立按先序遍历的顺序">2.建立（按先序遍历的顺序）</span></h3><ul>
<li>读入单个字符ch；</li>
<li>如果ch是#，看作空树，否则：</li>
<li>申请新的结点空间T；</li>
<li>把ch赋给T-&gt;data；</li>
<li>递归创建左、右子树。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void CreateBiTree(BiTree &amp;T)&#123;</span><br><span class="line">//按先序遍历的顺序建立二叉链表 </span><br><span class="line">	char ch;</span><br><span class="line">	cin&gt;&gt;ch;</span><br><span class="line">	if(ch == &#x27;#&#x27;) T=NULL; //递归结束</span><br><span class="line">	else&#123;</span><br><span class="line">		T = new BiTNode; //根结点 </span><br><span class="line">		T-&gt;data =ch;</span><br><span class="line">		CreateBiTree(T-&gt;lchild);//递归创建左子树 </span><br><span class="line">		CreateBiTree(T-&gt;rchild);//递归创建右子树 </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="3中序遍历">3.中序遍历</span></h3><p>若二叉树为空，则空操作，否则：</p>
<ul>
<li>中序遍历左子树；</li>
<li>访问根结点；</li>
<li>中序遍历右子树。</li>
</ul>
<h4><span id="1递归遍历">（1）递归遍历</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void InOrderTraverse(BiTree T)&#123;</span><br><span class="line">//中序遍历的递归算法</span><br><span class="line">if(T)&#123;</span><br><span class="line">	InOrderTraverse(T-&gt;lchild);//中序遍历左子树</span><br><span class="line">	cout&lt;&lt;T-&gt;data;</span><br><span class="line">	InOrderTraverse(T-&gt;rchild);//中序遍历右子树</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="2非递归遍历">（2）非递归遍历</span></h4><p>①对于STL下的stack容器，如果要使链表结点进出栈，就定义类似于</p>
<p>stack&lt;BiTNode*&gt;stk; </p>
<p>然后就可以照常使用了。</p>
<p>②这一段的工作机制是：</p>
<ul>
<li>从根结点开始，遇到结点则将结点压栈；</li>
<li>当遇到无左子树的结点时，将此结点弹栈且访问它并遍历它的右子树；</li>
<li>若该结点为叶子结点，则继续弹栈，开始遍历它的父节点的右子树。</li>
</ul>
<p>③用了一个临时变量BiTNode* top来储存栈顶结点，存完以后stack出栈，top被访问，之后继续遍历</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void InOrderTraverse1(BiTree T)&#123;</span><br><span class="line">//中序遍历的非递归算法（栈）</span><br><span class="line">stack&lt;BiTNode*&gt;stk; </span><br><span class="line">BiTNode *p;</span><br><span class="line">p = T;</span><br><span class="line">while (p || !stk.empty()) &#123;    </span><br><span class="line">// 遍历左子树    </span><br><span class="line">if(p) &#123;    </span><br><span class="line">  stk.push(p);    </span><br><span class="line">  p = p-&gt;lchild;    </span><br><span class="line">&#125;else&#123;    </span><br><span class="line">  BiTNode* top = stk.top();  // 临时变量存储栈顶元素  </span><br><span class="line">  stk.pop();    </span><br><span class="line">  cout &lt;&lt; top-&gt;data; // 访问根结点    </span><br><span class="line">  p = top-&gt;rchild; // 遍历右子树    </span><br><span class="line">&#125;    </span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h3><span id="4先序遍历">4.先序遍历</span></h3><h4><span id="1递归">（1）递归</span></h4><p>若二叉树为空，则空操作，否则：</p>
<ul>
<li>访问根结点；</li>
<li>先序遍历左子树；</li>
<li>先序遍历右子树。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void PreOrderTraverse(BiTree T)&#123;</span><br><span class="line">//先序遍历的递归算法</span><br><span class="line">if(T)&#123;</span><br><span class="line">	cout&lt;&lt;T-&gt;data;</span><br><span class="line">	PreOrderTraverse(T-&gt;lchild);//先序遍历左子树</span><br><span class="line">	PreOrderTraverse(T-&gt;rchild);//先序遍历右子树</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="2非递归">（2）非递归</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void PreOrderTraverse1(BiTree T)&#123;</span><br><span class="line">//先序遍历的非递归算法（栈）</span><br><span class="line">stack&lt;BiTNode*&gt;stk; </span><br><span class="line">BiTNode *p;</span><br><span class="line">p = T;</span><br><span class="line">while (p || !stk.empty()) &#123;    </span><br><span class="line">// 遍历左子树    </span><br><span class="line">    if(p) &#123;</span><br><span class="line">	cout&lt;&lt;p-&gt;data;   //访问根结点 </span><br><span class="line">    stk.push(p);    //根结点进栈 </span><br><span class="line">    p = p-&gt;lchild;   //遍历左子树 </span><br><span class="line">    &#125;else&#123;</span><br><span class="line">	BiTNode* top = stk.top();    </span><br><span class="line">    stk.pop();       </span><br><span class="line">    p = top-&gt;rchild; // 遍历右子树    </span><br><span class="line">    &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3><span id="5后序遍历">5.后序遍历</span></h3><h4><span id="1递归">（1）递归</span></h4><p>若二叉树为空，则空操作，否则：</p>
<ul>
<li>后序遍历左子树；</li>
<li>后序遍历右子树。</li>
<li>访问根结点；</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void PostOrderTraverse(BiTree T)&#123;</span><br><span class="line">//后序遍历的递归算法</span><br><span class="line">if(T)&#123;</span><br><span class="line">	PostOrderTraverse(T-&gt;lchild);//后序遍历左子树</span><br><span class="line">	PostOrderTraverse(T-&gt;rchild);//后序遍历右子树</span><br><span class="line">	cout&lt;&lt;T-&gt;data;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="6层序遍历">6.层序遍历</span></h3><h4><span id="1队列法">（1）队列法</span></h4><ul>
<li>将二叉树的根结点进队；</li>
<li>判断队不为空，则对根结点进行访问：将队头输出；</li>
<li>判断结点有左孩子，就把左孩子进队，结点有右孩子，就把右孩子进队；</li>
<li>遍历过的结点出队。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void LevelOrderTraverse(BiTree &amp;T)&#123;</span><br><span class="line">//用队列实现层序遍历 </span><br><span class="line">queue&lt;BiTNode*&gt;q;</span><br><span class="line">if(T) q.push(T);//根结点进队</span><br><span class="line">while(!q.empty())&#123;</span><br><span class="line">	cout&lt;&lt;q.front()-&gt;data;//访问根结点</span><br><span class="line">	if (q.front()-&gt;lchild)   //如果有左孩子，leftChild入队列</span><br><span class="line">    &#123;</span><br><span class="line">        q.push(q.front()-&gt;lchild);   </span><br><span class="line">    &#125;</span><br><span class="line">    if (q.front()-&gt;rchild)   //如果有右孩子，rightChild入队列</span><br><span class="line">    &#123;</span><br><span class="line">        q.push(q.front()-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">    q.pop();  //已经遍历过的节点出队列</span><br><span class="line">	&#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4><span id="2数组法">（2）数组法</span></h4><ul>
<li>检查根结点是否为空，如果为空立即返回；</li>
<li>创建BiTNode指针类型的指针数组，定义in、out变量，它们模拟了队列的进队和出队，用于跟踪在数组temp中哪个位置是下一个要插入节点的位置（in），以及哪个位置是当前要处理的节点（out）；</li>
<li>进队，保存根结点；</li>
<li>如果已经进队（in&gt;out)，循环执行以下操作：</li>
<li>​    定义临时结点变量，保存队列头部结点，out出队；</li>
<li>​    如果结点存在，访问结点；</li>
<li>​    检查左、右孩子是否存在，把它们加进队列中。</li>
<li>如果in的值溢出，中断返回。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void LevelOrderTraverse1(BiTree T)&#123;</span><br><span class="line">//创建结构体数组实现层序遍历</span><br><span class="line">//#define MAXTSIZE 100</span><br><span class="line">if(!T) return;</span><br><span class="line"></span><br><span class="line">BiTNode* temp[MAXTSIZE]; ////创建BiTNode指针类型的指针数组</span><br><span class="line">int in=0;</span><br><span class="line">int out=0;</span><br><span class="line">temp[in++]=T;//保存根结点</span><br><span class="line">while(in&gt;out)&#123;</span><br><span class="line">	BiTNode* node = temp[out++]; // 取出队列头部节点</span><br><span class="line">	if(node)&#123;</span><br><span class="line">	cout&lt;&lt;node-&gt;data;//访问结点 </span><br><span class="line">	if (node-&gt;lchild) temp[in++] = node-&gt;lchild;  </span><br><span class="line">  if (node-&gt;rchild) temp[in++] = node-&gt;rchild; </span><br><span class="line">	&#125;</span><br><span class="line">	if(in&gt;MAXTSIZE) return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>四种遍历的输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">请输入建立二叉链表的序列：</span><br><span class="line">ABC##DE#G##F###</span><br><span class="line">中序遍历的结果为：</span><br><span class="line">CBEGDFA</span><br><span class="line">先序遍历的结果为：</span><br><span class="line">ABCDEGF</span><br><span class="line">后序遍历的结果为：</span><br><span class="line">CGEFDBA</span><br><span class="line">层序遍历的结果为：</span><br><span class="line">ABCDEFG</span><br></pre></td></tr></table></figure>



<h2><span id="二-复制二叉树">二、复制二叉树</span></h2><p>如果是空树，停止递归，否则：</p>
<ul>
<li>申请一个新结点空间，复制根结点；</li>
<li>递归复制左子树、右子树。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void copy(BiTree T,BiTree &amp;NewT)&#123;</span><br><span class="line">//复制一颗和T完全相同的二叉树</span><br><span class="line">if(T==NULL)&#123;</span><br><span class="line">	NewT=NULL;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">	NewT = new BiTNode;</span><br><span class="line">	NewT-&gt;data=T-&gt;data;//复制根结点</span><br><span class="line">	copy(T-&gt;lchild,NewT-&gt;lchild);//递归复制左子树</span><br><span class="line">	copy(T-&gt;rchild,NewT-&gt;rchild);//递归复制右子树  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历以后可以发现新树和被复制的树完全一致。</p>
<h2><span id="三-计算二叉树">三、计算二叉树</span></h2><h3><span id="1计算深度">1.计算深度</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int Depth(BiTree T)&#123;</span><br><span class="line">//计算二叉树的深度</span><br><span class="line">int m,n;</span><br><span class="line">if(T==NULL) return 0;</span><br><span class="line">else&#123;</span><br><span class="line">	m=Depth(T-&gt;lchild);//递归计算左子树的深度 </span><br><span class="line">	n=Depth(T-&gt;rchild);//递归计算右子树的深度</span><br><span class="line">	if(m&gt;n) return m+1;//取更大者 ，+1 是为了加上当前节点这一层</span><br><span class="line">	else return n+1; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="2计算高度">2.计算高度</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int GetHeight( BinTree BT )&#123;</span><br><span class="line">    if(BT == NULL)</span><br><span class="line">        return 0;</span><br><span class="line">    //left</span><br><span class="line">    int left_height = 0, right_height = 0;//定义左子树和右子树的高度变量</span><br><span class="line">    left_height = 1 + GetHeight(BT-&gt;Left);//遍历</span><br><span class="line">    //right</span><br><span class="line">    right_height = 1 + GetHeight(BT-&gt;Right);//遍历</span><br><span class="line">    if(left_height &gt; right_height)//取更高者</span><br><span class="line">        return left_height;</span><br><span class="line">    else return right_height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="四-计算二叉树的结点数">四、计算二叉树的结点数</span></h2><h3><span id="1计算结点数">1.计算结点数</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int NodeCount(BiTree T) &#123;</span><br><span class="line">	//统计二叉树T中结点的个数</span><br><span class="line">	if (T == NULL) return 0;//如果是空树，则结点个数为0，递归结束</span><br><span class="line">	else return NodeCount(T-&gt;lchild) + NodeCount(T-&gt;rchild) + 1;</span><br><span class="line">	//否则结点个数为左子树的结点个数+右子树的结点个数+1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="2计算叶子结点数">2.计算叶子结点数</span></h3><p>①</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void CountLeaf(BiTree T, int&amp; count) //求叶子结点个数 </span><br><span class="line">&#123;</span><br><span class="line">     if(T) &#123;</span><br><span class="line">        if ((!T-&gt;lchild)&amp;&amp; (!T-&gt;rchild))</span><br><span class="line">           count++;     // 对叶子结点计数	</span><br><span class="line">		CountLeaf( T-&gt;lchild, count);  </span><br><span class="line">      	CountLeaf( T-&gt;rchild, count); </span><br><span class="line">   &#125; // if</span><br><span class="line">&#125; // CountLeaf</span><br></pre></td></tr></table></figure>

<p>②</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int LeafCount ( BiTree T)</span><br><span class="line">&#123;</span><br><span class="line">    int count=0;</span><br><span class="line"></span><br><span class="line">if(T==NULL)&#123;//空树</span><br><span class="line">    return 0;</span><br><span class="line">&#125;else if(T-&gt;lchild==NULL &amp;&amp; T-&gt;rchild==NULL)&#123;//只有一个根节点</span><br><span class="line">    return count+1;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">    count=LeafCount(T-&gt;lchild)+LeafCount(T-&gt;rchild);//关系为左右相加求和</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="五-线索二叉树">五、线索二叉树</span></h2><p><strong>解决问题</strong>：</p>
<ul>
<li>在n个结点的二叉树中，必定有n+1个空链域（叶子结点的左右子树空间浪费了）</li>
<li>二叉树的遍历，无论是递归还是非递归算法，效率都不算高。</li>
</ul>
<p><strong>线索化</strong>：</p>
<p>现将某结点的<a href="https://so.csdn.net/so/search?q=%E7%A9%BA%E6%8C%87%E9%92%88&spm=1001.2101.3001.7020">空指针</a>域指向该结点的前驱后继，定义规则如下</p>
<blockquote>
<ul>
<li>若结点的左子树为空，则该结点的左孩子指针指向其前驱结点</li>
<li>若结点的右子树为空，则该结点的右孩子指针指向其后继结点</li>
</ul>
<p>这种指向前驱和后继的<strong>指针</strong>称为<strong>线索</strong>，将一棵普通的二叉树以某种次序遍历，并添加线索的过程称为线索化。</p>
</blockquote>
<p><img src="/2024/05/28/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E9%81%8D%E5%8E%86/ccb64328668a46c69a90bd7a9059d8bb.png" alt="ccb64328668a46c69a90bd7a9059d8bb"></p>
<p>添加标志位ltag和rtag,并定义以下规则</p>
<ul>
<li>ltag0，指向左孩子；ltag&#x3D;&#x3D;1，指向前驱结点</li>
<li>rtag0，指向右孩子；rtag&#x3D;&#x3D;1，指向后继结点</li>
</ul>
<p>从而区分诸如lchild指向的是左孩子还是前驱结点</p>
<h3><span id="1定义">1.定义</span></h3><p>其中pre是全局变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct BiThrNode&#123;</span><br><span class="line">	char data;</span><br><span class="line">	struct BiThrNode *lchild,*rchild;</span><br><span class="line">	int Ltag,Rtag;</span><br><span class="line">&#125;BiThrNode,*BiThrTree;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BiThrNode* pre;//前驱结点的变量</span><br></pre></td></tr></table></figure>

<h3><span id="2创建">2.创建</span></h3><p>一定要对Ltag和Rtag初始化！！这里排查了好久</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void CreateBiTree(BiThrTree &amp;T)&#123;</span><br><span class="line">//按先序遍历的顺序建立二叉链表 </span><br><span class="line">	char ch;</span><br><span class="line">	cin&gt;&gt;ch;</span><br><span class="line">	if(ch == &#x27;#&#x27;) T=NULL; //递归结束</span><br><span class="line">	else&#123;</span><br><span class="line">		T = new BiThrNode; //根结点 </span><br><span class="line">		T-&gt;data =ch;</span><br><span class="line">		T-&gt;Ltag = 0;       //这里一定要加上，不然后边会出错 </span><br><span class="line">    T-&gt;Rtag = 0;</span><br><span class="line">		CreateBiTree(T-&gt;lchild);//递归创建左子树 </span><br><span class="line">		CreateBiTree(T-&gt;rchild);//递归创建右子树 </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="3线索化">3.线索化</span></h3><ul>
<li>如果p非空，左子树递归线索化；</li>
<li>如果p的左孩子为空，给p加上左线索，Ltag&#x3D;1，让p的左孩子指针指向pre（前驱）；否则Ltag&#x3D;0；</li>
<li>如果p的右孩子为空，给pre加上右线索，Rtag&#x3D;1，让pre的右孩子指向p（后继），否则Rtag&#x3D;0；</li>
<li>将pre指向刚访问过的结点p，即pre&#x3D;p；</li>
<li>右子树递归线索化。</li>
</ul>
<p><img src="/2024/05/28/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E9%81%8D%E5%8E%86/ccb64328668a46c69a90bd7a9059d8bb-1716878459234-2.png" alt="ccb64328668a46c69a90bd7a9059d8bb"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void InThreading(BiThrTree p)&#123;</span><br><span class="line">	if(p)&#123;</span><br><span class="line">    InThreading(p-&gt;lchild);   //递归左子树线索化</span><br><span class="line">    if(!p-&gt;lchild)&#123;           //没有左孩子</span><br><span class="line">        p-&gt;Ltag = 1;    //前驱线索</span><br><span class="line">        p-&gt;lchild = pre; //左孩子指针指向前驱</span><br><span class="line">    &#125;</span><br><span class="line">    if(!pre-&gt;rchild)&#123;     //没有右孩子</span><br><span class="line">        pre-&gt;Rtag = 1;  //后继线索</span><br><span class="line">        pre-&gt;rchild = p; //前驱右孩子指针指向后继(当前结点p)</span><br><span class="line">    &#125;</span><br><span class="line">    pre = p; //保持pre指向p的前驱 </span><br><span class="line">    InThreading(p-&gt;rchild);      //递归右子树线索化</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void InOrderThreading(BiThrTree &amp;Thrt,BiThrTree T)&#123;</span><br><span class="line">	Thrt = new BiThrNode;//建立头结点 </span><br><span class="line">	Thrt-&gt;Ltag=0;//头结点有左孩子，若树非空，则其左孩子为树根</span><br><span class="line">	Thrt-&gt;Rtag=1;//头结点的右孩子指针为右线索</span><br><span class="line">	Thrt-&gt;rchild=Thrt;//初始化时右指针指向自己</span><br><span class="line">	if(!T) Thrt-&gt;lchild=Thrt;//若树为空，则左指针也指向自己</span><br><span class="line">	else&#123;</span><br><span class="line">		Thrt -&gt;lchild=T;//头结点的左孩子指向根 </span><br><span class="line">		pre = Thrt;//pre初值指向头结点 </span><br><span class="line">		InThreading(T);//对以T为根的二叉树进行线索化</span><br><span class="line">		pre-&gt;rchild=Thrt;//结束后，pre为最右结点，pre的右线索指向头结点</span><br><span class="line">		pre-&gt;Rtag=1;</span><br><span class="line">		Thrt-&gt;rchild=pre;//头结点的右线索指向pre </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="4中序遍历">4.中序遍历</span></h3><ul>
<li>指针p指向根结点；</li>
<li>p非空或遍历未结束时：</li>
<li>沿着左孩子向下，到达最左下结点*p，它是中序的第一个结点；</li>
<li>访问*p；</li>
<li>沿着右线索反复查找当前结点*p的后继结点并访问后继结点，直至右线索为0或者遍历结束；</li>
<li>转向p的右子树。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void InOrderThraverse_Thr(BiThrTree T) &#123;  </span><br><span class="line">    BiThrTree p = T-&gt;lchild;  //p指向根结点</span><br><span class="line">    while (p != T) &#123;  //空树或遍历结束时，p==T</span><br><span class="line">    // 遍历左子树  </span><br><span class="line">    while (p-&gt;Ltag == 0) p = p-&gt;lchild;//沿着左孩子向下</span><br><span class="line">	cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;;   //访问其左子树为空的结点</span><br><span class="line">    while (p-&gt;Rtag == 1 &amp;&amp; p-&gt;rchild != T)&#123;  </span><br><span class="line">        p = p-&gt;rchild;  </span><br><span class="line">        cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;;  //沿着右线索访问后继结点</span><br><span class="line">    &#125;  </span><br><span class="line">    p = p-&gt;rchild;  //转向p的右子树</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>数据结构笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>串的存储和表现</title>
    <url>/2024/05/31/%E4%B8%B2%E5%92%8C%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#%E4%B8%80-%E4%B8%B2%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84">一、串的存储结构</a><ul>
<li><a href="#1%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8">1.顺序存储</a></li>
<li><a href="#2%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8">2.链式存储</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C-%E4%B8%B2%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95">二、串的模式匹配算法</a><ul>
<li><a href="#1bf%E7%AE%97%E6%B3%95">1.BF算法</a></li>
<li><a href="#2kmp%E7%AE%97%E6%B3%95">2.KMP算法</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<p>[TOC]</p>
<h2><span id="一-串的存储结构">一、串的存储结构</span></h2><h3><span id="1顺序存储">1.顺序存储</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define MAXLEN 255 //串的最大长度</span><br><span class="line">typedef struct&#123;</span><br><span class="line">//串的定长顺序存储结构</span><br><span class="line">char ch[MAXLEN+1]; //存储串的一位数组，下标0的分量闲置不用</span><br><span class="line">int length; //串的当前长度</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line">//串的堆式顺序存储结构</span><br><span class="line">char *ch; //若是非空串，则按串长分配存储区，否则ch为NULL</span><br><span class="line">int length;</span><br><span class="line">&#125;HString;</span><br></pre></td></tr></table></figure>

<h3><span id="2链式存储">2.链式存储</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define CHUNKSIZE 80</span><br><span class="line">typedef struct Chunk&#123;</span><br><span class="line">char ch[CHUNKSIZE];</span><br><span class="line">struct Chunk *next;</span><br><span class="line">&#125;Chunk;</span><br><span class="line">typedef struct&#123;</span><br><span class="line">Chunk *head,*tail; //串的头、尾指针</span><br><span class="line">int length; //串的当前长度</span><br><span class="line">&#125;LString;</span><br></pre></td></tr></table></figure>



<h2><span id="二-串的模式匹配算法">二、串的模式匹配算法</span></h2><h3><span id="1bf算法">1.BF算法</span></h3><ul>
<li><p>分别利用计数指针i和j，指示主串S和模式T中当前正待比较的字符位置，i初值为pos，j初值为0；</p>
</li>
<li><p>如果两个串均未比较到串尾，即i和j均分别小于等于S和T的长度时，循环执行操作：</p>
</li>
<li><p>S.ch[i]和T.ch[i]比较，若相等，则i和j分别指示串中下一个位置，继续比较后续字符；</p>
</li>
<li><p>若不等，指针后退重新匹配，从主串的下一个字符（i&#x3D;i-j+2）起再重新和模式的第一个字符(j&#x3D;0)比较；</p>
</li>
<li><p>如果j&gt;length，说明模式T的每个字符依次和主串S中的一个连续的字符序列相等，则匹配成功，返回和模式T中第一个字符相等的字符在主串S中的符号（i-T.length），否则不成功，返回0。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//算法4.1　BF算法</span><br><span class="line">int Index(SString S, SString T, int pos)</span><br><span class="line">&#123;</span><br><span class="line">	//返回模式T在主串S中第pos个字符之后第s一次出现的位置。若不存在，则返回值为0</span><br><span class="line">	//其中，T非空，1≤pos≤StrLength(S)</span><br><span class="line">	int i = pos;</span><br><span class="line">	int j = 1;</span><br><span class="line">	while(i &lt;= S[0]&amp;&amp;j &lt;= T[0])</span><br><span class="line">	&#123;</span><br><span class="line">		if(S[i]==T[j])</span><br><span class="line">		&#123;</span><br><span class="line">			++i;</span><br><span class="line">			++j;</span><br><span class="line">		&#125; //继续比较后继字符</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			i=i-j+2;</span><br><span class="line">			j=1;</span><br><span class="line">		&#125; //指针后退重新开始匹配</span><br><span class="line">	&#125;</span><br><span class="line">	if (j &gt; T[0])</span><br><span class="line">		return i - T[0];</span><br><span class="line">	else</span><br><span class="line">		return 0;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;//Index</span><br></pre></td></tr></table></figure>

<p>最好情况下的平均时间复杂度是O(n+m);</p>
<p>最坏情况下的平均时间复杂度是O(n*m).</p>
<h3><span id="2kmp算法">2.KMP算法</span></h3><p>特点：指针不需要回溯</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//算法4.2　KMP算法</span><br><span class="line">int Index_KMP(SString S, SString T, int pos, int next[])</span><br><span class="line">&#123; 	// 利用模式串T的next函数求T在主串S中第pos个字符之后的位置的KMP算法</span><br><span class="line">	//其中，T非空，1≤pos≤StrLength(S)</span><br><span class="line">	int i = pos, j = 1;</span><br><span class="line">	while (i &lt;= S[0] &amp;&amp; j &lt;= T[0])</span><br><span class="line">		if (j == 0 || S[i] == T[j]) // 继续比较后继字</span><br><span class="line">		&#123;</span><br><span class="line">			++i;</span><br><span class="line">			++j;</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">			j = next[j]; // 模式串向右移动</span><br><span class="line">	if (j &gt; T[0]) // 匹配成功</span><br><span class="line">		return i - T[0];</span><br><span class="line">	else</span><br><span class="line">		return 0;</span><br><span class="line">&#125;//Index_KMP</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//算法4.3　计算next函数值</span><br><span class="line">void get_next(SString T, int next[])</span><br><span class="line">&#123; //求模式串T的next函数值并存入数组next</span><br><span class="line">	int i = 1, j = 0;</span><br><span class="line">	next[1] = 0;</span><br><span class="line">	while (i &lt; T[0])</span><br><span class="line">		if (j == 0 || T[i] == T[j])</span><br><span class="line">		&#123;</span><br><span class="line">			++i;</span><br><span class="line">			++j;</span><br><span class="line">			next[i] = j;</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">			j = next[j];</span><br><span class="line">&#125;//get_next</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>数据结构笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>仿真自由落体的小球</title>
    <url>/2024/07/04/%E4%BB%BF%E7%9C%9F%E8%87%AA%E7%94%B1%E8%90%BD%E4%BD%93%E7%9A%84%E5%B0%8F%E7%90%83/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#1-%E6%98%BE%E7%A4%BA%E4%B8%80%E4%B8%AA%E9%9D%99%E6%AD%A2%E5%B0%8F%E7%90%83">1 显示一个静止小球</a></li>
<li><a href="#2-%E6%98%BE%E7%A4%BA%E5%A4%9A%E4%B8%AA%E5%B0%8F%E7%90%83">2 显示多个小球</a></li>
<li><a href="#3-%E5%B0%8F%E7%90%83%E4%B8%8B%E8%90%BD%E5%8A%A8%E7%94%BB">3 小球下落动画</a></li>
<li><a href="#4-%E5%B0%8F%E7%90%83%E9%87%8D%E5%A4%8D%E4%B8%8B%E8%90%BD">4 小球重复下落</a></li>
<li><a href="#5-%E5%B0%8F%E7%90%83%E4%B8%8A%E4%B8%8B%E5%8F%8D%E5%BC%B9">5 小球上下反弹</a></li>
<li><a href="#6-%E5%B0%8F%E7%90%83%E5%8A%A0%E9%80%9F%E4%B8%8B%E8%90%BD">6 小球加速下落</a></li>
</ul>
<!-- tocstop -->

<p>[TOC]</p>
<p>在本文，将研究如何实现小球受重力影响加速下落后，碰到地面反弹的效果。</p>
<h3><span id="1-显示一个静止小球">1 显示一个静止小球</span></h3><h4><span id="代码实现">【代码实现】</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;graphics.h&gt;//引用图形库头文件</span><br><span class="line">#include &lt;conio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	initgraph(400, 400);    //创建窗口大小为400x400像素</span><br><span class="line">	circle(200, 200, 100);    //画圆，圆心(200,200),半径100</span><br><span class="line">	_getch();      //按任意键继续,防止闪退</span><br><span class="line">	closegraph();   //关闭绘图窗口</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="效果展示">【效果展示】</span></h4><p><img src="/2024/07/04/%E4%BB%BF%E7%9C%9F%E8%87%AA%E7%94%B1%E8%90%BD%E4%BD%93%E7%9A%84%E5%B0%8F%E7%90%83/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240704214842.png" alt="微信截图_20240704214842"></p>
<h3><span id="2-显示多个小球">2 显示多个小球</span></h3><h4><span id="代码实现">【代码实现】</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;graphics.h&gt;//引用图形库头文件</span><br><span class="line">#include &lt;conio.h&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	initgraph(400, 400);    //创建窗口大小为400x400像素</span><br><span class="line">	fillcircle(200, 100, 50);    //画实心圆，圆心(200,100),半径50</span><br><span class="line">	fillcircle(200, 200, 50);    //画实心圆，圆心(200,200),半径50</span><br><span class="line">	fillcircle(200, 300, 50);    //画实心圆，圆心(200,300),半径50</span><br><span class="line">	_getch();      //按任意键继续,防止闪退</span><br><span class="line">	closegraph();   //关闭绘图窗口</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="效果展示">【效果展示】</span></h4><p><img src="/2024/07/04/%E4%BB%BF%E7%9C%9F%E8%87%AA%E7%94%B1%E8%90%BD%E4%BD%93%E7%9A%84%E5%B0%8F%E7%90%83/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240704215629.png" alt="微信截图_20240704215629"></p>
<p>利用四则运算，可以让3个小球上下均匀分布</p>
<h4><span id="代码">【代码】</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;graphics.h&gt;//引用图形库头文件</span><br><span class="line">#include &lt;conio.h&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int hight = 800;</span><br><span class="line">	initgraph(600, hight);   </span><br><span class="line">	fillcircle(200, 1 * hight / 4, 50);</span><br><span class="line">	fillcircle(200, 2 * hight / 4, 50);</span><br><span class="line">	fillcircle(200, 3 * hight / 4, 50);</span><br><span class="line">	_getch();      //按任意键继续,防止闪退</span><br><span class="line">	closegraph();   //关闭绘图窗口</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/04/%E4%BB%BF%E7%9C%9F%E8%87%AA%E7%94%B1%E8%90%BD%E4%BD%93%E7%9A%84%E5%B0%8F%E7%90%83/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240704220235.png" alt="微信截图_20240704220235"></p>
<p>用变量step记录小球之间的距离，用y记录小球的起始位置。</p>
<p>每一次输出小球就增加一次距离，实现输出多个均匀分布的小球</p>
<h4><span id="代码">【代码】</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;graphics.h&gt;//引用图形库头文件</span><br><span class="line">#include &lt;conio.h&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int y = 100;</span><br><span class="line">	int step = 100;</span><br><span class="line">	initgraph(600, 600);</span><br><span class="line">	fillcircle(300, y, 20);</span><br><span class="line">	y = y + step;</span><br><span class="line">	fillcircle(300, y, 20);</span><br><span class="line">	y = y + step;</span><br><span class="line">	fillcircle(300, y, 20);</span><br><span class="line">	y = y + step;</span><br><span class="line">	fillcircle(300, y, 20);</span><br><span class="line">	y = y + step;</span><br><span class="line">	fillcircle(300, y, 20);</span><br><span class="line">	y = y + step;</span><br><span class="line">	_getch();      //按任意键继续,防止闪退</span><br><span class="line">	closegraph();   //关闭绘图窗口</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/04/%E4%BB%BF%E7%9C%9F%E8%87%AA%E7%94%B1%E8%90%BD%E4%BD%93%E7%9A%84%E5%B0%8F%E7%90%83/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240704222338.png" alt="微信截图_20240704222338"></p>
<h3><span id="3-小球下落动画">3 小球下落动画</span></h3><p><strong>cleardevice();&#x2F;&#x2F;清屏函数</strong></p>
<p><strong>Sleep(1000);&#x2F;&#x2F;表示程序暂停100毫秒</strong></p>
<h4><span id="代码实现">【代码实现】</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;graphics.h&gt;//引用图形库头文件</span><br><span class="line">#include &lt;conio.h&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int y = 100;</span><br><span class="line">	int step = 100;</span><br><span class="line">	initgraph(600, 600);</span><br><span class="line">	while (1) &#123;</span><br><span class="line">		cleardevice();//清屏函数，在绘制新小球前清除画面上的内容</span><br><span class="line">		fillcircle(300, y, 20);</span><br><span class="line">		Sleep(100);//表示程序暂停100毫秒</span><br><span class="line">		y = y + step;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	_getch();      //按任意键继续,防止闪退</span><br><span class="line">	closegraph();   //关闭绘图窗口</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="4-小球重复下落">4 小球重复下落</span></h3><p>通过不断的执行y坐标的增加使小球下落，当小球到底时，使y值回归</p>
<h4><span id="代码实现">【代码实现】</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;graphics.h&gt;//引用图形库头文件</span><br><span class="line">#include &lt;conio.h&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int y = 50;</span><br><span class="line">	initgraph(600, 600);</span><br><span class="line">	while (1) &#123;</span><br><span class="line">		y++;</span><br><span class="line">		if (y &gt; 620)</span><br><span class="line">			y = -20;</span><br><span class="line">		cleardevice();//清屏函数，在绘制新小球前清除画面上的内容</span><br><span class="line">		fillcircle(300, y, 20);</span><br><span class="line">		Sleep(10);//表示程序暂停10毫秒</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	_getch();      //按任意键继续,防止闪退</span><br><span class="line">	closegraph();   //关闭绘图窗口</span><br><span class="line">	return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="5-小球上下反弹">5 小球上下反弹</span></h3><p>通过增加一个变量xy值，记录小球在y轴方向上的速度。</p>
<p>当小球和下窗口接触时，坐标&#x3D;600-20&#x3D;580，和上窗口接触时，坐标&#x3D;20。</p>
<p>为了实现反弹，只需要把xy反向。即xy&#x3D;-xy</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;graphics.h&gt;//引用图形库头文件</span><br><span class="line">#include &lt;conio.h&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int y = 50;</span><br><span class="line">	int xy = 3;//速度</span><br><span class="line">	initgraph(600, 600);</span><br><span class="line">	while (1) &#123;</span><br><span class="line">		y += xy;</span><br><span class="line">		if (y &gt;= 580 || y&lt;20)</span><br><span class="line">			xy = -xy;</span><br><span class="line">		cleardevice();//清屏函数，在绘制新小球前清除画面上的内容</span><br><span class="line">		fillcircle(300, y, 20);</span><br><span class="line">		Sleep(10);//表示程序暂停10毫秒</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	_getch();      //按任意键继续,防止闪退</span><br><span class="line">	closegraph();   //关闭绘图窗口</span><br><span class="line">	return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="6-小球加速下落">6 小球加速下落</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;graphics.h&gt;//引用图形库头文件</span><br><span class="line">#include &lt;conio.h&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	float y = 100;//y坐标</span><br><span class="line">	float xy = 0;//y方向速度</span><br><span class="line">	float g = 0.5;//y方向加速度</span><br><span class="line">	initgraph(600, 600);</span><br><span class="line">	while (1) &#123;</span><br><span class="line">		cleardevice();//清屏函数，在绘制新小球前清除画面上的内容</span><br><span class="line">		xy = xy + g;//利用加速度更新xy速度</span><br><span class="line">		y = y + xy;</span><br><span class="line">		if (y &gt;= 580)</span><br><span class="line">			xy = -0.95*xy;//受阻力影响</span><br><span class="line">		if (y &gt; 580) y = 580; //防止小球穿过地面</span><br><span class="line">		fillcircle(300, y, 20);</span><br><span class="line">		Sleep(10);//表示程序暂停10毫秒</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	_getch();      //按任意键继续,防止闪退</span><br><span class="line">	closegraph();   //关闭绘图窗口</span><br><span class="line">	return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>C++_EasyX 项目</tag>
      </tags>
  </entry>
  <entry>
    <title>【unity2d】项目报告 横板2d跑酷游戏 SuperNikki</title>
    <url>/2024/08/08/%E3%80%90unity2d%E3%80%91%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-%E6%A8%AA%E6%9D%BF2d%E8%B7%91%E9%85%B7%E6%B8%B8%E6%88%8F-SuperNikki/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#1-%E5%88%9B%E5%BB%BA%E6%96%B0%E9%A1%B9%E7%9B%AE">1 创建新项目</a></li>
<li><a href="#2-%E4%BD%BF%E7%94%A8%E5%9B%BE%E5%83%8F%E7%B4%A0%E6%9D%90%E5%88%B6%E4%BD%9C%E6%B8%B8%E6%88%8F%E7%94%BB%E9%9D%A2">2 使用图像素材制作游戏画面</a></li>
<li><a href="#3-%E5%88%B6%E4%BD%9C%E7%8E%A9%E5%AE%B6%E8%A7%92%E8%89%B2">3 制作玩家角色</a></li>
<li><a href="#4-%E7%94%A8%E8%84%9A%E6%9C%AC%E6%8E%A7%E5%88%B6%E8%A7%92%E8%89%B2%E7%A7%BB%E5%8A%A8-%E8%B7%B3%E8%B7%83-%E5%8A%A8%E7%94%BB">4 用脚本控制角色移动、跳跃、动画</a></li>
<li><a href="#5-%E5%88%B6%E4%BD%9C%E6%B8%B8%E6%88%8F%E5%85%B3%E5%8D%A1">5 制作游戏关卡</a></li>
<li><a href="#6-%E5%BC%80%E5%8F%91%E6%B8%B8%E6%88%8F%E7%9A%84ui">6 开发游戏的UI</a></li>
</ul>
<!-- tocstop -->

<p>[TOC]</p>
<h2><span id="1-创建新项目">1 创建新项目</span></h2><p>启动unity，点击“新项目”，选择“2d”，这样就创建了一个新项目。</p>
<p><strong>导入素材有两种方法：</strong></p>
<p>①点击window菜单栏 -&gt; Asset Store -&gt; 搜索 -&gt; Import</p>
<p>将所有资源一次性全部导入。</p>
<p>② 准备好本地资源，拖拽到Assets文件夹下。</p>
<p><strong>保存游戏关卡：</strong></p>
<p>点击File -&gt; save as -&gt; 选择Scenes文件夹 -&gt; 重命名为“Stage1” -&gt; 保存。</p>
<p>点击File -&gt; Build Settings…，将保存好的场景文件拖拽到Scenes in build的框内，这样这个场景就可以使用了。</p>
<h2><span id="2-使用图像素材制作游戏画面">2 使用图像素材制作游戏画面</span></h2><p>将背景图像和跳台图像拖拽到场景视图中，注意要放在摄像机的范围内，并将跳台的Order in layer设置为2（0以上的数值）。</p>
<p>把玩家图像拖拽到场景视图中，Order in layer设置为3。</p>
<p>这样，图像显示的优先顺序就变成了玩家&gt;跳台&gt;背景。</p>
<h2><span id="3-制作玩家角色">3 制作玩家角色</span></h2><p>选择玩家，单击Add Component -&gt; 搜索Rigidbody 2D -&gt; 单击添加。</p>
<p>将重力Gravity Scale设置为1.5。</p>
<p>勾选Freeze Rotation Z。（禁止旋转）</p>
<p>单击Add Component -&gt; 添加Capsule Collider 2D。</p>
<p><strong>给物体添加碰撞体积：</strong></p>
<p>选中跳台，单击Add Component -&gt; 搜索Rigidbody 2D -&gt; 单击添加。</p>
<p>这样，也给跳台添加了重力效果。</p>
<p>单击Add Component -&gt; 添加Box collider 2D，这样就给跳台添加了碰撞体积。</p>
<p><img src="/2024/08/08/%E3%80%90unity2d%E3%80%91%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-%E6%A8%AA%E6%9D%BF2d%E8%B7%91%E9%85%B7%E6%B8%B8%E6%88%8F-SuperNikki/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240808020912.png" alt="微信截图_20240808020912"></p>
<p>可以看到角色稳稳当当地落在跳台上。</p>
<h2><span id="4-用脚本控制角色移动-跳跃-动画">4 用脚本控制角色移动、跳跃、动画</span></h2><p>新建C#脚本，命名为PlayerController。</p>
<p>拖拽脚本使其附着在玩家角色上。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GameObject obj =（游戏物体）.GetComponent&lt;类型名&gt;();</span><br><span class="line">可以用此方法取得附着于该游戏物体上的任意组件。</span><br><span class="line">当用的是this.时，表示从自身取得。此外，this.的写法可以省略。</span><br></pre></td></tr></table></figure>

<p><strong>Update函数：</strong></p>
<p>游戏通过定期对画面进行微小的刷新，来使画面看起来在动，这就是帧。</p>
<p>在unity中，每一帧都会调用一次update函数，将画面刷新和游戏动作相关的内容在update函数中实现，就可以反映在游戏中了。</p>
<p>update函数不一定就是周期调用的，FixedUpdate函数才是周期调用。</p>
<h4><span id="移动"><strong>移动：</strong></span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">float axisH = 0.0f;//输入</span><br><span class="line">//省略</span><br><span class="line">//（Update函数）</span><br><span class="line">axisH = Input.GetAxisRaw(&quot;Horizontal&quot;);</span><br></pre></td></tr></table></figure>

<p>这一行用来检测键盘的左右方向键有没有被按下。horizontal在英语中是水平的意思。<br>当按下右，GetAxisRaw会返回1.0f，<br>按下左会返回-1.0f,<br>什么都不按下会返回0.0f。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public float speed = 3.0f;//移动速度</span><br><span class="line">//省略</span><br><span class="line">//FixedUpdate函数</span><br><span class="line">rbody.velocity = new Vector2(axisH * speed, rbody.velocity.y);</span><br></pre></td></tr></table></figure>

<p>物理类的处理需要添加到FixedUpdate函数中。<br>Rigidbody2D类所带的velocity变量是反映该游戏物体当前移动速度的vector2类型的变量。通过给这个变量赋值，可以对Rigidbody2D组件的速度进行操作。<br>右：3.0f，<br>左：-3.0f，<br>不动：0.0f。</p>
<h4><span id="角色翻转"><strong>角色翻转：</strong></span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (axisH &gt; 0.0f)</span><br><span class="line">&#123;</span><br><span class="line">   //向右移动</span><br><span class="line">    Debug.Log(&quot;向右移动&quot;);</span><br><span class="line">    transform.localScale = new Vector2(1, 1);</span><br><span class="line">&#125;</span><br><span class="line">    else if (axisH &lt; 0.0f) &#123;</span><br><span class="line">    //向左移动</span><br><span class="line">    Debug.Log(&quot;向左移动&quot;);</span><br><span class="line">    transform.localScale = new Vector2(-1, 1);//左右翻转</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>localScale是设置缩放倍率的参数，当其设置为负值时，就可以达到翻转效果。</p>
<h4><span id="角色跳跃"><strong>角色跳跃：</strong></span></h4><p>这一步接在5的后面。</p>
<p>对玩家角色选中Player标签。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public float jump = 9.0f;//跳跃力</span><br><span class="line">public LayerMask groundLayer;//可以落脚的层</span><br><span class="line">bool goJump = false;//跳跃开始的旗标</span><br><span class="line">bool onGround = false;//立于地面的旗标</span><br></pre></td></tr></table></figure>

<p>groundLayer是用来设定对地面增加的Ground层的。</p>
<p>层用LayerMask类型表现。</p>
<p>在LayerMask的前面加上public，从而能够在unity编辑器中修改它。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (Input.GetButtonDown(&quot;Jump&quot;))   Jump();//跳跃</span><br></pre></td></tr></table></figure>

<p>Input是用于处理输入的类。</p>
<p><strong>GetButtonDown是用于判定指定按键时候被按下的函数，返回值为bool类型。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (onGround || axisH != 0)</span><br><span class="line">&#123;</span><br><span class="line">//在地面上或速度不为0</span><br><span class="line">//更新速度</span><br><span class="line">rbody.velocity = new Vector2(axisH * speed, rbody.velocity.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现当按键松开时，玩家不会笔直坠落。</p>
<p><strong>为了使角色跳跃，调用了Rigidbody类的AddForce函数。</strong></p>
<p>这是一种为附着了Rigidbody2D组件的游戏物体施加力的方法。这里向上施加了9.0f的力，也就是向正上方起跳，然后通过AddForce的第二参数来指定施加怎样的力。</p>
<p>ForceMode2D.Impulse指定的是施加瞬时的力。</p>
<p><strong>做到这里，在脚本中找到Ground Layer，选择Ground。</strong></p>
<h4><span id="动画"><strong>动画：</strong></span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> //接触开始</span><br><span class="line">void OnTriggerEnter2D(Collider2D collision)</span><br><span class="line">&#123;</span><br><span class="line">if (collision.gameObject.tag == &quot;Goal&quot;)&#123;</span><br><span class="line">Goal();</span><br><span class="line">&#125;else if (collision.gameObject.tag == &quot;Dead&quot;)</span><br><span class="line">&#123;</span><br><span class="line">GameOver(); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OnTriggerEnter2D函数是当物体触碰到了碰撞体积时自动调用的方法。</p>
<p>其参数collision是触碰到的Collider组件，其带有的gameObject变量是附着了Collider组件的游戏物体。如果tag为Goal，就调用Goal函数，tag为Dead，就调用GameOver函数。</p>
<p>之后，调整玩家的游戏状态变量等以实现初始化。</p>
<h2><span id="5-制作游戏关卡">5 制作游戏关卡</span></h2><p>Layer-&gt; Add layer… -&gt; 新增layer为Ground。</p>
<p>对跳台和障碍物都设定为Ground。</p>
<p>将障碍物拖拽到画面上，将Order in Layer设置为2，添加Box Collider 2D组件。</p>
<p><strong>设置终点：</strong></p>
<p>把终点图像拖拽到画面上，Order in Layer设置为2，附着Box Collider 2D组件，并勾选Is Trigger，进行终点判定。</p>
<p>之后通过脚本来进行实际的终点判定。</p>
<p>Tag -&gt; Add Tag… -&gt; Tags + -&gt; 输入Goal -&gt; save保存，将标签设置为Goal标签。</p>
<p><strong>制作看不见的碰撞体积：</strong></p>
<p>为了不让玩家角色从画面的两端掉下去，需要造一堵看不见的墙，也就是碰撞体积。</p>
<p>单击层级视图左上角的+ -&gt; Create Empty -&gt; 命名为WallObject，添加两个Box Collider 2D组件，调整成适合的形状。</p>
<p><strong>制作游戏失败的碰撞体积：</strong></p>
<p>首先利用跳台制作一个空穴，判定玩家掉进空穴就会失败。</p>
<p>Create Empty -&gt; 改名为DeadObject，将Box Collider 2D组件附着在空物体上，调整成适合的形状，选中Is Trigger。再制作一个Dead标签。</p>
<h2><span id="6-开发游戏的ui">6 开发游戏的UI</span></h2><p><strong>添加图像UI：</strong></p>
<p>Create -&gt; UI -&gt; Image，这样就在层级视图中添加了一个叫做Canvas的物体。</p>
<p>选中Canvas，将Render Mode设置为Screen Space-Camera，将Order in Layer设置为10。点住Main Camera，将其拖到Render Camera的文本框中。这样Canvas的尺寸就收入了摄像机的范围内了。</p>
<p>把项目视图中的Game Start拖拽到Source Image。</p>
<p><img src="/2024/08/08/%E3%80%90unity2d%E3%80%91%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-%E6%A8%AA%E6%9D%BF2d%E8%B7%91%E9%85%B7%E6%B8%B8%E6%88%8F-SuperNikki/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240808132100.png" alt="微信截图_20240808132100"></p>
]]></content>
      <tags>
        <tag>unity2d</tag>
      </tags>
  </entry>
  <entry>
    <title>半导体器件的基本特性</title>
    <url>/2024/04/23/%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%99%A8%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h2><span id="半导体">半导体</span></h2><p>根据导电性能，物质分为：导体、绝缘体和半导体。</p>
<p>物质的导电特性取决于物质的原子结构。</p>
<p>常见的半导体：硅（Si）、锗（Ge），四价元素。</p>
<h3><span id="1本征半导体">1.<strong>本征半导体</strong></span></h3><ul>
<li>完全纯净的、结构完整的半导体。</li>
<li>在本征半导体中，自由电子和空穴<strong>成对产生，浓度相等</strong>。</li>
</ul>
<h3><span id="2n型半导体">2.N型半导体</span></h3><ul>
<li>在本侦半导体中加入“<strong>五价元素</strong>”。</li>
<li>靠自由电子导电。</li>
<li>对外呈<strong>电中性</strong>。</li>
<li>N型半导体中含有<strong>较高</strong>的自由电子浓度，<strong>自由电子</strong>是<strong>多数载流子（多子）</strong>，空穴浓度较低，是少数载流子（少子）。</li>
<li>多数载流子浓度越高，导电性能越强。</li>
</ul>
<h3><span id="3p型半导体">3.P型半导体</span></h3><ul>
<li>在本征半导体中掺入“<strong>三价元素</strong>”。</li>
<li>对外呈<strong>电中性</strong>。</li>
<li><strong>空穴</strong>为<strong>多数载流子</strong>，而自由电子为少数载流子。</li>
</ul>
<h3><span id="4载流子的运动">4.载流子的运动</span></h3><ul>
<li><strong>漂移运动</strong>： 在<strong>电场</strong>的作用下，载流子的运动称为“漂移运动”，由漂移运动产生的电流为<strong>漂移电流</strong>。</li>
<li><strong>扩散运动</strong>：由于<strong>浓度差</strong>引起的载流子运动称为“扩散运动”，产生的相应电流为<strong>扩散电流</strong>。</li>
<li>漂移运动与扩散运动相反。</li>
<li>漂移运动作用和扩散运动作用相等。</li>
</ul>
<h2><span id="pn结">PN结</span></h2><h3><span id="1形成">1.形成</span></h3><ul>
<li>扩散越多，电场越强，漂移运动越强，对扩散的阻力越大，从而达到<strong>动态平衡</strong>，形成PN结。</li>
<li>PN结的电流为0。</li>
<li>PN区交界处有一个缺少载流子的高阻区，称为<strong>阻挡区</strong>，又叫耗尽区。</li>
</ul>
<p><img src="/2024/04/23/%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%99%A8%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7/20200622205628795.jpg" alt="20200622205628795"></p>
<h3><span id="2单向导电特性">2.单向导电特性</span></h3><h4><span id="1pn结外加正向电压导通">（1）PN结外加正向电压（导通）</span></h4><ul>
<li>**正向偏置：P+N-**。</li>
<li>扩散运动增加，漂流运动减弱，多数载流子向对方区扩散形成<strong>较大的正向电流</strong>。</li>
<li>PN结<strong>导通</strong>。</li>
<li>形成的电阻为正向电阻，阻值很小。</li>
<li><strong>正向电压越大，正向电流越大</strong>。</li>
</ul>
<p><img src="/2024/04/23/%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%99%A8%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7/20200622212041521.jpg" alt="20200622212041521"></p>
<h4><span id="2pn结外加反向电压截止">（2）PN结外加反向电压（截止）</span></h4><ul>
<li>**反向偏置：N+P-**。</li>
<li>漂流作用大于扩散作用，少数载流子做漂移运动，称反向电流。</li>
<li><strong>反向电流很小</strong>。</li>
<li>反向电压再增加，反向电流也不会增加，I&#x3D;-Iₛ。</li>
<li><strong>呈现的电阻为反向电阻，阻值很大</strong>。</li>
</ul>
<p><img src="/2024/04/23/%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%99%A8%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7/20200622211350136.jpg" alt="20200622211350136"></p>
<h4><span id="3伏安特性">（3）伏安特性</span></h4><p>当反向电压超过一定数值（反向击穿电压Uᵦ）后，反向电流会突然<strong>急剧增加</strong>，称为<strong>反向击穿</strong>。</p>
<p><img src="/2024/04/23/%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%99%A8%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7/R-C.png" alt="R-C"></p>
]]></content>
      <tags>
        <tag>电子电路基础</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构课设报告——用栈和队列做表达式求值</title>
    <url>/2024/05/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E8%AE%BE%E6%8A%A5%E5%91%8A%E2%80%94%E2%80%94%E7%94%A8%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E5%81%9A%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90">【案例分析】</a></li>
<li><a href="#%E5%AE%9E%E9%AA%8C%E8%BF%87%E7%A8%8B">【实验过程】</a><ul>
<li><a href="#1%E5%AE%9A%E4%B9%89">1.定义</a></li>
<li><a href="#2%E7%94%A8map%E5%88%A4%E6%96%AD%E4%BC%98%E5%85%88%E7%BA%A7">2.用map判断优先级</a></li>
<li><a href="#3%E5%A4%84%E7%90%86%E5%A4%9A%E4%BD%8D%E6%95%B0%E9%97%AE%E9%A2%98">3.处理多位数问题</a></li>
<li><a href="#4%E5%A4%84%E7%90%86%E6%8B%AC%E5%8F%B7%E9%97%AE%E9%A2%98">4.处理括号问题</a></li>
<li><a href="#5%E8%BE%93%E5%85%A5%E5%8E%BB%E6%8E%89%E7%A9%BA%E6%A0%BC">5.输入：去掉空格</a></li>
</ul>
</li>
<li><a href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81">【完整代码】</a></li>
</ul>
<!-- tocstop -->

<p>[TOC]</p>
<h2><span id="案例分析">【案例分析】</span></h2><p>已知表达式&#x3D;操作数+操作符，其中操作数是123这样的数字，操作符是运算符和界限符（如括号）。</p>
<p>做实验前先理清：</p>
<p>1.<strong>四则运算的优先性</strong>：先乘除后加减，括号优先，从左到右。</p>
<p>2.<strong>中缀表达式转换成后缀表达式</strong>：</p>
<ul>
<li>遇到数字就直接输出到后缀表达式中，遇到操作符就判断其优先级，并将其压入栈中。</li>
<li>如果栈顶元素的优先级大于等于当前操作符，则先将栈顶元素弹出并输出到后缀表达式中，再将当前操作符压入栈中。</li>
<li>如果遇到了左括号，则直接将其压入栈中，如果遇到了右括号，则弹出栈中的元素，直到遇到了左括号为止，并将这些元素输出到后缀表达式中。</li>
<li>最后，将栈中剩余的元素依次弹出，并输出到后缀表达式中。</li>
</ul>
<p>3.<strong>后缀表达式计算</strong>：遍历后缀表达式，如果遇到数字则直接入栈，如果遇到操作符，则弹出栈顶的两个元素，进行计算后将结果入栈。最后留在栈里的就是最终结果。</p>
<h2><span id="实验过程">【实验过程】</span></h2><h3><span id="1定义">1.定义</span></h3><p>该段定义了结构体element，存放操作数num和操作符op，供stack和queue容器随时进出。</p>
<p>并在里面定义了布尔变量flag，用于识别中缀表达式当前字符是操作数还是操作符。</p>
<p>最后调用了map用于判断运算符的优先级。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct element&#123;</span><br><span class="line">double num; //存放操作数</span><br><span class="line">char op; //存放操作符</span><br><span class="line">bool flag; //true 表示操作数，false 表示操作符 </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">string str; //输入的中缀表达式</span><br><span class="line">stack&lt;element&gt;s; //操作符栈</span><br><span class="line">queue&lt;element&gt;q; //后缀表达式队列</span><br><span class="line">map&lt;char,int&gt;op; //判断优先级,字符到整型的映射 </span><br></pre></td></tr></table></figure>

<h3><span id="2用map判断优先级">2.用map判断优先级</span></h3><p>1&lt;2，先乘除后加减（括号另外考虑）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">map&lt;char,int&gt;op; //判断优先级,字符到整型的映射 </span><br><span class="line"></span><br><span class="line">op[&#x27;+&#x27;] = op[&#x27;-&#x27;] = 1;</span><br><span class="line">op[&#x27;*&#x27;] = op[&#x27;/&#x27;] = 2;</span><br></pre></td></tr></table></figure>

<p>temp.op定义为操作符栈的当前操作符</p>
<p>s.top().op是操作符栈的栈顶操作符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while(!s.empty() &amp;&amp; op[temp.op]&lt;=op[s.top().op])&#123; //当前操作符栈的优先级低于栈顶，并且栈不为空 </span><br><span class="line">  q.push(s.top());</span><br><span class="line">  s.pop();</span><br><span class="line"> &#125;</span><br><span class="line"> s.push(temp);</span><br><span class="line"> index++;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3><span id="3处理多位数问题">3.处理多位数问题</span></h3><p>一位数的方法：检测到当前读取的字符是“数字”，temp转为1，表示操作数，把字符转化成阿拉伯数并进队列。</p>
<p>多位数的方法：读取到第一个数字后进行循环判断，<strong>一直到读取完毕或者遇到不是数字的操作符</strong>，若进入循环，那么此次读入的数为 前一个 * 10 + 现在的数字</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(str[index]&gt;=&#x27;0&#x27; &amp;&amp; str[index]&lt;=&#x27;9&#x27;)&#123; //当前读取的是数字</span><br><span class="line"> temp.flag = true;</span><br><span class="line"> temp.num = str[index++]-&#x27;0&#x27; ; //转化成数字</span><br><span class="line">   while(index&gt;str.size() &amp;&amp; str[index]&gt;=&#x27;0&#x27; &amp;&amp; str[index]&lt;&#x27;9&#x27;)&#123; //处理多位数 </span><br><span class="line">   temp.num = temp.num*10 + str[index]-&#x27;0&#x27;;</span><br><span class="line">   index++; //下一位 </span><br><span class="line"> &#125;</span><br><span class="line"> q.push(temp);//进后缀表达式队列 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="4处理括号问题">4.处理括号问题</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(str[index] ==&#x27;(&#x27;) &#123;</span><br><span class="line"> s.push(temp);//对左括号，直接进操作符栈</span><br><span class="line">  index++; //下一位</span><br><span class="line">  continue;</span><br><span class="line">&#125;else if(str[index]==&#x27;)&#x27;)&#123;</span><br><span class="line">	while(s.top().op!=&#x27;(&#x27;)&#123; //为右括号匹配左括号 </span><br><span class="line">		q.push(s.top()); </span><br><span class="line">	s.pop(); //出栈元素加入到队列</span><br><span class="line">   &#125;</span><br><span class="line"> s.pop();//将左括号出栈 </span><br><span class="line"> index++;</span><br><span class="line"> continue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">temp.flag=false;</span><br><span class="line">temp.op=str[index];</span><br></pre></td></tr></table></figure>

<h3><span id="5输入去掉空格">5.输入：去掉空格</span></h3><p>基于map</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for(int i = 0; i &lt; str.size(); i++) &#123;		//去掉空格 </span><br><span class="line">	if(str[i] == &#x27; &#x27;) &#123;</span><br><span class="line">	str.erase(str.begin() + i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br></pre></td></tr></table></figure>



<h2><span id="完整代码">【完整代码】</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;map&gt; </span><br><span class="line"></span><br><span class="line">struct element&#123;</span><br><span class="line">double num; //存放操作数</span><br><span class="line">char op; //存放操作符</span><br><span class="line">bool flag; //true 表示操作数，false 表示操作符 </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">string str; //输入的中缀表达式</span><br><span class="line">stack&lt;element&gt;s; //操作符栈</span><br><span class="line">queue&lt;element&gt;q; //后缀表达式队列</span><br><span class="line">map&lt;char,int&gt;op; //判断优先级,字符到整型的映射 </span><br><span class="line"></span><br><span class="line">int suffix()&#123;</span><br><span class="line">//将中缀表达式str转换成后缀表达式 </span><br><span class="line">element temp;</span><br><span class="line">int index = 0; //当前位置 </span><br><span class="line">while(index &lt; str.size()) &#123;</span><br><span class="line">	</span><br><span class="line">if(str[index]&gt;=&#x27;0&#x27; &amp;&amp; str[index]&lt;=&#x27;9&#x27;)&#123; //当前读取的是数字</span><br><span class="line"> temp.flag = true;</span><br><span class="line"> temp.num = str[index++]-&#x27;0&#x27; ; //转化成数字</span><br><span class="line">  while(index&lt;str.size() &amp;&amp; str[index]&gt;=&#x27;0&#x27; &amp;&amp; str[index]&lt;&#x27;9&#x27;)&#123; //处理多位数 </span><br><span class="line">   temp.num = temp.num*10 + str[index]-&#x27;0&#x27;;</span><br><span class="line">   index++; //下一位 </span><br><span class="line"> &#125;</span><br><span class="line"> q.push(temp);//进后缀表达式队列 </span><br><span class="line">&#125;else&#123;</span><br><span class="line"> temp.flag = false; //当前读取的是符号</span><br><span class="line"> temp.op = str[index];</span><br><span class="line"></span><br><span class="line"> if(str[index] ==&#x27;(&#x27;) &#123;</span><br><span class="line">  s.push(temp);//对左括号，直接进操作符栈</span><br><span class="line">   index++; //下一位</span><br><span class="line">   continue;</span><br><span class="line"> &#125;else if(str[index]==&#x27;)&#x27;)&#123;</span><br><span class="line"> 	while(s.top().op!=&#x27;(&#x27;)&#123; //为右括号匹配左括号 </span><br><span class="line"> 		q.push(s.top()); </span><br><span class="line">		s.pop(); //出栈元素加入到队列</span><br><span class="line">    &#125;</span><br><span class="line">  s.pop();//将左括号出栈 </span><br><span class="line">  index++;</span><br><span class="line">  continue;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> temp.flag=false;</span><br><span class="line"> temp.op=str[index];</span><br><span class="line"></span><br><span class="line"> while(!s.empty() &amp;&amp; op[temp.op]&lt;=op[s.top().op])&#123; //当前操作符栈的优先级低于栈顶，并且栈不为空 </span><br><span class="line">  q.push(s.top());</span><br><span class="line">  s.pop();</span><br><span class="line"> &#125;</span><br><span class="line"> s.push(temp);</span><br><span class="line"> index++;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">while(!s.empty())&#123;</span><br><span class="line"> q.push(s.top());</span><br><span class="line"> s.pop();</span><br><span class="line">&#125;</span><br><span class="line">return 1;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">double cal()&#123;</span><br><span class="line">double top1,top2;</span><br><span class="line">element cur,temp;</span><br><span class="line">while(!q.empty())&#123; //后缀表达式队列从头依次读取</span><br><span class="line"> cur = q.front(); //cur记录队首</span><br><span class="line"> q.pop(); //出队列 </span><br><span class="line"> if(cur.flag==true)&#123;</span><br><span class="line">   s.push(cur); //对操作数入栈 </span><br><span class="line"> &#125;else&#123;//遇到操作符，对栈里的操作数出栈 </span><br><span class="line">   top1 = s.top().num;</span><br><span class="line">   s.pop();</span><br><span class="line">   top2 = s.top().num;</span><br><span class="line">   s.pop();</span><br><span class="line">   temp.flag=true; //记录运算结果 </span><br><span class="line">   if(cur.op == &#x27;+&#x27;) temp.num = top2+top1;</span><br><span class="line">   if(cur.op == &#x27;-&#x27;) temp.num = top2-top1;</span><br><span class="line">   if(cur.op == &#x27;*&#x27;) temp.num = top2*top1;</span><br><span class="line">   if(cur.op == &#x27;/&#x27;) temp.num = top2/top1;</span><br><span class="line">   s.push(temp);//计算结果进栈 </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return s.top().num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	op[&#x27;+&#x27;] = op[&#x27;-&#x27;] = 1;</span><br><span class="line">	op[&#x27;*&#x27;] = op[&#x27;/&#x27;] = 2;</span><br><span class="line">	getline(cin,str);</span><br><span class="line">	while(!s.empty())&#123;</span><br><span class="line">		s.pop(); //清空 </span><br><span class="line">	&#125;</span><br><span class="line">	for(int i = 0; i &lt; str.size(); i++) &#123;		//去掉空格 </span><br><span class="line">	if(str[i] == &#x27; &#x27;) &#123;</span><br><span class="line">	str.erase(str.begin() + i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	suffix();</span><br><span class="line">	cout&lt;&lt;&quot;计算结果为：&quot;&lt;&lt;cal()&lt;&lt;endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>数据结构笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>数字逻辑电路基础</title>
    <url>/2024/06/01/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#%E4%B8%80-%E6%95%B0%E5%88%B6-%E7%BC%96%E7%A0%81%E4%B8%8E%E9%80%BB%E8%BE%91%E4%BB%A3%E6%95%B0">一、数制、编码与逻辑代数</a><ul>
<li><a href="#1%E6%95%B0%E5%88%B6%E7%9A%84%E8%BD%AC%E5%8C%96">1.数制的转化</a></li>
<li><a href="#2%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E7%9A%84%E7%BC%96%E7%A0%81">2.二进制数的编码</a></li>
<li><a href="#3%E9%80%BB%E8%BE%91%E4%BB%A3%E6%95%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%80%BB%E8%BE%91">3.逻辑代数的基本逻辑</a></li>
<li><a href="#4%E9%80%BB%E8%BE%91%E5%87%BD%E6%95%B0">4.逻辑函数</a></li>
<li><a href="#5%E5%8D%A1%E8%AF%BA%E5%9B%BE">&#x3D;&#x3D;5.卡诺图&#x3D;&#x3D;</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C-%E9%9B%86%E6%88%90%E9%80%BB%E8%BE%91%E9%97%A8%E7%94%B5%E8%B7%AF">二、集成逻辑门电路</a><ul>
<li><a href="#1%E6%99%B6%E4%BD%93%E4%BA%8C%E6%9E%81%E7%AE%A1%E7%9A%84%E5%BC%80%E5%85%B3%E7%89%B9%E6%80%A7">1.晶体二极管的开关特性</a></li>
<li><a href="#2%E6%99%B6%E4%BD%93%E7%AE%A1%E7%9A%84%E5%BC%80%E5%85%B3%E7%89%B9%E6%80%A7">2.晶体管的开关特性</a></li>
<li><a href="#3%E7%94%B1%E4%BA%8C%E6%9E%81%E7%AE%A1%E5%92%8C%E6%99%B6%E4%BD%93%E7%AE%A1%E7%BB%84%E6%88%90%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%80%BB%E8%BE%91%E9%97%A8%E7%94%B5%E8%B7%AF">3.由二极管和晶体管组成的基本逻辑门电路</a></li>
<li><a href="#1%E4%B8%8E%E9%97%A8">（1）与门</a></li>
<li><a href="#2%E9%9D%9E%E9%97%A8">（2）非门</a></li>
<li><a href="#3ttl%E4%B8%8E%E9%9D%9E%E9%97%A8%E7%94%B5%E8%B7%AF">(3)TTL“与非”门电路</a></li>
<li><a href="#4%E9%9B%86%E7%94%B5%E6%9E%81%E5%BC%80%E8%B7%AFttl%E7%94%B5%E8%B7%AFoc%E9%97%A8">(4)集电极开路TTL电路（OC门）</a></li>
<li><a href="#5%E4%B8%89%E6%80%81ttl%E9%97%A8tsl%E9%97%A8">(5)三态TTL门（TSL门）</a></li>
<li><a href="#4%E6%AD%A3%E9%80%BB%E8%BE%91%E5%92%8C%E8%B4%9F%E9%80%BB%E8%BE%91">4.&#x3D;&#x3D;正逻辑和负逻辑&#x3D;&#x3D;</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89-%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E7%9A%84%E5%88%86%E6%9E%90%E5%92%8C%E8%AE%BE%E8%AE%A1">三、组合逻辑电路的分析和设计</a></li>
<li><a href="#%E5%9B%9B-%E8%A7%A6%E5%8F%91%E5%99%A8">四、触发器</a></li>
</ul>
<!-- tocstop -->

<p>[TOC]</p>
<h2><span id="一-数制-编码与逻辑代数">一、数制、编码与逻辑代数</span></h2><h3><span id="1数制的转化">1.数制的转化</span></h3><p>B二进制，O八进制，D十进制，H十六进制</p>
<h3><span id="2二进制数的编码">2.二进制数的编码</span></h3><h4><span id="代码"><strong>代码</strong></span></h4><p>数值和文字符号可以用多位二进制表示，前一类表示数值的大小，后一类表示不同的符号，这种多位二进制叫做代码。</p>
<h4><span id="编码">编码</span></h4><p>按照一定的规则组合的代码，并赋予一定的含义。</p>
<h4><span id="bcd码">BCD码</span></h4><p>把十进制的每一位用多位二进制来表示，将此称为二进制编码的十进制数码，简称BCD码。</p>
<h4><span id="18421码">（1）8421码</span></h4><ul>
<li>有权：(N)ᴰ &#x3D; 8a₃ +4a₂ +2a₁ + 1a₀</li>
<li>有奇偶性：奇数的最低位为1.偶数的最低位为0</li>
<li>例子：(92.35)ᴰ &#x3D; (1001 0010 . 0011 0101)8421</li>
</ul>
<h4><span id="22421码">（2）2421码</span></h4><ul>
<li>各位的权值是2、4、2、1</li>
<li>例子：(652.37)ᴰ &#x3D; (1100 1011 0010 . 0011 1101)2421</li>
</ul>
<h4><span id="3余3码">（3）余3码</span></h4><ul>
<li>是由8421码加3（0011）得来的</li>
<li>无权</li>
</ul>
<h4><span id="4字符编码">（4）字符编码</span></h4><p>字符编码就是对可显示、不可显示的字符或控制字符的编码，以便信息的交换、处理、存储和数据传输的格式控制。</p>
<h3><span id="3逻辑代数的基本逻辑">3.逻辑代数的基本逻辑</span></h3><h4><span id="1与">（1）与</span></h4><ul>
<li>符号</li>
</ul>
<p><img src="/2024/06/01/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/20190524142450218.png" alt="20190524142450218"></p>
<ul>
<li>表达式</li>
</ul>
<p><img src="/2024/06/01/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/20190524142516260.png" alt="20190524142516260"></p>
<h4><span id="2或">（2）或<img src="/2024/06/01/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/20190524142634125.png" alt="20190524142634125"></span></h4><p><img src="/2024/06/01/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/20190524142538549.png" alt="20190524142538549"></p>
<ul>
<li>表达式：F&#x3D;A+B</li>
</ul>
<h4><span id="3非">（3）非</span></h4><img src="/2024/06/01/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/20190524142615458.png" alt="20190524142615458" style="zoom: 80%;">

<img src="/2024/06/01/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/20190524142634125-1717175618792-6.png" alt="20190524142634125" style="zoom:50%;">

<h4><span id="4异或正负逻辑">（4）异或（正负逻辑）</span></h4><p><img src="/2024/06/01/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/20190524142702131.png" alt="20190524142702131"></p>
<h4><span id="5同或正负逻辑">（5）同或（正负逻辑）</span></h4><p><img src="/2024/06/01/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/20190524142715410.png" alt="20190524142715410"></p>
<p><strong>注意：</strong>偶数个1用异或运算得到0，奇数个1用异或运算得到1</p>
<p>奇数个0用同或运算得到0，偶数个0用异或运算得到1</p>
<h3><span id="4逻辑函数">4.逻辑函数</span></h3><p>函数表达式一般化简成 <strong>与-或式</strong> ，其最简应满足的两个条件：<br>1）表达式中“与”项的个数最少；<br>2）在满足1）的前提下，每个“与”项中的变量个数最少。</p>
<h4><span id="1与或表达式积之和-或与表达式和之积">（1）与或表达式（积之和）、或与表达式（和之积）</span></h4><p><img src="/2024/06/01/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240601012350.png" alt="微信截图_20240601012350"></p>
<h4><span id="x3dx3d2常用公式x3dx3d">&#x3D;&#x3D;（2）常用公式&#x3D;&#x3D;</span></h4><p><img src="/2024/06/01/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240601012515.png" alt="微信截图_20240601012515"></p>
<h4><span id="3逻辑代数中的一些特殊规律">（3）逻辑代数中的一些特殊规律</span></h4><p>利用反演律求反函数和对偶式</p>
<p><img src="/2024/06/01/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240601012954.png" alt="微信截图_20240601012954"></p>
<h3><span id="x3dx3d5卡诺图x3dx3d">&#x3D;&#x3D;5.卡诺图&#x3D;&#x3D;</span></h3><ul>
<li>圈的个数必须是2的幂次</li>
<li>“1”相邻对称</li>
<li>至少有一个“1”是新的</li>
<li>每个“1”至少圈一次</li>
</ul>
<p><img src="/2024/06/01/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/20200329101822678.png" alt="20200329101822678"></p>
<h2><span id="二-集成逻辑门电路">二、集成逻辑门电路</span></h2><p><strong>数字电路中，二极管管被当作开关使用，三极管工作在饱和区和截止区</strong></p>
<p>一个理想的开关元件应该具备：</p>
<ul>
<li><strong>在接通状态时，其接通电阻为0；</strong></li>
<li><strong>在断开状态下，阻抗为无穷大，流过开关的电流为0；</strong></li>
<li><strong>断开和接通之间的转换能在瞬间完成，即开关时间为0。</strong></li>
</ul>
<h3><span id="1晶体二极管的开关特性">1.晶体二极管的开关特性</span></h3><p>晶体二极管由PN结构成，具备<strong>单向导电特性</strong>。</p>
<h3><span id="2晶体管的开关特性">2.晶体管的开关特性</span></h3><p><img src="/2024/06/01/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240601014239.png" alt="微信图片_20240601014239"></p>
<p><img src="/2024/06/01/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240604114230.png" alt="微信截图_20240604114230"></p>
<h3><span id="3由二极管和晶体管组成的基本逻辑门电路">3.由二极管和晶体管组成的基本逻辑门电路</span></h3><h3><span id="1与门">（1）与门</span></h3><p><img src="/2024/06/01/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240604114959.png" alt="微信截图_20240604114959"></p>
<p>对于ABC中的每个输入端而言，都只能有两种状态：<strong>高电位或低电位</strong>。</p>
<p>约定：5V左右为高电平，用1表示，0V左右为低电平，用0表示。</p>
<h3><span id="2非门">（2）非门</span></h3><p><img src="/2024/06/01/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240604115219.png" alt="微信截图_20240604115219"></p>
<h3><span id="3ttl与非门电路">(3)TTL“与非”门电路</span></h3><p><img src="/2024/06/01/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/R-C-1717473463127-4.png" alt="R-C"></p>
<p><img src="/2024/06/01/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/201801171516196998292490.png" alt="201801171516196998292490"></p>
<p><img src="/2024/06/01/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240604120300.jpg" alt="微信图片_20240604120300"></p>
<p><img src="/2024/06/01/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240604120416.jpg" alt="微信图片_20240604120416"></p>
<h3><span id="4集电极开路ttl电路oc门">(4)集电极开路TTL电路（OC门）</span></h3><p>集电极开路门又叫OC门，多个OC门输出端并联在一起可以实现<strong>线与逻辑</strong>功能。</p>
<p><img src="/2024/06/01/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/6380731668632576204449708.png_280.jpg" alt="6380731668632576204449708.png_280"></p>
<p><img src="/2024/06/01/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240604121025.png" alt="微信截图_20240604121025"></p>
<h3><span id="5三态ttl门tsl门">(5)三态TTL门（TSL门）</span></h3><p><strong>当E&#x3D;1时，构成三态“与非”门状态</strong></p>
<p>当E&#x3D;0时，构成禁止态</p>
<p>三态门的三种可能输出状态是：<strong>高电平、低电平、高阻态</strong>。</p>
<p>门电路在使用中不允许闲置输入端悬空，<strong>与门</strong>的闲置输入端应该接入<strong>高电平</strong>，<strong>或门</strong>的闲置输入端应该接入<strong>低电平</strong>。</p>
<p><img src="/2024/06/01/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240604121534.png" alt="微信截图_20240604121534"></p>
<h3><span id="4x3dx3d正逻辑和负逻辑x3dx3d">4.&#x3D;&#x3D;正逻辑和负逻辑&#x3D;&#x3D;</span></h3><p><strong>正逻辑：用高电平H表示逻辑1，用低电平L表示逻辑0</strong></p>
<p>P &#x3D; ABC</p>
<p><strong>负逻辑：用高电平H表示逻辑0，用低电平L表示逻辑1</strong></p>
<p>P&#x3D;A+B+C</p>
<p><strong>正负逻辑之间存在简单的对偶关系。</strong></p>
<p><img src="/2024/06/01/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/01d5ab979a554ea8a58784a647507fd0.png" alt="01d5ab979a554ea8a58784a647507fd0"></p>
<h2><span id="三-组合逻辑电路的分析和设计">三、组合逻辑电路的分析和设计</span></h2><p><strong>半加器、全加器、编码器，译码器</strong></p>
<p>都属于组合逻辑电路</p>
<p>组合逻辑电路的描述：真值表，卡诺图，逻辑方程，逻辑图</p>
<h2><span id="四-触发器">四、触发器</span></h2><p>触发器的输出是由当前状态和当前输入状态决定的。（输入信号和电路的原始状态）</p>
]]></content>
      <tags>
        <tag>电子电路基础</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念3 L1</title>
    <url>/2024/07/06/%E6%96%B0%E6%A6%82%E5%BF%B53-L1/</url>
    <content><![CDATA[<h2><span id="单词">单词</span></h2><h3><span id="1cat-like-像猫一样">1.cat-like 像猫一样</span></h3><p>mother-like 像母亲一样</p>
<p>childlike (lovely) 童真</p>
<p>childish(immature) 幼稚</p>
<h3><span id="2at-large-逍遥法外">2.at large 逍遥法外</span></h3><p>large —power —out of control 无法无天</p>
<p>escape  v.成功地逃跑</p>
<p>flee away 跑开</p>
<p>scatter away 四散逃窜</p>
<p>evade  v.逃避应该承担的责任</p>
<p>evade tax 逃税</p>
<p>desert  v.遗弃、舍弃、擅离</p>
<p>desert one‘s army 军人开小差</p>
<p>cut class 逃课</p>
<h3><span id="3spot">3.spot</span></h3><h4><span id="n斑点">n.斑点</span></h4><p>a beauty spot 美人痣</p>
<p>solar spot 太阳黑子(solar a.太阳的)</p>
<p>spotlight  n.聚光灯</p>
<p>be in the spotlight 众人瞩目</p>
<p>[eg]Tom Cruse is in the spolight in American film industry.</p>
<p>(to achieve a lot of attention)</p>
<p>[eg]A leopard will not change its spot. 江山易改本性难移</p>
<h4><span id="v发现">v.发现</span></h4><p>observe:观察，观测</p>
<p>discover:发现</p>
<p>recognize:认出</p>
<p>detect:探测</p>
<p>explore:探索，仔细勘察</p>
<h3><span id="4evidence-n证据">4.evidence n.证据</span></h3><p>witness 证人</p>
<p>judge 法官</p>
<p>jury 陪审团</p>
<p>self-evident a.不言自明的</p>
<p>[eg]We hold these truths to be self-evident, that all men are created equal, that they are endowed by their Creator with certain unalienable rights, that among these are life, liberty and the pursuit of happiness.</p>
<h3><span id="5oblige-v迫使某人做">5.oblige v.迫使某人做</span></h3><p>feel obliged to do 有义务做</p>
<p>[eg]Men feel obliged to take the responsibility for family.</p>
<p>compel v.使感到有义务</p>
<p>compulsory a.强制性的，强迫的，（由于法律）必须做的</p>
<p>9-year’s compulsory education 九年义务教育</p>
<p>drive v.驱使人做不愉快的事</p>
<p>drive sb nuts 都快使人疯了</p>
<p>drive me crazy</p>
<h4><span id="6hunt-v打猎-寻找">6.hunt  v.打猎 寻找</span></h4><p>hunt for 搜寻，寻找</p>
<p>go hunting for 寻找</p>
<p>hunt for a job 找工作</p>
<h4><span id="7human-beings-有别于神和动物">7.human being(s) 有别于神和动物</span></h4><p>mankind</p>
<p>[eg]in the long history of the mankind</p>
<p>human race 人的种族</p>
<p>being ①生物</p>
<p>②存在coming into being形成，出现，成立</p>
<p>for the time being 眼下</p>
<h3><span id="8corner">8.corner</span></h3><h4><span id="n角落">n角落</span></h4><p>at&#x2F;on the corner 在角落</p>
<p>in the corner 在角落里</p>
<p>around the corner 即将发生</p>
<p>cut corners 走捷径</p>
<p>[eg]The Negro（蔑称） is still languishing in the corners od American society and finds himself an exile（流亡者） in his own land.</p>
<h4><span id="v被逼到墙角">v.被逼到墙角</span></h4><p>[eg]A cornered beast will do something desperate.</p>
<h3><span id="trail">trail</span></h3><p>a trail of 一连串</p>
<p>a trail of mud 一串泥迹</p>
<p>[eg]wherever he went, the playboy left behind him a trail of broken hearts.</p>
<p>第一次出现的名词做主语，要把他放在主句的位置</p>
<h3><span id="print-n印痕">print n.印痕</span></h3><p>foot print</p>
<h2><span id="课文">课文</span></h2><ol>
<li>Pumas are large, cat-like animals which are found in America.</li>
</ol>
<p><strong>be found(there be)：产于，分布于</strong></p>
<ol start="2">
<li>When reports came into London Zoo that a wild puma had been spotted forty-five miles south of London, they were not taken seriously.</li>
</ol>
<p><strong>south of ….以南</strong></p>
<p>同位语从句 that只起连接作用</p>
<p>[eg]I was shocked when I heard the news that his father died yesterday.</p>
<p>&#x3D;&#x3D;The news is that his father died yesterday.</p>
<p>能连接同位语从句的名词有：</p>
<p><strong>①  belief 相信</strong></p>
<p><strong>②  fact 事实</strong></p>
<p><strong>③  idea 主意</strong></p>
<p><strong>④  doubt 怀疑</strong></p>
<p><strong>⑤  rumor 谣言</strong></p>
<p><strong>⑥  evidence 证据</strong></p>
<p><strong>⑦  conclusion 结论</strong></p>
<p><strong>⑧  information 消息</strong></p>
<p><strong>⑨  suggestion 建议</strong></p>
<p><strong>⑩  problem 问题</strong></p>
<p><strong>⑪ order 命令</strong></p>
<p><strong>⑫ discovery 发现</strong></p>
<p><strong>⑬ opinion 观点</strong></p>
<p>人称或指示代词的替代含义要回到句子的切近部分寻找它的中心含义。</p>
<p><strong>take sth seriously 认真对待</strong></p>
<p>take sth slightly</p>
<p>[eg]Every one ought to take life seriously.</p>
<p>[eg]Education is so important that we should take it seriously.</p>
<ol start="3">
<li>However, as the evidence began to accumulate, experts from the Zoo felt obliged to investigate, for the descriptions given by people who claimed to have seen the puma were extraordinarily similar.</li>
</ol>
<p><strong>for 引导原因状语从句，处于从属地位</strong></p>
<p><strong>as 不强调原因的重要性</strong></p>
<p><strong>since 既然</strong></p>
<p><strong>because</strong></p>
<p>claimed to have done 动词不定式的完成式</p>
<p>体现它所表示的动作发生在谓语动作之前</p>
<p><strong>be similar to sb</strong></p>
<p><strong>look &#x2F;be like</strong></p>
<p><strong>take after</strong></p>
<ol start="4">
<li>Several people complained of ‘cat-like noises’ at night and a businessman on a fishing trip saw the puma up a tree.</li>
</ol>
<p><strong>on a fishing trip to 在去钓鱼的途中</strong></p>
<p><strong>on way to</strong></p>
<ol start="5">
<li>this one must have been in the possession of a private collector and somehow managed to escape.</li>
</ol>
<p>must have been&#x2F;done sth 作者主观的肯定判断，是事实总结、归纳的标志</p>
<p><strong>in the possession of 为…所有 主语是物</strong></p>
<p><strong>in possession of主语是人</strong></p>
<p>in the authority of 由…管辖</p>
<p>in the care of 由…照看</p>
<p>in the charge of 由…负责</p>
<h2><span id="原文a-puma-at-large"><strong>原文</strong>A puma at large</span></h2><p>  Pumas are large, cat-like animals which are found in America. When reports <strong>came into</strong> London Zoo <strong>that</strong> a wild puma had been spotted forty-five miles south of London, they were not <strong>taken seriously</strong>. However, as the evidence began to accumulate, experts from the Zoo felt obliged to investigate, <strong>for</strong> the descriptions given by people who claimed to have seen the puma were extraordinarily similar.  </p>
<p>  The hunt for the puma began in a small village where a woman picking blackberries saw ‘a large cat’ only five yards away from her. It immediately <strong>ran away</strong> when she saw it, and experts <strong>confirmed that</strong> a puma will not attack a human being unless it is <strong>cornered</strong>. The search proved difficult, <strong>for</strong> the puma was often observed at one place in the morning and at another place twenty miles away in the evening. Wherever it went, it left behind it <strong>a trail of</strong> dead deer and small animals like rabbits. Paw prints were seen in <strong>a number of</strong> places and puma fur was found clinging to bushes. Several people complained of ‘cat-like noises’ at night and a businessman <strong>on a fishing trip</strong> saw the puma up a tree. The experts were now fully convinced <strong>that</strong> the animal was a puma, but where had it come from? As no pumas had been reported missing from any zoo in the country, this one <strong>must have been</strong> <strong>in the possession of</strong> a private collector and somehow <strong>managed to</strong> escape. The hunt went on for several weeks, but the puma was not caught. It is disturbing to think that a dangerous wild animal is still <strong>at large</strong> in the quiet countryside.</p>
<p>参考译文——逃遁的美洲狮</p>
<p>美洲狮是一种体形似猫的大动物，产于美洲。当伦敦动物园接到报告说，在伦敦以南45英里处发现一只美洲狮时，这些报告并没有受到重视。可是，随着证据越来越多，动物园的专家们感到有必要进行一番调查，因为凡是声称见到过美洲狮的人们所描述的情况竟是出奇地相似。</p>
<p>搜寻美洲狮的工作是从一座小村庄开始的。那里的一位妇女在采摘黑莓时的看见“一只大猫”，离她仅5码远，她刚看见它，它就立刻逃走了。专家证实，美洲狮非被逼得走投无路，是决不会伤人的。事实上搜寻工作很困难，因为常常是早晨在甲地发现那只美洲狮，晚上却在20英里外的乙地发现它的踪迹。无论它走哪儿，一路上总会留下一串死鹿及死兔子之类的小动物，在许多地方看见爪印，灌木丛中发现了粘在上面的美洲狮毛。有人抱怨说夜里听见“像猫一样的叫声”；一位商人去钓鱼，看见那只美洲狮在树上。专家们如今已经完全肯定那只动物就是美洲狮，但它是从哪儿来的呢?由于全国动物园没有一家报告丢了美洲狮，因此那只美洲狮一定是某位私人收藏豢养的，不知怎么设法逃出来了。搜寻工作进行了好几个星期，但始终未能逮住那只美洲狮。想到在宁静的乡村里有一头危险的野兽继续逍遥流窜，真令人担心。</p>
]]></content>
      <tags>
        <tag>新概念3</tag>
      </tags>
  </entry>
  <entry>
    <title>别碰方块游戏</title>
    <url>/2024/07/08/%E5%88%AB%E7%A2%B0%E6%96%B9%E5%9D%97%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#1%E6%8C%89%E7%A9%BA%E6%A0%BC%E9%94%AE%E6%8E%A7%E5%88%B6%E5%B0%8F%E7%90%83%E8%B5%B7%E8%B7%B3">1.按空格键控制小球起跳</a></li>
<li><a href="#2%E6%96%B9%E5%9D%97%E7%9A%84%E7%BB%98%E5%88%B6%E5%92%8C%E7%A7%BB%E5%8A%A8">2.方块的绘制和移动</a></li>
<li><a href="#3%E5%B0%8F%E7%90%83%E5%92%8C%E6%96%B9%E5%9D%97%E7%9A%84%E7%A2%B0%E6%92%9E%E5%88%A4%E6%96%AD">3.小球和方块的碰撞判断</a></li>
<li><a href="#4%E9%9A%8F%E6%9C%BA%E9%AB%98%E5%BA%A6%E5%92%8C%E9%80%9F%E5%BA%A6">4.随机高度和速度</a></li>
<li><a href="#5%E5%BE%97%E5%88%86%E7%9A%84%E8%AE%A1%E7%AE%97%E5%92%8C%E6%98%BE%E7%A4%BA">5.得分的计算和显示</a></li>
<li><a href="#6%E6%80%BB%E4%BB%A3%E7%A0%81">6.总代码</a></li>
</ul>
<!-- tocstop -->

<p>[TOC]</p>
<h2><span id="1按空格键控制小球起跳">1.按空格键控制小球起跳</span></h2><p>_kbhit()函数当用户有键盘输入时返回1，否则返回0.</p>
<p>_getch()函数可以储存用户输入的字符在变量中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;graphics.h&gt;//引用图形库头文件</span><br><span class="line">#include &lt;conio.h&gt;//_kbhit()所必要的头文件</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	float width = 600;//画面宽度</span><br><span class="line">	float height = 600;//画面高度</span><br><span class="line">	initgraph(height, width);//新建画布</span><br><span class="line"></span><br><span class="line">    float ball_x, ball_y, ball_vy;//小球圆心坐标x、y，y方向速度</span><br><span class="line">    float g=0.6;//重力</span><br><span class="line">    float radius = 20;//小球半径</span><br><span class="line">    ball_x = width / 4;</span><br><span class="line">    ball_y = height - radius;</span><br><span class="line">    ball_vy = 0;</span><br><span class="line">    </span><br><span class="line">    while (1) &#123;</span><br><span class="line">    	if (_kbhit()) &#123;//当按键时</span><br><span class="line">    		char input = _getch();//获得输入字符</span><br><span class="line">    		if(input == &#x27; &#x27;) ball_vy = -16;//给小球一个向上的初速度</span><br><span class="line">    	</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">    	ball_vy =ball_vy + g;//利用加速度更新xy速度</span><br><span class="line">    	ball_y = ball_y + ball_vy;</span><br><span class="line">    	if (ball_y &gt;= height - radius) &#123;//如果小球落到地上</span><br><span class="line">    		ball_vy = 0;//y速度为0</span><br><span class="line">    		ball_y = height - radius;//重置</span><br><span class="line">    	&#125;</span><br><span class="line">    	cleardevice();//清屏函数，在绘制新小球前清除画面上的内容</span><br><span class="line">    	fillcircle(ball_x, ball_y, radius);</span><br><span class="line">    	Sleep(10);//表示程序暂停10毫秒</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    closegraph();   //关闭绘图窗口</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="2方块的绘制和移动">2.方块的绘制和移动</span></h2><p>一如函数fillcircle(ball_x, ball_y, radius);可以画圆，函数fillrectangle(left,top,right,bottom)可以画矩形。其中前两个是左上角的xy坐标，后两个是右下角的xy坐标。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">float rect_left_x, rect_top_y, rect_width, rect_height;</span><br><span class="line">rect_height = 100;//方块高度</span><br><span class="line">rect_width = 20;//方块宽度</span><br><span class="line">rect_left_x = width * 3 / 4;//方块左边x坐标</span><br><span class="line">rect_top_y = height - rect_height;//方块顶部y坐标</span><br><span class="line"></span><br><span class="line">fillrectangle(rect_left_x, height - rect_height, rect_left_x + rect_width, height);//画方块</span><br></pre></td></tr></table></figure>

<p>由于方块最底部在窗口底部，因此其底部y坐标为窗口高度height。rect_height记录方块的高度，所以方块最顶部的y坐标rect_top_y为height - rect_height。</p>
<p><img src="/2024/07/08/%E5%88%AB%E7%A2%B0%E6%96%B9%E5%9D%97%E6%B8%B8%E6%88%8F/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240708190907.png" alt="微信截图_20240708190907"></p>
<p>进一步，添加变量rect_vx记录方块在x方向上的速度，并初始化为-3.</p>
<p>在while语句中，让方块从右向左移动。当方块到达窗口最左边时，再让其从最右边出现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//前略</span><br><span class="line">float ball_vy = 0;</span><br><span class="line">//中略</span><br><span class="line">rect_left_x += rect_vx;</span><br><span class="line">if (rect_left_x &lt;= 0)//如果方块跑到最左边</span><br><span class="line">	rect_left_x = width;//在最右边重新出现</span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/08/%E5%88%AB%E7%A2%B0%E6%96%B9%E5%9D%97%E6%B8%B8%E6%88%8F/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240708190945.png" alt="微信截图_20240708190945"></p>
<h2><span id="3小球和方块的碰撞判断">3.小球和方块的碰撞判断</span></h2><p>第一种情况：方块最左边在小球最右边的左侧 或者两者x坐标相同</p>
<p>第二种情况：方块最右边在小球最左边的右侧 或者两者x坐标相同</p>
<p>第三种情况：方块最上边在小球最下边的上侧 或者两者y坐标相同</p>
<pre><code>    //如果小球碰到方块
    if ((rect_left_x &lt;= ball_x + radius)
        &amp;&amp; (rect_left_x + rect_width &gt;= ball_x - radius)
        &amp;&amp; (height - rect_height &lt;= ball_y + radius)) &#123;
        Sleep(100);//慢动作效果
    &#125;
</code></pre>
<h2><span id="4随机高度和速度">4.随机高度和速度</span></h2><p>rand()可以生成随机数（整数）</p>
<p>int() float()可以实现数据类型的转化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (rect_left_x &lt;= 0) &#123;//如果方块跑到最左边</span><br><span class="line">	rect_left_x = width;//在最右边重新出现</span><br><span class="line">	rect_height = rand() % int(height / 4) + height / 4;//设置方块随机高度</span><br><span class="line">	rect_vx = rand() / float(RAND_MAX) * 4 - 7;//设置方块随机速度</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="5得分的计算和显示">5.得分的计算和显示</span></h2><p>定义整型变量记录游戏的得分，并初始化为0；</p>
<p>当方块跑到画面最左边，得分增加1；</p>
<p>当方块碰到小球时，得分清零。</p>
<p>另外，利用EasyX的文字输出功能，可输出score</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TCHAR s[20];//定义字符串数组</span><br><span class="line">_stprintf_s(s, _T(&quot;%d&quot;), score);//将score转化为字符串</span><br><span class="line">settextstyle(40, 0, _T(&quot;宋体&quot;));//设置文字大小、字体</span><br><span class="line">outtextxy(50, 30, s);//输出得分文字</span><br></pre></td></tr></table></figure>



<h2><span id="6总代码">6.总代码</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;graphics.h&gt;//引用图形库头文件</span><br><span class="line">#include &lt;conio.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	float width = 600;//画面宽度</span><br><span class="line">	float height = 600;//画面高度</span><br><span class="line">	initgraph(height, width);//新建画布</span><br><span class="line"></span><br><span class="line">    float ball_x, ball_y, ball_vy;//小球圆心坐标x、y，y方向速度</span><br><span class="line">    float g=0.6;//重力</span><br><span class="line">    float radius = 20;//小球半径</span><br><span class="line">    ball_x = width / 4;</span><br><span class="line">    ball_y = height - radius;</span><br><span class="line">    ball_vy = 0;</span><br><span class="line">    </span><br><span class="line">    float rect_left_x, rect_top_y, rect_width, rect_height,rect_vx;</span><br><span class="line">    rect_height = 100;//方块高度</span><br><span class="line">    rect_width = 20;//方块宽度</span><br><span class="line">    rect_left_x = width * 3 / 4;//方块左边x坐标</span><br><span class="line">    rect_top_y = height - rect_height;//方块顶部y坐标</span><br><span class="line">    rect_vx = -3;</span><br><span class="line">    </span><br><span class="line">    int score = 0;//得分</span><br><span class="line">    while (1) &#123;</span><br><span class="line">    	if (_kbhit()) &#123;//当按键时</span><br><span class="line">    		char input = _getch();//获得输入字符</span><br><span class="line">    		if(input == &#x27; &#x27;) ball_vy = -16;//给小球一个向上的初速度</span><br><span class="line">    	</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">    	ball_vy =ball_vy + g;//利用加速度更新xy速度</span><br><span class="line">    	ball_y = ball_y + ball_vy;</span><br><span class="line">    	if (ball_y &gt;= height - radius) &#123;//如果小球落到地上</span><br><span class="line">    		ball_vy = 0;//y速度为0</span><br><span class="line">    		ball_y = height - radius;//重置</span><br><span class="line">    	&#125;</span><br><span class="line">    	rect_left_x += rect_vx;</span><br><span class="line">    	if (rect_left_x &lt;= 0) &#123;//如果方块跑到最左边</span><br><span class="line">    		rect_left_x = width;//在最右边重新出现</span><br><span class="line">    		rect_height = rand() % int(height / 4) + height / 4;//设置方块随机高度</span><br><span class="line">    		rect_vx = rand() / float(RAND_MAX) * 4 - 7;//设置方块随机速度</span><br><span class="line">    		score++;//得分加一</span><br><span class="line">    	&#125;</span><br><span class="line">    	//如果小球碰到方块</span><br><span class="line">    	if ((rect_left_x &lt;= ball_x + radius)</span><br><span class="line">    		&amp;&amp; (rect_left_x + rect_width &gt;= ball_x - radius)</span><br><span class="line">    		&amp;&amp; (height - rect_height &lt;= ball_y + radius)) &#123;</span><br><span class="line">    		Sleep(100);//慢动作效果</span><br><span class="line">    		score = 0;//得分清零</span><br><span class="line">    	&#125;</span><br><span class="line">    	cleardevice();//清屏函数，在绘制新小球前清除画面上的内容</span><br><span class="line">    	fillcircle(ball_x, ball_y, radius);//画圆</span><br><span class="line">    	fillrectangle(rect_left_x, height - rect_height, rect_left_x + rect_width, height);//画方块</span><br><span class="line">    	TCHAR s[20];//定义字符串数组</span><br><span class="line">    	_stprintf_s(s, _T(&quot;%d&quot;), score);//将score转化为字符串</span><br><span class="line">    	settextstyle(40, 0, _T(&quot;宋体&quot;));//设置文字大小、字体</span><br><span class="line">    	outtextxy(50, 30, s);//输出得分文字</span><br><span class="line">    	Sleep(10);//表示程序暂停10毫秒</span><br><span class="line">    &#125;</span><br><span class="line">    closegraph();   //关闭绘图窗口</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>C++_EasyX 项目</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构课设报告——用顺序表实现图书信息管理系统</title>
    <url>/2024/03/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E8%AE%BE%E6%8A%A5%E5%91%8A%E2%80%94%E2%80%94%E7%94%A8%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%AE%9E%E7%8E%B0%E5%9B%BE%E4%B9%A6%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90">【案例分析】</a></li>
<li><a href="#%E5%AE%9E%E9%AA%8C%E8%BF%87%E7%A8%8B">【实验过程】</a><ul>
<li><a href="#1%E9%A2%84%E5%85%88%E5%AE%9A%E4%B9%89">1.预先定义</a></li>
<li><a href="#2%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96">2.顺序表的初始化</a></li>
<li><a href="#3%E5%BD%95%E5%85%A5%E5%9B%BE%E4%B9%A6%E4%BF%A1%E6%81%AF">3.录入图书信息</a></li>
<li><a href="#4%E6%9F%A5%E6%89%BE%E5%9B%BE%E4%B9%A6%E4%BF%A1%E6%81%AF">4.查找图书信息</a></li>
</ul>
</li>
<li><a href="#5%E6%B7%BB%E5%8A%A0%E4%B9%A6%E7%B1%8D%E4%BF%A1%E6%81%AF">5.添加书籍信息</a></li>
<li><a href="#6%E5%88%A0%E9%99%A4%E4%B9%A6%E7%B1%8D">6.删除书籍</a></li>
<li><a href="#7%E4%BF%AE%E6%94%B9%E4%B9%A6%E7%B1%8D%E4%BF%A1%E6%81%AF">7.修改书籍信息</a></li>
<li><a href="#8%E6%8E%92%E5%BA%8F">8.排序</a></li>
</ul>
<ul>
<li><a href="#%E4%BB%A3%E7%A0%81">【代码】</a></li>
</ul>
<!-- tocstop -->

<p>[TOC]</p>
<h2><span id="案例分析">【案例分析】</span></h2><p>将图书馆信息管理系统抽象成</p>
<p>线性表，每本书作为线性表的一个元素，其中包括以下功能：</p>
<p>1.查找。通过输入关键词，返回该书的所有信息。</p>
<p>2.插入。添加新的书籍。</p>
<p>3.删除。删除书籍。</p>
<p>4.修改。调用查找功能，找到对应书籍并修改。</p>
<p>5.排序。</p>
<p>6.计数。</p>
<h2><span id="实验过程">【实验过程】</span></h2><h3><span id="1预先定义">1.预先定义</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`#include&lt;new&gt;`</span><br><span class="line">`#include&lt;fstream&gt; //对文件输入输出` </span><br><span class="line">`#include&lt;iostream&gt;  //对屏幕上输入输出`</span><br><span class="line">`using namespace std;`</span><br><span class="line">`#define maxsize 1000`</span><br><span class="line">`typedef struct&#123;`</span><br><span class="line">	`char no[20];  //图书编号` </span><br><span class="line">	`char name[50];  //书名` </span><br><span class="line">	`float price;  //定价` </span><br><span class="line">`&#125;book;`</span><br><span class="line">`typedef struct&#123;`</span><br><span class="line">	`book *elem;   //存储空间的基地址`</span><br><span class="line">	`int len;     //表长`</span><br><span class="line">`&#125;SqList;  //图书表的顺序存储结构为SqList` </span><br></pre></td></tr></table></figure>

<p>之后，在main函数中设置 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`SqList L;` </span><br></pre></td></tr></table></figure>



<h3><span id="2顺序表的初始化">2.顺序表的初始化</span></h3><p>为顺序表分配一个预定义大小的数组空间，并把表长设定为0。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`int initlist(SqList &amp;L)`</span><br><span class="line">`//构造空表` </span><br><span class="line">`&#123;`</span><br><span class="line">	`L.elem = new book[maxsize];`</span><br><span class="line">	`if(!L.elem)  exit(0);  //存储分配失败，不知为何，在这个地方用return -1会导致后续程序出错`</span><br><span class="line">	`L.len=0;`</span><br><span class="line">	`return 1;` </span><br><span class="line">`&#125;`</span><br></pre></td></tr></table></figure>

<p>new int的作用是分配内存，找到一个连续的内存块，然后返回一个指向该内存的指针。</p>
<p>如：<code>int* a = new int;</code></p>
<p>这样，我们为a分配了一个4字节的内存。</p>
<p>如果想分配一个数组，就在数组名后面加[]，里面输入数字。</p>
<h3><span id="3录入图书信息">3.录入图书信息</span></h3><p>在开启图书馆管理功能前，有必要先录入书籍信息，在这里，我用文件读取数组信息的方法实现批量录入。</p>
<p><em>001 NineteenEightyFour 25.00</em><br><em>002 HarryPotter 400.00</em><br><em>003 GonewiththeWind 40.00</em><br><em>004 AnimalFarm 10.00</em><br><em>005 LePetitPrince 22.00</em><br><em>006 ToKillaMockingBird 32.00</em><br><em>007 Siddhartha 32.00</em><br><em>008 DifferentSeasons 29.90</em><br><em>009 FlowersforAlgernon 36.00</em><br><em>010 RiverTown 36.00</em></p>
<p>关于文件读写的笔记，我写在另一篇文章。</p>
<h3><span id="4查找图书信息">4.查找图书信息</span></h3><p>由于图书一共录入三种信息，所以我们可以分别用三种信息（编号，名字，价格）进行查找。编号和名字是char[]字符数组，借助函数**strcmp(新字符，待比较旧字符)**，如果函数值为0，说明两个字符相同，完成查找；这时我们借助一个初始值为0的计数器joke，如果查找成功，joke++，如果遍历结束还是找不到，joke值则始终为0。</p>
<p>如果不要求键入信息十分精准，通过关键字即可返回，则可以使用函数<strong>strstr（母字符串，子字符串）</strong>，注意定义指针。它的写法是：</p>
<p><code>#include&lt;cstring&gt;//头文件</code></p>
<p><code>char new[20];</code></p>
<p><code>char old[20];</code></p>
<p><code>char* a=strstr(old,new);</code></p>
<p><code>if(a==NULL)  cout&lt;&lt;&quot;not found&quot;&lt;&lt;endl; //此时说明两个字符完全不相同</code></p>
<p><u>注意：strstr函数区分大小写。</u></p>
<h4><span id="1根据图书编号查找">（1）根据图书编号查找</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`void Findno(SqList L)`</span><br><span class="line">`//查找书号` </span><br><span class="line">`&#123;`</span><br><span class="line">	`char findno[20];`</span><br><span class="line">	`cin&gt;&gt;findno;`</span><br><span class="line">	`int joke=0;`</span><br><span class="line">	`cout&lt;&lt;&quot;图书编号&quot;&lt;&lt;setw(20)&lt;&lt;&quot;书名&quot;&lt;&lt;setw(30)&lt;&lt;&quot;价格&quot;&lt;&lt;endl;`</span><br><span class="line">	`for(int i=0;i&lt;L.len;i++)&#123;`</span><br><span class="line">		`if(strcmp(findno,L.elem[i].no)==0)&#123;`</span><br><span class="line">			`joke++;`</span><br><span class="line">			`cout&lt;&lt;fixed&lt;&lt;setprecision(2);`</span><br><span class="line">			`cout&lt;&lt;L.elem[i].no&lt;&lt;setw(30)&lt;&lt;L.elem[i].name&lt;&lt;setw(30)&lt;&lt;L.elem[i].price&lt;&lt;endl;`</span><br><span class="line">		`&#125;`</span><br><span class="line">	`&#125;`</span><br><span class="line">	`if(joke==0) cout&lt;&lt;&quot;404 NOT FOUND&quot;&lt;&lt;endl;`</span><br><span class="line">`&#125;`</span><br></pre></td></tr></table></figure>



<h4><span id="2根据书名查找">（2）根据书名查找</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`void Findname(SqList L)`</span><br><span class="line">`//查找书名`</span><br><span class="line">`&#123;`</span><br><span class="line">	`char findname[50];`</span><br><span class="line">	`cin&gt;&gt;findname;`</span><br><span class="line">	`int joke=0;`</span><br><span class="line">	`cout&lt;&lt;&quot;图书编号&quot;&lt;&lt;setw(20)&lt;&lt;&quot;书名&quot;&lt;&lt;setw(30)&lt;&lt;&quot;价格&quot;&lt;&lt;endl;`</span><br><span class="line">	`for(int i=0;i&lt;L.len;i++)&#123;`</span><br><span class="line">	`char *b=strstr(L.elem[i].name,findname);`</span><br><span class="line">		`if(b!=NULL)&#123;`</span><br><span class="line">			`joke++;`</span><br><span class="line">			`cout&lt;&lt;L.elem[i].no&lt;&lt;setw(30)&lt;&lt;L.elem[i].name&lt;&lt;setw(30)&lt;&lt;L.elem[i].price&lt;&lt;endl;`</span><br><span class="line">		`&#125;`</span><br><span class="line">	`&#125;`</span><br><span class="line">	`if(joke==0) cout&lt;&lt;&quot;404 NOT FOUND&quot;&lt;&lt;endl;`</span><br><span class="line">	 ``</span><br><span class="line">`&#125;`</span><br></pre></td></tr></table></figure>



<h4><span id="3根据价格查找">（3）根据价格查找</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`void Findprice(SqList L)`</span><br><span class="line">`//查找价格` </span><br><span class="line">`&#123;`</span><br><span class="line">	`float findprice;`</span><br><span class="line">	`cin&gt;&gt;findprice;`</span><br><span class="line">	`int joke=0;`</span><br><span class="line">	`cout&lt;&lt;&quot;图书编号&quot;&lt;&lt;setw(20)&lt;&lt;&quot;书名&quot;&lt;&lt;setw(30)&lt;&lt;&quot;价格&quot;&lt;&lt;endl;`</span><br><span class="line">	`for(int i=0;i&lt;L.len;i++)&#123;`</span><br><span class="line">		`if(findprice==L.elem[i].price)&#123;`</span><br><span class="line">			`joke++;`</span><br><span class="line">			`cout&lt;&lt;L.elem[i].no&lt;&lt;setw(30)&lt;&lt;L.elem[i].name&lt;&lt;setw(30)&lt;&lt;L.elem[i].price&lt;&lt;endl;`</span><br><span class="line">		`&#125;`</span><br><span class="line">	`&#125;`</span><br><span class="line">	`if(joke==0) cout&lt;&lt;&quot;404 NOT FOUND&quot;&lt;&lt;endl;`</span><br><span class="line">	 ``</span><br><span class="line">`&#125;`</span><br></pre></td></tr></table></figure>



<h2><span id="5添加书籍信息">5.添加书籍信息</span></h2><p>这个功能很简单，先准备好待插入的顺序表位置newnumber，对于newnumber之后的元素，统一后移一个单位，<u>表长加一</u>。记得<u>检查表是否溢出（表长&#x3D;&#x3D;maxsize），和newnumber的合法范围</u>（还记得数组从0开始，而顺序表是从1开始吗？所以，newnumber最小可以是1；另外，插入顺序表允许末尾追加，所以newnumber最大可以是表长+1。实际范围是**<u>[1,表长+1]</u>**。)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">``int listinsert(SqList &amp;L,int newnumber)`</span><br><span class="line">`//添加新图书`</span><br><span class="line">`&#123;`</span><br><span class="line">	`if( (newnumber&gt;L.len+1) || (newnumber&lt;1) ) exit(0);`</span><br><span class="line">	`if(L.len==maxsize) exit(0);`</span><br><span class="line">	`for(int i=L.len-1;i&gt;=newnumber-1;i--)&#123;`</span><br><span class="line">		`L.elem[i+1]=L.elem[i]; //插入位置以后的元素后移一个单位`</span><br><span class="line">	`&#125;L.elem[newnumber-1]=L.elem[maxsize-1];`</span><br><span class="line">	`L.len++;`</span><br><span class="line">	`return 1;`</span><br><span class="line"> &#125;` </span><br><span class="line"></span><br><span class="line">这里，</span><br></pre></td></tr></table></figure>

<p>我把要添加进去的数组信息放在了顺序表的最后一个位置maxsize，等插入位置以后的元素完成后移后，再将这组信息填进待插入的位置。</p>
<p>为了能直观地查看添加后的效果，设置一个输出函数，后续可以重复利用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">``void readlist(SqList L)&#123;`</span><br><span class="line">	`cout&lt;&lt;&quot;图书编号&quot;&lt;&lt;setw(20)&lt;&lt;&quot;书名&quot;&lt;&lt;setw(30)&lt;&lt;&quot;价格&quot;&lt;&lt;endl;`</span><br><span class="line">	`for(int i=0;i&lt;L.len;i++)&#123;`</span><br><span class="line">		`cout&lt;&lt;fixed&lt;&lt;setprecision(2);`</span><br><span class="line">		`cout&lt;&lt;L.elem[i].no&lt;&lt;setw(30)&lt;&lt;L.elem[i].name&lt;&lt;setw(30)&lt;&lt;L.elem[i].price&lt;&lt;endl;`</span><br><span class="line"> `&#125;`</span><br><span class="line">&#125;`</span><br></pre></td></tr></table></figure>



<h2><span id="6删除书籍">6.删除书籍</span></h2><p>这个功能需要借助查找功能。首先，我们查找一本书，定位到它在顺序表中的位置后（自然，我们知道了<u>这个位置的合法范围是**[1,表长]**</u>），使<u>该位置之后的元素统一往前移动一个单位，该书自然就被覆盖掉了。记得<u>表长减一</u>。</u></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`void listdelete(SqList &amp;L)`</span><br><span class="line">`//删除一本书`</span><br><span class="line">`&#123;`</span><br><span class="line">   `int deletedata;`</span><br><span class="line">	`char findnoname[50];`</span><br><span class="line">`cin&gt;&gt;findnoname;`</span><br><span class="line">`int joke=0;`</span><br><span class="line">`char* a;`</span><br><span class="line">`cout&lt;&lt;&quot;图书编号&quot;&lt;&lt;setw(20)&lt;&lt;&quot;书名&quot;&lt;&lt;setw(30)&lt;&lt;&quot;价格&quot;&lt;&lt;endl;`</span><br><span class="line">`for(int i=0;i&lt;L.len;i++)&#123;`</span><br><span class="line">	`a=strstr(L.elem[i].name,findnoname);`</span><br><span class="line">	`if(strcmp(findnoname,L.elem[i].no)==0)&#123;`</span><br><span class="line">		`joke++;`</span><br><span class="line">		`cout&lt;&lt;L.elem[i].no&lt;&lt;setw(30)&lt;&lt;L.elem[i].name&lt;&lt;setw(30)&lt;&lt;L.elem[i].price&lt;&lt;endl;`</span><br><span class="line">		`deletedata=i+1;`</span><br><span class="line">	`&#125;`</span><br><span class="line">	`if(a!=NULL)&#123;`</span><br><span class="line">		`joke++;`</span><br><span class="line">		`cout&lt;&lt;L.elem[i].no&lt;&lt;setw(30)&lt;&lt;L.elem[i].name&lt;&lt;setw(30)&lt;&lt;L.elem[i].price&lt;&lt;endl;`</span><br><span class="line">		`deletedata=i+1;`</span><br><span class="line">	`&#125;`</span><br><span class="line">`&#125;`</span><br><span class="line">`if(joke==0) cout&lt;&lt;&quot;404 NOT FOUND&quot;&lt;&lt;endl;`</span><br><span class="line">	``if((deletedata&lt;1) || (deletedata&gt;L.len)) exit(0);`</span><br><span class="line">	`for(int i=deletedata;i&lt;L.len;i++)&#123;`</span><br><span class="line">		`L.elem[i-1]=L.elem[i]; //对i所在的位置删除数据后，进行前移，前一个元素等于后一个元素` </span><br><span class="line"> `&#125;L.len--;`</span><br><span class="line">&#125;`</span><br></pre></td></tr></table></figure>

<h2><span id="7修改书籍信息">7.修改书籍信息</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int doinglist(SqList &amp;L)</span><br><span class="line">//修改顺序表信息 </span><br><span class="line">&#123;</span><br><span class="line">	cout&lt;&lt;&quot;请输入书籍编号&quot;&lt;&lt;endl;</span><br><span class="line">char findno[20];</span><br><span class="line">cin&gt;&gt;findno;</span><br><span class="line">int joke=0;</span><br><span class="line">int doing;</span><br><span class="line">for(int i=0;i&lt;L.len;i++)&#123;</span><br><span class="line">	if(strcmp(findno,L.elem[i].no)==0)&#123;</span><br><span class="line">		joke++;</span><br><span class="line">		cout&lt;&lt;&quot;获取书籍信息成功！&quot;&lt;&lt;endl;</span><br><span class="line">		cout&lt;&lt;&quot;图书编号&quot;&lt;&lt;setw(20)&lt;&lt;&quot;书名&quot;&lt;&lt;setw(30)&lt;&lt;&quot;价格&quot;&lt;&lt;endl;</span><br><span class="line">		cout&lt;&lt;fixed&lt;&lt;setprecision(2);</span><br><span class="line">		cout&lt;&lt;L.elem[i].no&lt;&lt;setw(30)&lt;&lt;L.elem[i].name&lt;&lt;setw(30)&lt;&lt;L.elem[i].price&lt;&lt;endl;</span><br><span class="line">		while(1)&#123;</span><br><span class="line">			cout&lt;&lt;&quot;请输入（0-3）：1.修改书籍编号 2.修改书名 3.修改书的价格 0.退出修改&quot;&lt;&lt;endl;</span><br><span class="line">			cin&gt;&gt;doing;</span><br><span class="line">			switch(doing)&#123;</span><br><span class="line">				case 1:&#123;</span><br><span class="line">					cout&lt;&lt;&quot;请输入新书籍编号：&quot;&lt;&lt;endl;</span><br><span class="line">					char newno[20];</span><br><span class="line">					cin&gt;&gt;newno;</span><br><span class="line">					strcpy(L.elem[i].no,newno); </span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">				case 2:&#123;</span><br><span class="line">					cout&lt;&lt;&quot;请输入新书名：&quot;&lt;&lt;endl;</span><br><span class="line">					char newname[50];</span><br><span class="line">					cin&gt;&gt;newname;</span><br><span class="line">					strcpy(L.elem[i].name,newname); </span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">				case 3:&#123;</span><br><span class="line">					cout&lt;&lt;&quot;请输入新价格：&quot;&lt;&lt;endl;</span><br><span class="line">					float newprice;</span><br><span class="line">					cin&gt;&gt;newprice;</span><br><span class="line">					L.elem[i].price=newprice;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">				case 0:&#123;</span><br><span class="line">				system(&quot;pause&quot;);</span><br><span class="line">			    system(&quot;cls&quot;);//实现清屏</span><br><span class="line">			    return 0;</span><br><span class="line">				&#125;break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="8排序">8.排序</span></h2><p>依照价格高低，对书籍进行排序。采用选择排序法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void talllist(SqList &amp;L)</span><br><span class="line"> //选择排序法 </span><br><span class="line"> &#123;</span><br><span class="line"> 	int max;  </span><br><span class="line">    for(int i=0;i&lt;L.len-1;i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        max=i;  </span><br><span class="line">        for(int j=i;j&lt;L.len;j++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            if(L.elem[max].price &gt; L.elem[j].price)  //本质是索引为i和i+1 的结构体成员在做比较，这种写法可以保证不漏掉每一组比较 </span><br><span class="line">                max=j;  </span><br><span class="line">        &#125;  </span><br><span class="line">        L.elem[L.len+1] = L.elem[i];  //用一个在顺序表外面的位置储存旧值，暂时没想到其他好的办法 </span><br><span class="line">        L.elem[i] = L.elem[max];  </span><br><span class="line">        L.elem[max] = L.elem[L.len+1] ;</span><br><span class="line">	 &#125;</span><br></pre></td></tr></table></figure>

<p>9.这个很简单，统计数目只需要输出表长就可以了</p>
<p>我用文件读取的时候多读了一行0，所以实操的时候用了表长-1</p>
<h1><span id="代码">【代码】</span></h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;new&gt;</span><br><span class="line">#include&lt;fstream&gt; //对文件输入输出 </span><br><span class="line">#include&lt;iostream&gt;  //对屏幕上输入输出</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define maxsize 1000</span><br><span class="line">typedef struct&#123;</span><br><span class="line">	char no[20];  //图书编号 </span><br><span class="line">	char name[50];  //书名 </span><br><span class="line">	float price;  //定价 </span><br><span class="line">&#125;book;</span><br><span class="line">typedef struct&#123;</span><br><span class="line">	book *elem;   //存储空间的基地址</span><br><span class="line">	int len;     //表长</span><br><span class="line">&#125;SqList;  //图书表的顺序存储结构为SqList </span><br><span class="line"></span><br><span class="line">int initlist(SqList &amp;L)</span><br><span class="line">//构造空表 </span><br><span class="line">&#123;</span><br><span class="line">	L.elem = new book[maxsize];</span><br><span class="line">	if(!L.elem)  exit(0);  //存储分配失败，不知为何，在这个地方用return -1会导致后续程序出错</span><br><span class="line">	L.len=0;</span><br><span class="line">	return 1; </span><br><span class="line">&#125; </span><br><span class="line">void menu()&#123;</span><br><span class="line">//菜单 </span><br><span class="line">	cout&lt;&lt;&quot;————&quot;&lt;&lt;&#x27;\n&#x27;&lt;&lt;&quot;menu&quot;&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;&quot;1.查找某本书&quot;&lt;&lt;&#x27;\n&#x27;&lt;&lt;&quot;2.添加新书&quot;&lt;&lt;&#x27;\n&#x27;&lt;&lt;&quot;3.删除某本书&quot;&lt;&lt;&#x27;\n&#x27;&lt;&lt;&quot;4.修改某本书的信息&quot;&lt;&lt;&#x27;\n&#x27;&lt;&lt; &quot;5.排序&quot;&lt;&lt;&#x27;\n&#x27;&lt;&lt;&quot;6.统计&quot;&lt;&lt;&#x27;\n&#x27;; </span><br><span class="line">	cout&lt;&lt;&quot;————&quot;&lt;&lt;endl; </span><br><span class="line">&#125;</span><br><span class="line">void Findno(SqList L)</span><br><span class="line">//查找书号 </span><br><span class="line">&#123;</span><br><span class="line">	char findno[20];</span><br><span class="line">	cin&gt;&gt;findno;</span><br><span class="line">	int joke=0;</span><br><span class="line">	cout&lt;&lt;&quot;图书编号&quot;&lt;&lt;setw(20)&lt;&lt;&quot;书名&quot;&lt;&lt;setw(30)&lt;&lt;&quot;价格&quot;&lt;&lt;endl;</span><br><span class="line">	for(int i=0;i&lt;L.len;i++)&#123;</span><br><span class="line">		if(strcmp(findno,L.elem[i].no)==0)&#123;</span><br><span class="line">			joke++;</span><br><span class="line">			cout&lt;&lt;L.elem[i].no&lt;&lt;setw(30)&lt;&lt;L.elem[i].name&lt;&lt;setw(30)&lt;&lt;L.elem[i].price&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if(joke==0) cout&lt;&lt;&quot;404 NOT FOUND&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">void Findname(SqList L)</span><br><span class="line">//查找书名</span><br><span class="line">&#123;</span><br><span class="line">	char findname[50];</span><br><span class="line">	cin&gt;&gt;findname;</span><br><span class="line">	int joke=0;</span><br><span class="line">	cout&lt;&lt;&quot;图书编号&quot;&lt;&lt;setw(20)&lt;&lt;&quot;书名&quot;&lt;&lt;setw(30)&lt;&lt;&quot;价格&quot;&lt;&lt;endl;</span><br><span class="line">	for(int i=0;i&lt;L.len;i++)&#123;</span><br><span class="line">	char *b=strstr(L.elem[i].name,findname);</span><br><span class="line">		if(b!=NULL)&#123;</span><br><span class="line">			joke++;</span><br><span class="line">			cout&lt;&lt;L.elem[i].no&lt;&lt;setw(30)&lt;&lt;L.elem[i].name&lt;&lt;setw(30)&lt;&lt;L.elem[i].price&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if(joke==0) cout&lt;&lt;&quot;404 NOT FOUND&quot;&lt;&lt;endl;</span><br><span class="line">	 </span><br><span class="line">&#125;</span><br><span class="line">void Findprice(SqList L)</span><br><span class="line">//查找价格 </span><br><span class="line">&#123;</span><br><span class="line">	float findprice;</span><br><span class="line">	cin&gt;&gt;findprice;</span><br><span class="line">	int joke=0;</span><br><span class="line">	cout&lt;&lt;&quot;图书编号&quot;&lt;&lt;setw(20)&lt;&lt;&quot;书名&quot;&lt;&lt;setw(30)&lt;&lt;&quot;价格&quot;&lt;&lt;endl;</span><br><span class="line">	for(int i=0;i&lt;L.len;i++)&#123;</span><br><span class="line">		if(findprice==L.elem[i].price)&#123;</span><br><span class="line">			joke++;</span><br><span class="line">			cout&lt;&lt;fixed&lt;&lt;setprecision(2);</span><br><span class="line">			cout&lt;&lt;L.elem[i].no&lt;&lt;setw(30)&lt;&lt;L.elem[i].name&lt;&lt;setw(30)&lt;&lt;L.elem[i].price&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if(joke==0) cout&lt;&lt;&quot;404 NOT FOUND&quot;&lt;&lt;endl;</span><br><span class="line">	 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int listinsert(SqList &amp;L,int newnumber)</span><br><span class="line">//添加新图书</span><br><span class="line">&#123;</span><br><span class="line">	if( (newnumber&gt;L.len+1) || (newnumber&lt;1) ) exit(0);</span><br><span class="line">	if(L.len==maxsize) exit(0);</span><br><span class="line">	for(int i=L.len-1;i&gt;=newnumber-1;i--)&#123;</span><br><span class="line">		L.elem[i+1]=L.elem[i]; //插入位置以后的元素后移一个单位</span><br><span class="line">	&#125;L.elem[newnumber-1]=L.elem[maxsize-1];</span><br><span class="line">	L.len++;</span><br><span class="line">	return 1;</span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> void listdelete(SqList &amp;L)</span><br><span class="line"> //删除一本书</span><br><span class="line"> &#123;</span><br><span class="line">    int deletedata;</span><br><span class="line"> 	char findnoname[50];</span><br><span class="line">	cin&gt;&gt;findnoname;</span><br><span class="line">	int joke=0;</span><br><span class="line">	char* a;</span><br><span class="line">	cout&lt;&lt;&quot;图书编号&quot;&lt;&lt;setw(20)&lt;&lt;&quot;书名&quot;&lt;&lt;setw(30)&lt;&lt;&quot;价格&quot;&lt;&lt;endl;</span><br><span class="line">	for(int i=0;i&lt;L.len;i++)&#123;</span><br><span class="line">		a=strstr(L.elem[i].name,findnoname);</span><br><span class="line">		if(strcmp(findnoname,L.elem[i].no)==0)&#123;</span><br><span class="line">			joke++;</span><br><span class="line">			cout&lt;&lt;L.elem[i].no&lt;&lt;setw(30)&lt;&lt;L.elem[i].name&lt;&lt;setw(30)&lt;&lt;L.elem[i].price&lt;&lt;endl;</span><br><span class="line">			deletedata=i+1;</span><br><span class="line">		&#125;</span><br><span class="line">		if(a!=NULL)&#123;</span><br><span class="line">			joke++;</span><br><span class="line">			cout&lt;&lt;L.elem[i].no&lt;&lt;setw(30)&lt;&lt;L.elem[i].name&lt;&lt;setw(30)&lt;&lt;L.elem[i].price&lt;&lt;endl;</span><br><span class="line">			deletedata=i+1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if(joke==0) cout&lt;&lt;&quot;404 NOT FOUND&quot;&lt;&lt;endl;</span><br><span class="line"> 	</span><br><span class="line"></span><br><span class="line"> 	if((deletedata&lt;1) || (deletedata&gt;L.len)) exit(0);</span><br><span class="line"> 	for(int i=deletedata;i&lt;L.len;i++)&#123;</span><br><span class="line"> 		L.elem[i-1]=L.elem[i]; //对i所在的位置删除数据后，进行前移，前一个元素等于后一个元素 </span><br><span class="line"> 	 &#125;L.len--;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> int doinglist(SqList &amp;L)</span><br><span class="line"> //修改顺序表信息 </span><br><span class="line"> &#123;</span><br><span class="line"> 	cout&lt;&lt;&quot;请输入书籍编号&quot;&lt;&lt;endl;</span><br><span class="line">	char findno[20];</span><br><span class="line">	cin&gt;&gt;findno;</span><br><span class="line">	int joke=0;</span><br><span class="line">	int doing;</span><br><span class="line">	for(int i=0;i&lt;L.len;i++)&#123;</span><br><span class="line">		if(strcmp(findno,L.elem[i].no)==0)&#123;</span><br><span class="line">			joke++;</span><br><span class="line">			cout&lt;&lt;&quot;获取书籍信息成功！&quot;&lt;&lt;endl;</span><br><span class="line">			cout&lt;&lt;&quot;图书编号&quot;&lt;&lt;setw(20)&lt;&lt;&quot;书名&quot;&lt;&lt;setw(30)&lt;&lt;&quot;价格&quot;&lt;&lt;endl;</span><br><span class="line">			cout&lt;&lt;fixed&lt;&lt;setprecision(2);</span><br><span class="line">			cout&lt;&lt;L.elem[i].no&lt;&lt;setw(30)&lt;&lt;L.elem[i].name&lt;&lt;setw(30)&lt;&lt;L.elem[i].price&lt;&lt;endl;</span><br><span class="line">			while(1)&#123;</span><br><span class="line">				cout&lt;&lt;&quot;请输入（0-3）：1.修改书籍编号 2.修改书名 3.修改书的价格 0.退出修改&quot;&lt;&lt;endl;</span><br><span class="line">				cin&gt;&gt;doing;</span><br><span class="line">				switch(doing)&#123;</span><br><span class="line">					case 1:&#123;</span><br><span class="line">						cout&lt;&lt;&quot;请输入新书籍编号：&quot;&lt;&lt;endl;</span><br><span class="line">						char newno[20];</span><br><span class="line">						cin&gt;&gt;newno;</span><br><span class="line">						strcpy(L.elem[i].no,newno); </span><br><span class="line">						break;</span><br><span class="line">					&#125;</span><br><span class="line">					case 2:&#123;</span><br><span class="line">						cout&lt;&lt;&quot;请输入新书名：&quot;&lt;&lt;endl;</span><br><span class="line">						char newname[50];</span><br><span class="line">						cin&gt;&gt;newname;</span><br><span class="line">						strcpy(L.elem[i].name,newname); </span><br><span class="line">						break;</span><br><span class="line">					&#125;</span><br><span class="line">					case 3:&#123;</span><br><span class="line">						cout&lt;&lt;&quot;请输入新价格：&quot;&lt;&lt;endl;</span><br><span class="line">						float newprice;</span><br><span class="line">						cin&gt;&gt;newprice;</span><br><span class="line">						L.elem[i].price=newprice;</span><br><span class="line">						break;</span><br><span class="line">					&#125;</span><br><span class="line">					case 0:&#123;</span><br><span class="line">					system(&quot;pause&quot;);</span><br><span class="line">				    system(&quot;cls&quot;);</span><br><span class="line">				    return 0;</span><br><span class="line">					&#125;break;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> &#125;</span><br><span class="line"> void talllist(SqList &amp;L)</span><br><span class="line"> //选择排序法 </span><br><span class="line"> &#123;</span><br><span class="line"> 	int max;  </span><br><span class="line">    for(int i=0;i&lt;L.len-1;i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        max=i;  </span><br><span class="line">        for(int j=i;j&lt;L.len;j++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            if(L.elem[max].price &gt; L.elem[j].price)  //本质是索引为i和i+1 的结构体成员在做比较，这种写法可以保证不漏掉每一组比较 </span><br><span class="line">                max=j;  </span><br><span class="line">        &#125;  </span><br><span class="line">        L.elem[L.len+1] = L.elem[i];  //用一个在顺序表外面的位置储存旧值，暂时没想到其他好的办法 </span><br><span class="line">        L.elem[i] = L.elem[max];  </span><br><span class="line">        L.elem[max] = L.elem[L.len+1] ;</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br><span class="line"> void readlist(SqList L)&#123;</span><br><span class="line"> 	cout&lt;&lt;&quot;图书编号&quot;&lt;&lt;setw(20)&lt;&lt;&quot;书名&quot;&lt;&lt;setw(30)&lt;&lt;&quot;价格&quot;&lt;&lt;endl;</span><br><span class="line"> 	for(int i=0;i&lt;L.len;i++)&#123;</span><br><span class="line"> 		cout&lt;&lt;fixed&lt;&lt;setprecision(2);</span><br><span class="line"> 		cout&lt;&lt;L.elem[i].no&lt;&lt;setw(30)&lt;&lt;L.elem[i].name&lt;&lt;setw(30)&lt;&lt;L.elem[i].price&lt;&lt;endl;</span><br><span class="line">	 &#125;</span><br><span class="line"> &#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	SqList L;</span><br><span class="line">	initlist(L); //顺序表的初始化 </span><br><span class="line">	FILE *fp=NULL;</span><br><span class="line">	FILE *fp1=NULL;</span><br><span class="line">	fp=fopen(&quot;information.txt&quot;,&quot;r&quot;);//r打开只读文件 </span><br><span class="line">	if(fp==NULL)&#123;</span><br><span class="line">	cout&lt;&lt;&quot;文件读取无效&quot;&lt;&lt;endl;</span><br><span class="line">	exit(0); </span><br><span class="line">	&#125;</span><br><span class="line">	int i=0;</span><br><span class="line">	while(!feof(fp))&#123;</span><br><span class="line">        fscanf(fp, &quot;%s %s %f\n&quot;, L.elem[i].no,L.elem[i].name,&amp;L.elem[i].price);//字符变量不需要加&amp;指向地址，%s忽略字符串前一个空格 </span><br><span class="line">		i++;</span><br><span class="line">	&#125; </span><br><span class="line">	L.len=i+1; </span><br><span class="line">	fclose(fp);//关闭文件 </span><br></pre></td></tr></table></figure>

<p>​	</p>
<pre><code>while(1)&#123;
    menu(); 
    int choose;
    int find;
    string yes;
    cin&gt;&gt;choose; 
    switch(choose)&#123;
        case 1:&#123;
            cout&lt;&lt;&quot;请选择（0-3）：1.按图书编号查找 2.按书名查找 3.按价格查找 0.退出&quot;&lt;&lt;endl;
            cin&gt;&gt;find;
            if(find==1) Findno(L);
            if(find==2) Findname(L);
            if(find==3) Findprice(L);
            break;
        &#125;
        case 2:&#123;
            int newnumber;
            cout&lt;&lt;&quot;请输入：添加新图书至第__位(按0退出)&quot;&lt;&lt;endl;
            cin&gt;&gt;newnumber;
            if(newnumber!=0)&#123;
                cin&gt;&gt;L.elem[maxsize-1].no&gt;&gt;L.elem[maxsize-1].name&gt;&gt;L.elem[maxsize-1].price;
                listinsert(L,newnumber);
                cout&lt;&lt;&quot;添加成功！是否查看？Y/N&quot;&lt;&lt;endl;
                cin&gt;&gt;yes;
                if(yes==&quot;Y&quot;) readlist(L);
                if(yes==&quot;N&quot;) break;
            &#125;
            break;
        &#125;
        case 3:&#123;
            cout&lt;&lt;&quot;请选择（0-2）：1.输入图书编号并删除该书 2.输入书名并删除该书 0.退出&quot;&lt;&lt;endl;
            cin&gt;&gt;find;
            if(find==1) &#123;
            cout&lt;&lt;&quot;正在查询你想删除的书...&quot;&lt;&lt;endl; 
            listdelete(L); 
            cout&lt;&lt;&quot;删除完成！请查看：&quot;&lt;&lt;endl; 
            readlist(L);
            &#125;
            if(find==2)&#123;
            cout&lt;&lt;&quot;查找到你想删除的书是：&quot;&lt;&lt;endl; 	
            listdelete(L);
            cout&lt;&lt;&quot;删除完成！请查看：&quot;&lt;&lt;endl; 
            readlist(L);
         	&#125;
            break;
        &#125;
        case 4:&#123;
            cout&lt;&lt;&quot;请选择（0-1）：1.输入图书编号并修改该书信息  0.退出&quot;&lt;&lt;endl;
            cin&gt;&gt;find;
            if(find==1) doinglist(L);
            break;
        &#125;
        case 5:&#123;
            cout&lt;&lt;&quot;请选择（0-1）：1.按价格升序排序  0.退出&quot;&lt;&lt;endl;
            cin&gt;&gt;find;
            if(find==1)&#123;
                talllist(L);
                readlist(L);
            &#125;
            break;
        &#125;
        case 6:&#123;
            cout&lt;&lt;&quot;本系统目前共收录&quot;&lt;&lt;L.len-1&lt;&lt;&quot;本书&quot;&lt;&lt;endl; 
            float sum=0;
            for(int i=0;i&lt;L.len;i++)&#123;
                sum+=L.elem[i].price;
            &#125;
            cout&lt;&lt;fixed&lt;&lt;setprecision(2);
            cout&lt;&lt;&quot;价值约&quot;&lt;&lt; sum&lt;&lt;&quot;元&quot;&lt;&lt;endl; 
            break;
        &#125;
    &#125;
fp1=fopen(&quot;information2.txt&quot;,&quot;w+&quot;);//w+打开可读写文件，若不存在则建立，若存在则清空并覆盖 
if(fp==NULL)&#123;
cout&lt;&lt;&quot;文件写入无效&quot;&lt;&lt;endl;
exit(0); 
&#125;
for(i=0;i&lt;L.len;i++)&#123;
    fprintf(fp1,&quot;%s %s %.2f\n&quot;,L.elem[i].no,L.elem[i].name,L.elem[i].price);
&#125;
fclose(fp1);//关闭文件 

system(&quot;pause&quot;);
system(&quot;cls&quot;);

&#125;
return 0;
&#125;
</code></pre>
]]></content>
      <tags>
        <tag>数据结构笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>斐波那契类型 题解</title>
    <url>/2024/07/27/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E7%B1%BB%E5%9E%8B-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h2><span id="1爬楼梯">1爬楼梯</span></h2><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p>
<p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：2</span><br><span class="line">解释：有两种方法可以爬到楼顶。</span><br><span class="line">1. 1 阶 + 1 阶</span><br><span class="line">2. 2 阶</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：3</span><br><span class="line">解释：有三种方法可以爬到楼顶。</span><br><span class="line">1. 1 阶 + 1 阶 + 1 阶</span><br><span class="line">2. 1 阶 + 2 阶</span><br><span class="line">3. 2 阶 + 1 阶</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 45</code></li>
</ul>
<h3><span id="1解法一我采用的">（1）解法一（我采用的）</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">  int climbStairs(int n) &#123;</span><br><span class="line">​    if(n==1) return 1;</span><br><span class="line">​    if(n==2) return 2;</span><br><span class="line">​    int a=1;</span><br><span class="line">​    int b=2;</span><br><span class="line">​    int temp;</span><br><span class="line">​    for(int i=3;i&lt;=n;i++)&#123;</span><br><span class="line">​      temp=a+b;</span><br><span class="line">​      a=b;</span><br><span class="line">​      b=temp;</span><br><span class="line">​    &#125;</span><br><span class="line">​    return b;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3><span id="2解法二动态规划">（2）解法二（动态规划）</span></h3><p>动态规划解决这个问题。设dp[i]就是i时候的最多方案则</p>
<blockquote>
<p>dp[1] &#x3D; 1;<br>dp[2] &#x3D; 2;<br>dp[3] &#x3D; dp[2] + dp[1]<br>……<br>dp[n] &#x3D; dp[n-1] + dp[n2]</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int climbStairs(int n) &#123;</span><br><span class="line">    //这里大小根据自己需要，或者使用 List 也可以</span><br><span class="line">    int[] dp = new int[100000];</span><br><span class="line">    dp[1] = 1;</span><br><span class="line">    dp[2] = 2;</span><br><span class="line">    for( int i = 3;i &lt;= n;++i )&#123;</span><br><span class="line">        dp[i] = dp[i-1] + dp[i-2];</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构 主观题汇总</title>
    <url>/2024/06/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%BB%E8%A7%82%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#1%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E6%9C%AF%E8%AF%AD%E7%9A%84%E9%97%AE%E9%A2%98">1.树的基本概念和术语的问题</a></li>
<li><a href="#2%E7%94%B1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%85%88%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E5%BA%8F%E5%88%97%E5%BB%BA%E6%A0%91">2.由二叉树的先序和中序序列建树</a></li>
<li><a href="#3%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%92%8C%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81">3.哈夫曼树和哈夫曼编码</a></li>
<li><a href="#4%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">4.图的基本概念</a></li>
<li><a href="#5%E7%94%BB%E5%87%BA%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E8%A1%A8%E5%B9%B6%E5%86%99%E5%87%BA%E5%9B%BE%E7%9A%84%E5%B9%BF%E5%BA%A6%E5%92%8C%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97">5.画出无向图的邻接表并写出图的广度和深度优先遍历序列</a></li>
<li><a href="#6%E6%B1%82%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91">6.求最小生成树</a></li>
<li><a href="#7%E6%B1%82%E5%8D%95%E6%BA%90%E7%82%B9%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84">7.求单源点的最短路径</a></li>
<li><a href="#10%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE">10.顺序查找</a></li>
<li><a href="#11%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%88%96%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE">11.二分查找或折半查找</a></li>
<li><a href="#12%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91">12.二叉排序树</a></li>
<li><a href="#13%E6%95%A3%E5%88%97%E8%A1%A8%E6%9F%A5%E6%89%BE%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%E6%B3%95">13.散列表查找——线性探测法</a></li>
<li><a href="#14%E5%93%88%E5%B8%8C%E8%A1%A8%E6%9F%A5%E6%89%BE%E9%93%BE%E5%9C%B0%E5%9D%80%E6%B3%95">14.哈希表查找——链地址法</a></li>
<li><a href="#15%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F">15.各种排序</a></li>
</ul>
<!-- tocstop -->

<p>[TOC]</p>
<h3><span id="1树的基本概念和术语的问题">1.树的基本概念和术语的问题</span></h3><p><strong>设在树中，结点x是结点y的双亲时，用(x,y)来表示树变。已知一棵树边的集合为：{(i,m),(i,n),(b,e),(e,i),(b,d),(a,b),(g,j),(g,k),(c,g),(c,f),(h,l),(c,h),(a,c)}，回答下列问题：</strong><br>（1）用树形表示法（带字母的圆圈和线）画出此树<br>（2） 哪个是根结点<br>（3） 哪些是叶结点？<br>（4） 哪个是g的双亲？<br>（5） 哪些是g的祖先？<br>（6） 哪些是g的孩子？<br>（7） 哪些是e的子孙？<br>（8） 哪些是e的兄弟？哪些是f的兄弟？<br>（9） 结点b和n的层次各是多少？<br>（10） 树的深度是多少？<br>（11） 以结点c为根的子树的深度是多少？<br>（12） 树的度数是多少？</p>
<p><img src="/2024/06/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%BB%E8%A7%82%E9%A2%98%E6%B1%87%E6%80%BB/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240608083207.png" alt="微信截图_20240608083207"></p>
<p>a是根结点；</p>
<p>m、n、d、j、k、f、l是叶子结点；</p>
<p>c是g的双亲；</p>
<p>a是g的祖先；</p>
<p>j、k是g的孩子；</p>
<p>i、m、n是e的子孙；</p>
<p>d是e的兄弟，g、h是f的兄弟；</p>
<p>b的层次是2，n的层次是5；</p>
<p>树的深度是5；</p>
<p>c的深度是3；</p>
<p>树的度数是3。</p>
<h3><span id="2由二叉树的先序和中序序列建树">2.由二叉树的先序和中序序列建树</span></h3><img src="/2024/06/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%BB%E8%A7%82%E9%A2%98%E6%B1%87%E6%80%BB/20180523165909343-1718009007546-1.png" alt="20180523165909343" style="zoom:80%;">

<p><strong>假设一棵二叉树的先序序列为EBADCFHGIKJ和中序序列为ABCDEFGHIJK，要求：</strong></p>
<p>（1）画出这棵二叉树；</p>
<p>（2）请给出其后序序列和层序序列。</p>
<img src="/2024/06/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%BB%E8%A7%82%E9%A2%98%E6%B1%87%E6%80%BB/微信截图_20240608084403-1718009026051-3.png" alt="微信截图_20240608084403" style="zoom:80%;">

<p>后序：ACDBGJKIHFE</p>
<p>层序：EBFADHCGIKJ</p>
<h3><span id="3哈夫曼树和哈夫曼编码">3.哈夫曼树和哈夫曼编码</span></h3><p><strong>求哈夫曼树：</strong></p>
<p>（１）根据n个给定的权值构成n棵二叉树的森林，森林中每一棵树只有一个带权的根结点</p>
<p>（２）在森林中，选取两棵根结点的权值最小的树作为左右子树，构造一棵新的二叉树，且设置新的二叉树的根结点的权值为其左右子树上根结点的权值之和</p>
<p>（３）在森林中删除这两棵树，同时将新得到的二叉树加入到森林中</p>
<p>（４）重复（２）和（３），直到森林中只有一棵树为止，这棵树即为哈夫曼树</p>
<p><strong>求哈夫曼编码：</strong></p>
<p>左分支为0，右分支为1。</p>
<p><strong>假设用于通信的电文仅由8个字母组成，字母在电文中出现的频率分别为0.09，0.16，0.02，0.06，0.32，0.03，0.21，0.11。</strong></p>
<p>（1）画出哈夫曼树；</p>
<p>（2）根据哈夫曼树给这8个字母设计哈夫曼编码，计算WPL值；</p>
<p>（3）设计另一种由二进制表示的等长编码方案；</p>
<p>（4） 对于上述实例，计算两种方案的平均编码长度，分析两种方案的优缺点。</p>
<p><img src="/2024/06/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%BB%E8%A7%82%E9%A2%98%E6%B1%87%E6%80%BB/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240608120058.png" alt="微信截图_20240608120058"></p>
<p><img src="/2024/06/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%BB%E8%A7%82%E9%A2%98%E6%B1%87%E6%80%BB/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240608121225.png" alt="微信截图_20240608121225"></p>
<p>对于上述两种方案，等长编码的构造比哈夫曼编码的构造简单。等长编码的译码简单。但是哈夫曼编码是最优前缀编码。利用哈夫曼编码对文件进行编码，使该文件压缩后对应的二进制文件的长度最短。而等长编码使该二进制文件的长度不短。哈夫曼编码的构造和译码相对等长编码复杂些。</p>
<h3><span id="4图的基本概念">4.图的基本概念</span></h3><p>请根据下图给出：</p>
<p>（1）每个顶点的度</p>
<p>（2）邻接矩阵</p>
<p>（3）邻接表(边结点序号从小到大)</p>
<p><img src="/2024/06/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%BB%E8%A7%82%E9%A2%98%E6%B1%87%E6%80%BB/51c238b5-954b-4348-af1a-f29986300fa6.png" alt="51c238b5-954b-4348-af1a-f29986300fa6"></p>
<p><img src="/2024/06/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%BB%E8%A7%82%E9%A2%98%E6%B1%87%E6%80%BB/0fa7c377-cb8e-4ccb-8c37-96bddd5aa3d2.jpg" alt="0fa7c377-cb8e-4ccb-8c37-96bddd5aa3d2"></p>
<p><img src="/2024/06/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%BB%E8%A7%82%E9%A2%98%E6%B1%87%E6%80%BB/aca2a79d-0232-4de6-96b0-1f5b0d9385a3.jpg" alt="aca2a79d-0232-4de6-96b0-1f5b0d9385a3"></p>
<p><img src="/2024/06/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%BB%E8%A7%82%E9%A2%98%E6%B1%87%E6%80%BB/4b5df1b6-2e31-4120-a0c3-af870755f3fe.png" alt="4b5df1b6-2e31-4120-a0c3-af870755f3fe"></p>
<h3><span id="5画出无向图的邻接表并写出图的广度和深度优先遍历序列">5.画出无向图的邻接表并写出图的广度和深度优先遍历序列</span></h3><p>(1)写出下图的邻接表(边结点序号从小到大)，<br>(2)写出从顶点3出发的广度优先搜索序列和深度优先搜索序列，顶点之间用空格隔开。约定以结点小编号优先次序访问。</p>
<p><img src="/2024/06/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%BB%E8%A7%82%E9%A2%98%E6%B1%87%E6%80%BB/8013d897-f5b6-4f3c-8fc5-39674a21cc16.png" alt="8013d897-f5b6-4f3c-8fc5-39674a21cc16"></p>
<p><img src="/2024/06/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%BB%E8%A7%82%E9%A2%98%E6%B1%87%E6%80%BB/user-uploads_1639164144315953152_2024-5-21_1716235096-488f3a33-1844-4da5-a857-1ac694da7a5f.jpg" alt="user-uploads_1639164144315953152_2024-5-21_1716235096-488f3a33-1844-4da5-a857-1ac694da7a5f"></p>
<p><img src="/2024/06/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%BB%E8%A7%82%E9%A2%98%E6%B1%87%E6%80%BB/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240616114026.jpg" alt="微信图片_20240616114026"></p>
<p>广度：3 1 2 4 6 0 5</p>
<p>深度：3 1 0 2 4 5 6</p>
<h3><span id="6求最小生成树">6.求最小生成树</span></h3><p>已知一个无向图的顶点集V和边集E分别为：V&#x3D;{1,2,3,4,5,6,7};</p>
<p>E&#x3D;{(1,2)3, (1,3)5, (1,4)8, (2,5)10, (2,3)6, (3,4)15, (3,5)12, (3,6)9, (4,6)4, (4,7)20, (5,6)18, (6,7)25}; &#x2F;&#x2F;每条边后面的数代表权值</p>
<p>请用克鲁斯卡尔算法得到最小生成树，试写出在最小生成树中依次得到的各条边。</p>
<p><img src="/2024/06/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%BB%E8%A7%82%E9%A2%98%E6%B1%87%E6%80%BB/user-uploads_1639164144315953152_2024-5-31_1717163110-28a492eb-ccc1-4eab-8f7c-a68b9a0db883.jpg" alt="user-uploads_1639164144315953152_2024-5-31_1717163110-28a492eb-ccc1-4eab-8f7c-a68b9a0db883"></p>
<h3><span id="7求单源点的最短路径">7.求单源点的最短路径</span></h3><p>下图所示的带权有向图G，给出从顶点V1到其余各个顶点的最短路径及其路径长度。</p>
<p><img src="/2024/06/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%BB%E8%A7%82%E9%A2%98%E6%B1%87%E6%80%BB/2364c788-a821-4c59-993f-2540331d84ae.jpg" alt="2364c788-a821-4c59-993f-2540331d84ae"></p>
<p><img src="/2024/06/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%BB%E8%A7%82%E9%A2%98%E6%B1%87%E6%80%BB/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240616114650.png" alt="微信图片_20240616114650"></p>
<h3><span id="10顺序查找">10.顺序查找</span></h3><p>根据教材中设置监视哨的顺序查找算法，回答如下问题：</p>
<p>（1）简述设置监视哨的顺序查找算法中监视哨的作用，（2）查找表中哪个数据元素是哨兵？（3）查找方向是顺序方向查找还是逆序方向查找？（4）n个元素的查找表进行设置监视哨的顺序查找，需要进行多少次比较后查找失败？</p>
<p>答案：</p>
<p>（1）设置监视哨，可以免去查找过程中每一步都要检测整个表是否查找完毕，可以使进行一次查找所需的平均时间几乎减少一半，提高了查找效率。</p>
<p>（2）顺序表ST的0单元</p>
<p>（3）逆序</p>
<p>（4）n+1次</p>
<h3><span id="11二分查找或折半查找">11.二分查找或折半查找</span></h3><p>已知如下11个元素的有序表（8,16,19,23,39,52,63,77,81,88,90）,要求：<br>（1）画出其二分查找的判定树；<br>（2）给出查找元素88和17的折半查找过程；<br>（3）设有序表表长为n，查找成功或不成功时和给定值进行比较的关键字个数至多分别为多少？<br>（4）给出二分查找的时间复杂度。</p>
<p><img src="/2024/06/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%BB%E8%A7%82%E9%A2%98%E6%B1%87%E6%80%BB/a41dc4ba-73ad-49b5-8d00-17554aed31f9.jpg" alt="a41dc4ba-73ad-49b5-8d00-17554aed31f9"></p>
<p><img src="/2024/06/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%BB%E8%A7%82%E9%A2%98%E6%B1%87%E6%80%BB/user-uploads_1639164144315953152_2024-6-6_1717688367-4365e094-635d-4768-ba6b-086bee11148c.jpg" alt="user-uploads_1639164144315953152_2024-6-6_1717688367-4365e094-635d-4768-ba6b-086bee11148c"></p>
<p>（3）查找成功和给定值进行比较的关键字个数至多都是（log₂n）的向下取整再加一</p>
<p>查找不成功和给定值进行比较的关键字个数等于该路径上内部结点个数，至多不超过（log₂n）的向下取整再加一</p>
<p>（4）O（log₂n）</p>
<h3><span id="12二叉排序树">12.二叉排序树</span></h3><p>在一个空的二叉排序树中依次插入关键字序列为12,7,17,11,16,2,13,9,21,4，要求：<br>（1）画出所得到的二叉排序树；<br>（2）查找关键字9和22各自跟哪些关键字进行了比较？<br>（3）二叉排序树的平均查找长度(ASL)与其形态有关，对n个元素构建的二叉排序树进行查找，最好和最坏的ASL分别是多少？</p>
<p>保证左子树小于根节点，右子树大于根节点</p>
<p><img src="/2024/06/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%BB%E8%A7%82%E9%A2%98%E6%B1%87%E6%80%BB/user-uploads_1639164144315953152_2024-6-7_1717690536-b9f28c4c-9993-4ef4-8706-c642776c854b.jpg" alt="user-uploads_1639164144315953152_2024-6-7_1717690536-b9f28c4c-9993-4ef4-8706-c642776c854b"></p>
<p>(2)9：12、7、11、9</p>
<p>22：12、17、21</p>
<p>（3）最好：log₂n</p>
<p>最坏：（n+1)&#x2F;2</p>
<h3><span id="13散列表查找线性探测法">13.散列表查找——线性探测法</span></h3><p>设哈希表的地址范围为0～17，哈希函数为：H（key）&#x3D;key%16。用线性探测法处理冲突，输入关键字序列：（10，24，32，17，31，30，46，47，40，63，49），构造哈希表，试回答下列问题：<br>① 画出哈希表的示意图；<br>② 若查找关键字63，需要依次与哪些关键字进行比较？<br>③ 若查找关键字60，需要依次与哪些关键字比较？<br>④ 假定每个关键字的查找概率相等，求查找成功时的平均查找长度。<br><img src="/2024/06/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%BB%E8%A7%82%E9%A2%98%E6%B1%87%E6%80%BB/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240616121417.png" alt="微信截图_20240616121417"></p>
<h3><span id="14哈希表查找链地址法">14.哈希表查找——链地址法</span></h3><p><img src="/2024/06/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%BB%E8%A7%82%E9%A2%98%E6%B1%87%E6%80%BB/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240616121606.png" alt="微信截图_20240616121606"></p>
<h3><span id="15各种排序">15.各种排序</span></h3><p>（1）设待排序的关键字序列为{12，2，16，30，28，10，16*，20，6，18}，试分别写出使用以下排序方法，每趟排序结束后关键字序列的状态。<br>① 直接插入排序<br>④ 冒泡排序<br>⑤ 快速排序<br>⑥ 简单选择排序<br>⑦ 堆排序<br>⑧ 二路归并排序</p>
<p>①直接插入排序</p>
<p><img src="/2024/06/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%BB%E8%A7%82%E9%A2%98%E6%B1%87%E6%80%BB/20191229110240491.png" alt="20191229110240491"></p>
<p>④ 冒泡排序</p>
<p><img src="/2024/06/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%BB%E8%A7%82%E9%A2%98%E6%B1%87%E6%80%BB/20191229155437320.png" alt="20191229155437320"></p>
<p>⑤ 快速排序</p>
<p><img src="/2024/06/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%BB%E8%A7%82%E9%A2%98%E6%B1%87%E6%80%BB/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240616121942.png" alt="微信截图_20240616121942"></p>
<p>⑥ 简单选择排序<br>将最小的选出来放在前面<br>2 [12 16 30 28 10 16* 20 6 18]<br>2 6 [16 30 28 10 16* 20 12 18]<br>2 6 10 [30 28 16 16* 20 12 18]<br>2 6 10 12 [28 16 16* 20 30 18]<br>2 6 10 12 16 [28 16* 20 30 18]<br>2 6 10 12 16 16* [28 20 30 18]<br>2 6 10 12 16 16* 18 [20 30 28]<br>2 6 10 12 16 16* 18 20 [28 30]<br>2 6 10 12 16 16* 18 20 28 [30]</p>
<p>⑧ 二路归并排序<br>[2 12] [16 30] [10 28] [16 * 20] [6 18]<br>[2 12 16 30] [10 16* 20 28] [ 6 18 ]<br>[2 10 12 16 16* 20 28 30] [6 18]<br>2 6 10 12 16 16* 18 20 28 30</p>
]]></content>
      <tags>
        <tag>数据结构笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>正弦稳态电路分析</title>
    <url>/2024/04/01/%E6%AD%A3%E5%BC%A6%E7%A8%B3%E6%80%81%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#%E6%AD%A3%E5%BC%A6%E4%BF%A1%E5%8F%B7">正弦信号</a><ul>
<li><a href="#1%E6%AD%A3%E5%BC%A6%E4%BF%A1%E5%8F%B7%E7%9A%84%E4%B8%89%E8%A6%81%E7%B4%A0">1.正弦信号的三要素</a></li>
<li><a href="#2%E6%AD%A3%E5%BC%A6%E4%BF%A1%E5%8F%B7%E7%9A%84%E7%9B%B8%E4%BD%8D%E5%B7%AE">2.正弦信号的相位差</a></li>
<li><a href="#3%E6%AD%A3%E5%BC%A6%E4%BF%A1%E5%8F%B7%E7%9A%84%E6%9C%89%E6%95%88%E5%80%BC">3.正弦信号的有效值</a></li>
</ul>
</li>
<li><a href="#%E6%AD%A3%E5%BC%A6%E4%BF%A1%E5%8F%B7%E7%9A%84%E7%9B%B8%E9%87%8F%E8%A1%A8%E7%A4%BA">正弦信号的相量表示</a><ul>
<li><a href="#1%E5%A4%8D%E6%95%B0a%E7%9A%84%E8%A1%A8%E7%A4%BA">1.复数A的表示</a></li>
<li><a href="#2%E7%94%A8%E7%9B%B8%E9%87%8F%E8%A1%A8%E7%A4%BA%E6%AD%A3%E5%BC%A6%E4%BF%A1%E5%8F%B7">2.用相量表示正弦信号</a></li>
</ul>
</li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E5%85%83%E4%BB%B6%E4%BC%8F%E5%AE%89%E7%89%B9%E6%80%A7%E7%9A%84%E7%9B%B8%E9%87%8F%E5%BD%A2%E5%BC%8F">基本元件伏安特性的相量形式</a><ul>
<li><a href="#1%E7%94%B5%E9%98%BB%E5%85%83%E4%BB%B6">1.电阻元件</a></li>
<li><a href="#2%E7%94%B5%E6%84%9F%E5%85%83%E4%BB%B6">2.电感元件</a></li>
<li><a href="#3%E7%94%B5%E5%AE%B9%E5%85%83%E4%BB%B6">3.电容元件</a></li>
<li><a href="#4%E6%AD%A3%E5%BC%A6%E7%94%B5%E6%BA%90%E7%9A%84%E7%9B%B8%E9%87%8F%E6%A8%A1%E5%9E%8B">4.正弦电源的相量模型</a></li>
</ul>
</li>
<li><a href="#%E7%9B%B8%E9%87%8F%E6%A8%A1%E5%9E%8B">相量模型</a><ul>
<li><a href="#1%E9%98%BB%E6%8A%97%E5%92%8C%E5%AF%BC%E7%BA%B3">1.阻抗和导纳</a></li>
<li><a href="#2%E7%9B%B8%E9%87%8F%E5%9B%BE">2.相量图</a></li>
<li><a href="#3%E9%98%BB%E6%8A%97%E5%92%8C%E5%AF%BC%E7%BA%B3%E7%9A%84%E4%B8%B2-%E5%B9%B6%E8%81%94">3.阻抗和导纳的串、并联</a></li>
</ul>
</li>
<li><a href="#%E4%B8%B2%E8%81%94%E8%B0%90%E6%8C%AF">串联谐振</a><ul>
<li><a href="#1%E6%9D%A1%E4%BB%B6">1.条件</a></li>
<li><a href="#2%E7%89%B9%E5%BE%81">2.特征</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<p>[TOC]</p>
<h2><span id="正弦信号">正弦信号</span></h2><p>正弦稳态电路：在正弦电源作用下，电路达到稳定工作状态时的正弦稳态电路。</p>
<p>正弦交流信号可以用sin函数表示，也可以用cos函数表示，本书采用sin函数。</p>
<h3><span id="1正弦信号的三要素">1.正弦信号的三要素</span></h3><h4><span id="一个正弦信号由3个参数确定最大值-频率角频率和初相">一个正弦信号由3个参数确定：<strong>最大值、频率（角频率）和初相</strong></span></h4><p>（1）<strong>正弦交流信号的一般表达式</strong>：<strong>u(t) &#x3D; Uₘ sin(ωt + θ)</strong></p>
<p>（2）<strong>Uₘ</strong>：<strong>幅值</strong>，表示正弦量所能达到的最大值；又叫峰值或振幅</p>
<p>（3）**(ωt + θ)<strong>：</strong>相位**；θ称为相位角</p>
<p>（4）<strong>ω</strong>：<strong>角频率</strong>，是正弦量在单位时间内变化的弧度数，单位<strong>rad&#x2F;s</strong></p>
<p>（5）<strong>周期</strong>：周期T表示正弦量变化一周需要的时间，单位<strong>s</strong></p>
<p>（6）<strong>公式</strong>：①<strong>T&#x3D;2π&#x2F;ω</strong></p>
<p>​                      ②<strong>f&#x3D;1&#x2F;T</strong></p>
<h3><span id="2正弦信号的相位差">2.正弦信号的相位差</span></h3><p>（1）<strong>定义</strong>：两个同频率正弦信号在任一时刻的相位之差称为相位差，实际上是初相之差。</p>
<p>（2）<strong>符号表示</strong>：θ&#x3D;θᵢ - θᵤ</p>
<p>（3）θ&gt;0，表示i(t)超前于u(t)，电流比电压先到达最大值或最小值；</p>
<p>​          θ&lt;0，表示i(t)滞后于u(t)；</p>
<p>​          θ&#x3D;0，则称i(t)与u(t)同相，二者同时到达最值；</p>
<p>​          θ&#x3D;+-π，则称i(t)与u(t)反相，当i(t)达到最大值时，u(t)达到最小值，反之亦然。</p>
<h3><span id="3正弦信号的有效值">3.正弦信号的有效值</span></h3><p>（1）<strong>定义</strong>：设两个阻值相同的电阻，分别通过周期电流和直流电流，在一个周期内，两个电阻消耗相同的能量，就称该直流电流值为周期电流的有效值。</p>
<p>（2）<strong>总结</strong>：<u>正弦信号的振幅值等于有效值的√2倍。</u></p>
<p>​                     Uₘ &#x3D; √2 U       ，        Iₘ &#x3D; √2 I</p>
<p>（3）<strong>公式表示</strong>：i(t)&#x3D;√2 I sin(ωt + θᵢ)</p>
<p>​                             u(t)&#x3D;√2 U sin(ωt + θᵤ)</p>
<h2><span id="正弦信号的相量表示">正弦信号的相量表示</span></h2><h3><span id="1复数a的表示">1.复数A的表示</span></h3><h4><span id="1代数型-指数型和极型">（1）代数型、指数型和极型</span></h4><ul>
<li><input disabled type="checkbox"> <strong>代数型</strong>：A&#x3D;a1 + ja2</li>
<li><input disabled type="checkbox"> <strong>指数型</strong>：A&#x3D;aeʲᶿ</li>
<li><input disabled type="checkbox"> <strong>极型</strong>：a∠θ</li>
</ul>
<h4><span id="2指数型转换为代数型">（2）指数型转换为代数型</span></h4><ul>
<li><input disabled type="checkbox"> <strong>欧拉公式</strong>：eʲᶿ &#x3D; cosθ + jsinθ</li>
<li><input disabled type="checkbox"> 特别的，e^jπ&#x2F;2 &#x3D; cos(π&#x2F;2) + jsin(π&#x2F;2) &#x3D;j</li>
</ul>
<h4><span id="3代数型转换为指数型和极型">（3）代数型转换为指数型和极型</span></h4><ul>
<li><p><input disabled type="checkbox"> 
<strong>a &#x3D; (a₁² + a₂²)^1&#x2F;2</strong></p>
</li>
<li><p><input disabled type="checkbox"> 
<strong>θ &#x3D; arctan (a₂&#x2F;a₁)</strong></p>
</li>
<li><p><input disabled type="checkbox"> 
常用值：arctan1 &#x3D; π&#x2F;4</p>
<p>​                arctan√3 &#x3D; π&#x2F;3</p>
<p>​                arctan1&#x2F;√3 &#x3D; π&#x2F;6</p>
</li>
</ul>
<img src="/2024/04/01/%E6%AD%A3%E5%BC%A6%E7%A8%B3%E6%80%81%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/微信截图_20240402012354.png" alt="微信截图_20240402012354" style="zoom:80%;">

<h4><span id="4计算">（4）计算</span></h4><img src="/2024/04/01/%E6%AD%A3%E5%BC%A6%E7%A8%B3%E6%80%81%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/微信截图_20240402012812.png" alt="微信截图_20240402012812" style="zoom:80%;">

<h3><span id="2用相量表示正弦信号">2.用相量表示正弦信号</span></h3><h4><span id="1正弦电流-电压的表示">（1）正弦电流、电压的表示</span></h4><p><img src="/2024/04/01/%E6%AD%A3%E5%BC%A6%E7%A8%B3%E6%80%81%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240405124242.png" alt="微信截图_20240405124242"></p>
<p><img src="/2024/04/01/%E6%AD%A3%E5%BC%A6%E7%A8%B3%E6%80%81%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240405123709.png" alt="微信图片_20240405123709"></p>
<h4><span id="2正弦信号与相量的对应规则">（2）正弦信号与相量的对应规则</span></h4><p><img src="/2024/04/01/%E6%AD%A3%E5%BC%A6%E7%A8%B3%E6%80%81%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240405125143.png" alt="微信截图_20240405125143"></p>
<h4><span id="3电流相量适用基尔霍夫定律见例题p87-p91">（3）电流相量适用基尔霍夫定律（见例题P87、P91）</span></h4><p>由i(t)&#x3D;i₁(t) + i₂(t)，有I˙ &#x3D;I˙₁ + I˙₂</p>
<p>由u(t)&#x3D;u₁(t) + u₂(t)，有U˙ &#x3D;U˙₁ + U˙₂</p>
<p>结论对于有效值相量和振幅相量都适用。</p>
<h2><span id="基本元件伏安特性的相量形式">基本元件伏安特性的相量形式</span></h2><h3><span id="1电阻元件">1.电阻元件</span></h3><p><img src="/2024/04/01/%E6%AD%A3%E5%BC%A6%E7%A8%B3%E6%80%81%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240405130717.png" alt="微信图片_20240405130717"></p>
<h3><span id="2电感元件">2.电感元件</span></h3><p><img src="/2024/04/01/%E6%AD%A3%E5%BC%A6%E7%A8%B3%E6%80%81%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240405131106.png" alt="微信截图_20240405131106"></p>
<h3><span id="3电容元件">3.电容元件</span></h3><p><img src="/2024/04/01/%E6%AD%A3%E5%BC%A6%E7%A8%B3%E6%80%81%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240405132101.png" alt="微信截图_20240405132101"></p>
<h3><span id="4正弦电源的相量模型">4.正弦电源的相量模型</span></h3><p>①<strong>正弦电压源</strong>：如果一个独立电压源uₛ(t)的输出电压为正弦电压，即uₛ(t) &#x3D; √2 Uₛ sin(ωt + θᵤ)，就称其为正弦电压源。</p>
<p>参数：Uₛ→有效值；ω→角频率；θᵤ→初相。</p>
<p>②<strong>正弦电流源</strong>：Iₛ(t) &#x3D; √2 Iₛ sin(ωt + θᵤ)</p>
<p>③正弦受控源：VCVC,CCVS,VCCS,CCCS</p>
<h2><span id="相量模型">相量模型</span></h2><h3><span id="1阻抗和导纳">1.阻抗和导纳</span></h3><h4><span id="1阻抗z">（1）阻抗Z</span></h4><h5><span id="1概念">①概念</span></h5><p><img src="/2024/04/01/%E6%AD%A3%E5%BC%A6%E7%A8%B3%E6%80%81%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/4c636121dd444a1e847b36ec124dfc34.png" alt="4c636121dd444a1e847b36ec124dfc34"></p>
<p>X&#x3D;0时，阻抗Z成电阻性。</p>
<p>把X替换成φᶻ也成立（z是下标）。</p>
<h5><span id="2转换关系">②转换关系</span></h5><p>R &#x3D; |Z|cosφᶻ（z是下标）</p>
<p>X &#x3D; |Z|sinφᶻ</p>
<p>其中，</p>
<p>|Z| &#x3D; √（R² + X²） &#x3D; U&#x2F;I</p>
<p>φᶻ &#x3D; arctan（X&#x2F;R）&#x3D; θᵤ - θᵢ</p>
<h5><span id="3基本元件的阻抗">③基本元件的阻抗</span></h5><p><img src="/2024/04/01/%E6%AD%A3%E5%BC%A6%E7%A8%B3%E6%80%81%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/35e4c5e6308d447aadb1585fcfa64836.png" alt="35e4c5e6308d447aadb1585fcfa64836"></p>
<p>其中，X˪ &#x3D; ωL，Xᶜ &#x3D; -1&#x2F;ωC  （c是下标）</p>
<h4><span id="2导纳y">（2）导纳Y</span></h4><p><img src="/2024/04/01/%E6%AD%A3%E5%BC%A6%E7%A8%B3%E6%80%81%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/aba8b119efdc4c78845b70dc846c1eaa.png" alt="aba8b119efdc4c78845b70dc846c1eaa"></p>
<p>导纳的量纲是西门子（S）。</p>
<h3><span id="2相量图">2.相量图</span></h3><p>确定相量的角度需要两个步骤:</p>
<p>①第1步:确定参考相量，即角度为零的相量</p>
<p><strong>串联电路</strong>选<strong>电流</strong>作为参考相量</p>
<p><strong>并联电路</strong>选<strong>电压</strong>作为参考相量</p>
<p>②第2步:根据支路的VCR确定支路电压或电流相量的角度</p>
<p><strong>滞后</strong>：顺时针，后面（以U˪的相量形式作为参照）</p>
<p><strong>超前</strong>：逆时针，前面</p>
<p><img src="/2024/04/01/%E6%AD%A3%E5%BC%A6%E7%A8%B3%E6%80%81%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/fb1a95a4fab44f2aac3ed1a013f8078d.png" alt="fb1a95a4fab44f2aac3ed1a013f8078d"></p>
<p><img src="/2024/04/01/%E6%AD%A3%E5%BC%A6%E7%A8%B3%E6%80%81%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/db461cce59f34b9b9df7b855b362fb60.png" alt="db461cce59f34b9b9df7b855b362fb60"></p>
<p><img src="/2024/04/01/%E6%AD%A3%E5%BC%A6%E7%A8%B3%E6%80%81%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/f6acd5e9b5bb46fb92aa919e11f436a0.png" alt="f6acd5e9b5bb46fb92aa919e11f436a0"></p>
<h3><span id="3阻抗和导纳的串-并联">3.阻抗和导纳的串、并联</span></h3><p><img src="/2024/04/01/%E6%AD%A3%E5%BC%A6%E7%A8%B3%E6%80%81%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240415222834.png" alt="微信图片_20240415222834"></p>
<h2><span id="串联谐振">串联谐振</span></h2><h3><span id="1条件">1.条件</span></h3><p>①电路的总阻抗是：Z &#x3D; R + j(ωL - 1&#x2F;ωC)</p>
<p>②发生谐振时，端口电压U&#96;和端口电流I·同相，只有当阻抗的虚部为0才能满足此条件。</p>
<p>③公式：ω &#x3D; ω₀ &#x3D; 1 &#x2F; √（ωC）</p>
<h3><span id="2特征">2.特征</span></h3><p>①谐振时的阻抗最小，电流最大。</p>
<p>②谐振时的电压与电流同相。并且达到最大值。</p>
<p>③谐振时电感电压和电容电压大小相等，方向相反，电阻电压等于电源电压。</p>
]]></content>
      <tags>
        <tag>电子电路基础</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构 客观题知识点</title>
    <url>/2024/06/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AE%A2%E8%A7%82%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%BB%AA%E8%AE%BA">第一章 绪论</a></li>
<li><a href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%BA%BF%E6%80%A7%E8%A1%A8">第二章 线性表</a></li>
<li><a href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97">第三章 栈和队列</a></li>
<li><a href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%95%B0%E7%BB%84-%E5%B9%BF%E4%B9%89%E8%A1%A8-%E4%B8%B2">第四章 数组 广义表 串</a></li>
<li><a href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%9B%BE">第六章 图</a></li>
<li><a href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%9F%A5%E6%89%BE">第七章 查找</a></li>
<li><a href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%8E%92%E5%BA%8F">第八章 排序</a></li>
<li><a href="#%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A%E9%A2%98">名词解释题</a><ul>
<li><a href="#%E9%93%BE%E8%A1%A8%E5%92%8C%E9%A1%BA%E5%BA%8F%E8%A1%A8">链表和顺序表</a></li>
<li><a href="#%E9%82%BB%E6%8E%A5%E8%A1%A8%E5%92%8C%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5">邻接表和邻接矩阵</a></li>
<li><a href="#%E6%8E%92%E5%BA%8F">排序</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<p>[TOC]</p>
<h2><span id="第一章-绪论">第一章 绪论</span></h2><p>被计算机加工的数据元素不是孤立的，它们彼此之间一般存在某种关系，通常把数据元素之间的这种关系称为 <strong>结构</strong></p>
<p>数据结构涉及数据的逻辑结构、存储结构和施加其上的操作3个方面</p>
<p>数据结构操作的实现与存储结构有关</p>
<p>定义逻辑结构时可不考虑存储结构</p>
<p><strong>数据结构的逻辑结构独立于其存储结构</strong></p>
<p>数据逻辑结构可以分为集合结构、线性结构、树结构和图结构</p>
<p>从逻辑上可将数据结构分为线性结构和非线性结构，<strong>线性表、栈与队列、字符串、数组、广义表是线性结构，树、图、集合是非线性结构</strong></p>
<p>线性表——一对一</p>
<p>集合——松散</p>
<p>树——一对多</p>
<p>图——多对多</p>
<p>关于抽象数据类型的描述：数据封装、使用与实现分离、信息隐藏</p>
<p>算法的时间复杂度与（<strong>问题规模</strong> ）有关。</p>
<p>某算法的时间复杂度是<em>O</em>(<em>n</em>2)，表明该算法的<strong>执行时间与<em>n</em>2成正比</strong></p>
<p><strong>算法+数据结构&#x3D;程序</strong></p>
<p><strong>数据元素</strong>是数据的基本单位，在计算机中通常作为一个整体进行考虑和处理。</p>
<p><strong>数据项</strong>是数据结构讨论问题的最小单元</p>
<p>数据结构在计算机内存中的表示是指<strong>数据的存储结构</strong></p>
<p>数据结构是一门研究非数值计算的程序设计问题中计算机的( <strong>操作对象</strong>)以及它们之间的关系和操作的学科。</p>
<p>顺序存储结构的特点是借助元素在存储器中的相对位置来表示数据元素之间的逻辑关系。（逻辑上相邻的两个元素对应的物理地址也是相邻的）</p>
<p>链式存储结构的特点是借助指示元素存储地址的指针来表示数据元素之间的逻辑关系。</p>
<p>一个正确的算法应该具有 5 个特性：确定性、可行性、有穷性，有一个或多个输出，有零个或多个输入</p>
<p>数据结构中评价算法的两个重要指标是<strong>空间复杂度</strong>和<strong>时间复杂度</strong></p>
<h2><span id="第二章-线性表">第二章 线性表</span></h2><p>对于顺序存储的长度为<em>N</em>的线性表，访问结点和增加结点的时间复杂度分别对应为<em>O</em>(1)和<em>O</em>(<em>N</em>)。</p>
<p>顺序表是一种随机存取的存储结构。</p>
<p>顺序存储设计时，存储单元的地址一定连续。</p>
<p>若某线性表最常用的操作是存取任一指定序号的元素和在最后进行插入和删除运算，则利用顺序表存储最节省时间。</p>
<p>顺序存储结构的主要缺点是不利于插入或删除操作。</p>
<p>一个顺序表所占用的存储空间大小与(元素的存放顺序 )无关，和表的长度、元素的类型、元素中各字段的类型有关。</p>
<p>要将一个顺序表{<em>a</em>0,<em>a</em>1,……,<em>a**n</em>−1}中第i个数据元素<em>a**i</em>(0≤i≤n-1)删除，需要移动（<strong>n-i-1</strong> ）个数据元素。</p>
<p>若长度为n的线性表采用顺序存储结构，那么删除它的第i个数据元素<strong>之前</strong>，需要它一次向前移动（<strong>n-i+1</strong>）个数据元素。</p>
<p>若长度为n的线性表采用顺序结构，在第i个数据元素之前插入一个元素，需要它依次向后移动（n-i+1）个元素。</p>
<p><strong>线性表L&#x3D;（a1, a2 ,……，an ）用一维数组表示，假定删除线性表中任一元素的概率相同（都为1&#x2F;n），则删除一个元素平均需要移动元素的个数是（n-1）&#x2F;2。</strong></p>
<p><strong>等概率情况下，在表长为n的顺序表中插入一个元素所需移动的元素平均个数为n&#x2F;2</strong></p>
<p><strong>删除（n-1）&#x2F;2  ········查找（n+1）&#x2F;2·········· 插入n&#x2F;2</strong></p>
<p>非空线性表除终端结点外，每个结点都有唯一的后继结点。</p>
<p>链式存储的优点是插入、删除元素时不会引起后续元素的移动，缺点是只能顺序访问各元素。</p>
<p>在单链表中，增加一个头结点的最终目的是为了<strong>方便运算的实现</strong></p>
<p>将线性表La和Lb头尾连接，要求时间复杂度为O(1)，且占用辅助空间尽量小。应该使用哪种结构？<strong>带尾指针的单循环链表</strong></p>
<p>可以用带表头附加结点的链表表示线性表，也可以用不带头结点的链表表示线性表，前者最主要的好处是（<strong>使空表和非空表的处理统一</strong>）。</p>
<p>在单链表中，要删除某一指定结点，必须先找到该结点的<strong>直接前驱</strong>。</p>
<p>链表的存储密度小于 1</p>
<h2><span id="第三章-栈和队列">第三章 栈和队列</span></h2><p>堆栈和队列都是插入、删除受到约束的线性表</p>
<p>若采用带头、尾指针的单向链表表示一个堆栈，那么该堆栈的栈顶指针top应该如何设置？<strong>将链表头设为top</strong></p>
<p>栈st为空的判断条件为<strong>st.top &#x3D;&#x3D; st.base</strong></p>
<p>栈st为满的判断条件为<strong>st.top-st.base&gt;&#x3D; st.stacksize</strong></p>
<p>在一个链栈中,若栈顶指针等于NULL则为栈空</p>
<p>和顺序栈相比，链栈有一个比较明显的优势是<strong>通常不会出现栈满的情况</strong></p>
<p>栈和队列的共同点是只允许在端点处插入和删除元素</p>
<p>不论是入队列操作还是入栈操作,在顺序存储结构上都需要考虑”溢出”情况。</p>
<p>在少用一个元素空间的循环队列(m为最大队列长度)是满队列的条件**(rear+1)%m&#x3D;&#x3D;front**</p>
<p>缓冲区应该是一个(<strong>队列</strong> )结构</p>
<p>最不适合用作链队的链表是（）。<strong>只带队头指针的非循环双链表</strong></p>
<p>从一个顺序队列中删除元素时，<strong>首先要取出队首指针所指位置上的元素</strong></p>
<p>在一个顺序存储的循环队列中，若队尾指针指向队尾元素的后一个位置，则队头指针一般指向队头元素的（ ）。<strong>当前位置</strong></p>
<p>在一个顺序循环队列中，若队头指针指向队头元素的当前位置，则队尾指针一般指向队尾元素的（ ）位置。<strong>后一个</strong></p>
<p>一个递归算法必须包括终止条件和递归部分</p>
<p>一个递归的定义可以用递归过程求解，也可以用非递归过程求解，但单从运行时间来看， 通常递归过程比非递归过程<strong>较慢</strong></p>
<h2><span id="第四章-数组-广义表-串">第四章 数组 广义表 串</span></h2><p>广义表是一种（<strong>递归</strong>）数据结构。</p>
<p>若一个问题既可以用迭代方式也可以用递归方式求解，则（<strong>迭代</strong> ）的方法具有更髙的时空效率。</p>
<p>递归函数转换为非递归函数时，通常借助（<strong>栈</strong> ）数据结构</p>
<p>递归函数占用较多的存储空间</p>
<p>串既可以采用顺序存储，也可以采用链式存储</p>
<p>串的长度是指串中所含字符的个数</p>
<p>设有两个串p和q，其中q是p的子串，求q在p中首次出现的位置的算法称为（ <strong>模式匹配</strong>）。</p>
<p>串是一种特殊的线性表，其特殊性体现在（ 数据元素是一个字符）。</p>
<p>对特殊矩阵采用压缩存储的主要目的是(减少不必要的存储空间 )</p>
<p>对n阶对称矩阵压缩存储时，需要表长为（n(n+1)&#x2F;2　）的顺序表。</p>
<p>设主串的长度为n，子串的长度为m，那么BF算法的时间复杂度为（ ）。<strong>O(nxm)</strong></p>
<p>BF算法在最好情况下为O（n+m），最坏情况下为O（nxm）</p>
<p>KMP算法的最大特点是指示主串的指针不用回溯</p>
<h2><span id="第六章-图">第六章 图</span></h2><p>图的BFS生成树的树高比DFS生成树的树高（<strong>小或相等</strong>）</p>
<p>图的遍历是从给定的源点出发每一个顶点仅被访问一次</p>
<p>遍历的基本算法有两种：深度遍历和广度遍历</p>
<p>图的深度遍历是一个递归过程</p>
<p>图的深度优先遍历类似于二叉树的先序遍历，栈</p>
<p>在用邻接表表示有<em>N</em>个结点<em>E</em>条边的图时，深度优先遍历算法的时间复杂度为：<strong><em>O</em>(<em>N</em>+<em>E</em>)</strong></p>
<p>图的广度优先搜索遍历类似于二叉树的层次遍历</p>
<p>用邻接表表示图进行广度优先遍历时，通常借助（ 队列）来实现算法</p>
<p>如果从无向图的任一顶点出发进行一次深度优先搜索可访问所有顶点，则该图一定是连通图</p>
<p>下面（　<strong>Prim算法</strong>）算法适合构造一个稠密图G的最小生成树。</p>
<p>任何一个带权无向连通图的最小生成树——有可能不唯一</p>
<p>在求最小生成树时，Kruskal算法更适合于____。<strong>稀疏图</strong></p>
<p>数据结构中Dijkstra算法用来解决哪个问题？<strong>最短路径</strong></p>
<h2><span id="第七章-查找">第七章 查找</span></h2><p>对二叉搜索树进行什么遍历可以得到从小到大的排序序列？<strong>中序遍历</strong></p>
<p>对于一个数据序列，按照输入顺序建立一个二叉排序树，该二叉排序树的形状取决于（<strong>数据元素的输入次序</strong> ）</p>
<p>折半查找与二叉排序树的时间性能（ ）。有时不相同</p>
<p>如果要求一个线性表既能较快的查找，又能适应动态变化的要求，最好采用( <strong>分块查找</strong>)查找法。</p>
<p>通过设置哨兵从而不需要判断下标是否越界的是（逆向顺序查找 ）</p>
<p>设有一个已排序的线性表（长度&gt;&#x3D;２），分别用顺序查找法和二分查找法找一个与K相等的元素，比较的次数分别是S和B，在查找不成功的情况下，S和B的关系是（S&gt;&#x3D;B）。</p>
<p>对线性表进行二分查找时，要求线性表必须( )<strong>以顺序方式存储，且结点按关键字有序排序</strong></p>
<h2><span id="第八章-排序">第八章 排序</span></h2><p>对n个不同的关键字由小到大进行冒泡排序,在下列( )情况下比较的次数最多.<strong>从大到小排序好的</strong></p>
<p>在最好和最坏情况下的时间复杂度均为O(nlogn)且稳定的排序方法是( <strong>归并排序</strong>).</p>
<p>从未排序的序列中依次取出一个元素与已排序序列中的元素进行比较,然后将其放在已排序序列的合适位置上,该排序方法称为<strong>插入排序</strong></p>
<p>下列排序算法中，不稳定的是<strong>希尔排序快速排序堆排序</strong></p>
<p>下列排序算法中，占用辅助空间最多的是（归并排序 ）</p>
<p>如果原始数据已有序，那么，使用<strong>直接插入</strong>排序算法最快。</p>
<h2><span id="名词解释题">名词解释题</span></h2><h3><span id="链表和顺序表">链表和顺序表</span></h3><h4><span id="顺序表">顺序表</span></h4><p>优点：便于随机存取，存取速度快，便利了查找和修改元素；存储密度大，利用效率高</p>
<p>缺点：占用了连续一大块的存储空间，容易浪费；不方便插入和删除元素</p>
<h4><span id="链表">链表</span></h4><p>优点：方便插入和删除元素；存储空间分配灵活，逻辑存储，不要求物理地址相邻<br>缺点：存储密度小，利用效率不高；不方便存取元素</p>
<h3><span id="邻接表和邻接矩阵">邻接表和邻接矩阵</span></h3><p>一个图的邻接矩阵表示是唯一的，而邻接表表示不唯一</p>
<h4><span id="邻接表one">邻接表（O(n+e)）</span></h4><p>优点：便于增加和删除顶点；便于统计边的数目；空间效率高</p>
<p>缺点：不便于判断两个顶点是否有边；不便于计算各个顶点的度</p>
<h4><span id="邻接矩阵on2">邻接矩阵（O(n²)）</span></h4><p>优点：便于判断两个顶点是否有边；便于计算各个顶点的度</p>
<p>缺点：不便于增加和删除顶点；不便于统计边的数目；空间复杂度高</p>
<h3><span id="排序">排序</span></h3><p>直接插入排序：和打扑克牌一样，把未排序的部分按序取出一个元素插入到已经排序好的有序序列中，插入位置从前往后找。时间复杂度O(n^2),空间复杂度O(1)</p>
<p>希尔排序：分组直接插入排序，将排序元素按增量序列分为几组，组内直接插入排序，缩减增量，使得元素基本有序，在进行一次直接插入排序。时间复杂度O(nlog2 n)，空间复杂度O(1)</p>
<p>冒泡排序：比较相邻元素的值。时间复杂度O(n^2),空间复杂度O(1)</p>
<p>快速排序：从左到右的元素都能一次性找到自己最终位置。piovt基准，low,high。时间复杂度O(nlog2 n),空间复杂度O(log2 n)</p>
<p>直接选择排序：在给定的一组记录中选择最小的和第一个记录交换，然后从第二个记录到最后记录中找最小的和第二个记录交换，如此下去。方式可选小放前面、选大放后面。时间复杂度O(n^2),空间复杂度O(1)</p>
<p>堆排序：大根堆、小根堆。时间复杂度O(nlon2 n),空间复杂度O(1)</p>
<p>二路归并排序：两两归并，排序成一个个有序序列。时间复杂度O(nlog2 n),空间复杂度O(n)</p>
<p>基数排序：实现方法为最高位优先、最低为优先。利用辅助队列按位收集和分配。时间复杂度O(n),空间复杂度O(r )</p>
]]></content>
      <tags>
        <tag>数据结构笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>游戏设计 笔记</title>
    <url>/2024/06/29/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#%E7%A9%BA%E9%97%B4">空间</a><ul>
<li><a href="#1%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97%E6%B8%B8%E6%88%8F%E6%80%A7%E7%9A%84%E4%BD%93%E7%8E%B0">1.《俄罗斯方块》游戏性的体现</a></li>
<li><a href="#2%E6%B3%A1%E6%B3%A1%E9%BE%99%E7%9A%84%E8%BF%9E%E9%94%81%E6%9C%BA%E5%88%B6">2.《泡泡龙》的连锁机制</a></li>
<li><a href="#3%E5%9C%B0%E4%B8%8B%E5%9F%8E">3.地下城</a></li>
<li><a href="#4%E7%A9%BA%E9%97%B4%E5%8E%8B%E7%BC%A9%E7%90%86%E5%BF%B5">4.空间压缩理念</a></li>
<li><a href="#5%E7%A9%BA%E6%B0%94%E5%A2%99">5.空气墙</a></li>
<li><a href="#6%E7%AE%B1%E5%BA%AD%E6%B8%B8%E6%88%8F">6.箱庭游戏</a></li>
<li><a href="#7%E7%AE%80%E5%8D%95%E7%9A%84%E7%A9%BA%E9%97%B4%E5%BC%95%E5%AF%BC%E6%96%B9%E5%BC%8F">7.简单的空间引导方式</a></li>
</ul>
</li>
<li><a href="#%E6%97%B6%E9%97%B4">时间</a><ul>
<li><a href="#%E5%AF%B9%E7%A7%B0%E6%B8%B8%E6%88%8F%E5%92%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E6%B8%B8%E6%88%8F">对称游戏和非对称游戏</a></li>
<li><a href="#%E5%AD%98%E6%A1%A3">存档</a></li>
<li><a href="#%E5%AD%90%E5%BC%B9%E6%97%B6%E9%97%B4">子弹时间</a></li>
<li><a href="#%E6%97%B6%E9%97%B4%E5%8F%99%E4%BA%8B%E5%92%8C%E6%9C%BA%E5%88%B6">时间叙事和机制</a></li>
</ul>
</li>
<li><a href="#%E8%A1%80%E9%87%8F">血量</a><ul>
<li><a href="#%E8%AE%BE%E8%AE%A1">设计</a></li>
<li><a href="#%E6%AD%BB%E4%BA%A1">死亡</a></li>
<li><a href="#%E6%9C%80%E5%A5%BD%E7%9A%84%E6%AD%BB%E4%BA%A1">最好的死亡</a></li>
</ul>
</li>
<li><a href="#%E9%81%93%E5%85%B7">道具</a><ul>
<li><a href="#%E6%B8%B8%E6%88%8F%E5%86%85%E8%8E%B7%E5%8F%96%E9%81%93%E5%85%B7%E7%9A%84%E6%B8%A0%E9%81%93">游戏内获取道具的渠道</a></li>
<li><a href="#%E6%8E%89%E8%90%BD%E6%A6%82%E7%8E%87">掉落概率</a></li>
</ul>
</li>
<li><a href="#%E6%8A%80%E8%83%BD">技能</a><ul>
<li><a href="#%E5%8E%9F%E5%88%99">原则</a></li>
</ul>
</li>
<li><a href="#%E4%BB%BB%E5%8A%A1">任务</a><ul>
<li><a href="#%E4%BD%9C%E7%94%A8">作用</a></li>
<li><a href="#%E8%8E%B7%E5%8F%96%E6%96%B9%E5%BC%8F">获取方式</a></li>
<li><a href="#%E5%AE%8C%E6%88%90%E6%96%B9%E5%BC%8F">完成方式</a></li>
<li><a href="#%E4%BC%98%E7%A7%80%E7%9A%84%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F">优秀的任务系统</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<p>[TOC]</p>
<p>电子游戏和传统游戏最本质的区别是电子游戏可以创造相对客观的随机性。</p>
<p>好玩的游戏不一定是只有单一的机制和单一的游戏性体现，而是需要一系列的相关机制合适地组合在一起。</p>
<p>好的游戏不应该过度强调真实性，带来现实中的糟糕体验。</p>
<p>电子游戏之所以吸引人是因为有着明确的目的性。</p>
<h2><span id="空间">空间</span></h2><h3><span id="1俄罗斯方块游戏性的体现">1.《俄罗斯方块》游戏性的体现</span></h3><ul>
<li>随机性带来的惊喜感。</li>
<li>消除方块后带来的成就感。</li>
<li>空间的减少带来的紧迫感。</li>
</ul>
<h3><span id="2泡泡龙的连锁机制">2.《泡泡龙》的连锁机制</span></h3><ul>
<li>当玩家一次操作后可以获得多次消除的机会，成就感也是成倍增加，之后的连锁反应都是对第一次操作的奖励，而奖励机制是驱使玩家一步步坚持下去的最好动力。</li>
<li>低敏感度的操作提供正反馈，高敏感的操作提供负反馈。</li>
</ul>
<h3><span id="3地下城">3.地下城</span></h3><h4><span id="a原因">A原因</span></h4><ul>
<li>rpg的核心是故事性和人物塑造，而这两点很难填充起游戏时长。</li>
<li>一款rpg想要成功，很重要的一点就是让玩家对主角有代入感，代入感最好的设计就是让玩家和主角有共同成长的体验。</li>
<li>玩家需要在游戏里找到成就感，其中成就感最重要的来源就是“战胜敌人”和“完成挑战”。</li>
<li>地下城本身是可以作为故事线索存在的。</li>
</ul>
<h4><span id="b缺点">B缺点</span></h4><ul>
<li>容易产生疲劳感。</li>
<li>很容易脱离游戏剧情本身。</li>
</ul>
<h4><span id="c原则">C原则</span></h4><ul>
<li>迷宫难度和敌人难度不能同时太高。</li>
<li>本身不能完全脱离故事，或者不能脱离游戏的某个核心机制。</li>
<li>主线相关的单一地下城不能过于漫长。</li>
</ul>
<h3><span id="4空间压缩理念">4.空间压缩理念</span></h3><p>生存空间：玩家在地下城或地图上遇到的那些敌人，并不一定是让玩家去战斗，而只是通过压缩玩家的活动空间，驱使玩家被动前进，这增加了玩家的紧张感，也起到了情绪渲染的作用。</p>
<h3><span id="5空气墙">5.空气墙</span></h3><p>分为看得见的墙（山川、海洋、森林）和看不见的墙（空气）。</p>
<p>玩家容易对空气墙感到厌恶。</p>
<h3><span id="6箱庭游戏">6.箱庭游戏</span></h3><ul>
<li>基础元素的重复使用。</li>
<li>鲜明的视觉落差。不同关卡不同风格。</li>
<li>用通路连接不同关卡。</li>
<li>三段式结构：钥匙-锁-钥匙。</li>
<li>四段式结构：遇到障碍物-获取道具和技能-通过障碍物-扩展更大的地图。</li>
</ul>
<h3><span id="7简单的空间引导方式">7.简单的空间引导方式</span></h3><p>在一个岔路口，宽阔的大路一定是正确的道路，狭窄的道路里可能有支线人物或者宝箱。</p>
<p>当有一条宽阔笔直的道路，中间没有任何敌人也没有任何宝物，而前面出现了一扇门，基本就暗示了即将开始一场宏大的boss战。</p>
<h2><span id="时间">时间</span></h2><h3><span id="对称游戏和非对称游戏">对称游戏和非对称游戏</span></h3><ul>
<li>对称性游戏指的是游戏的参与者获取的信息是同步的游戏。</li>
<li>非对称性游戏是玩家之间存在信息差的游戏。</li>
</ul>
<h3><span id="存档">存档</span></h3><p>分为即时存档和非即时存档。</p>
<h3><span id="子弹时间">子弹时间</span></h3><p>类似于《荒野大镖客2》的鹰眼</p>
<p>子弹时间这种机制存在的最核心的要素就是时间的不平等，当作战双方在时间上没有平等的权力，战斗力自然也就不同了。</p>
<h3><span id="时间叙事和机制">时间叙事和机制</span></h3><ul>
<li>时间是有限的。在有限的时间里尽可能地做更多的事情。</li>
<li>时间的流动性可以改变。</li>
<li>时间是可以跳跃的。</li>
</ul>
<h2><span id="血量">血量</span></h2><p>血量是玩家在游戏中的容错率，是控制游戏节奏的工具。</p>
<p>与胜负相关的重要信息一定要详细地呈现给玩家。</p>
<h3><span id="设计">设计</span></h3><ul>
<li>只有一条命。</li>
<li>用具象的数学化表示，随着装备的升级和等级的提升，血量会增加。</li>
<li>用小心心代替。</li>
<li>模糊生命值概念，用红屏代替残血。</li>
</ul>
<h3><span id="死亡">死亡</span></h3><p>在游戏，死亡的本质是宣告玩家这一次的尝试失败了。</p>
<p>一方面死亡存在的最主要的意义是为玩家创造玩下去的动力，当有死亡这个恐怖的可能性存在时，玩家才会想在游戏里拼命活下去，才能激励自己持续游戏；另一方面，在电子游戏里，死亡本身就是惩罚，去惩罚玩家不能完美地完成游戏。</p>
<p>要保证玩家会因为失败而感到沮丧，但又没有沮丧到放弃游戏。</p>
<p>死亡不是最糟糕的负面反馈，最糟糕的负面反馈是困惑。（不知道怎么就死了）</p>
<h3><span id="最好的死亡">最好的死亡</span></h3><ul>
<li>有操作空间的死亡。（可以提升自己再去打boss）</li>
<li>死亡惩罚的损失是可控的。（装备不能全部消失，尤其是不可再生资源）</li>
</ul>
<p>真正的死亡是玩家不再玩这款游戏。</p>
<h2><span id="道具">道具</span></h2><h3><span id="游戏内获取道具的渠道">游戏内获取道具的渠道</span></h3><p>任务获取。</p>
<p>杀敌掉落。</p>
<p>特殊时间或特殊任务（不可再生）。</p>
<p>锻造。</p>
<h3><span id="掉落概率">掉落概率</span></h3><p>完全随机。</p>
<p>计数掉落。刷久了一定会得到，即保底。</p>
<p>总值掉落，每次掉落会控制一定的总价值。</p>
<p>预期掉落，程序会分析玩家的需求并给予掉落。</p>
<h2><span id="技能">技能</span></h2><h3><span id="原则">原则</span></h3><p>独特性。看到某个技能，玩家能立刻想到对应的角色。</p>
<p>操作空间。技能不能是无脑使用的。</p>
<p>反制空间。技能可以被克制。比如冷却和消耗次数，比如其他人的技能可以压制。</p>
<p>团队配合。见于多人游戏中。</p>
<p>combo。可以打出连招。</p>
<p><img src="/2024/06/29/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1-%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240630002911.jpg" alt="微信图片_20240630002911"></p>
<h2><span id="任务">任务</span></h2><p>作为任务需要娱乐性，设计得有趣很重要。另外，任务在大部分游戏还承担叙事功能，给玩家讲清楚发生了什么故事也是任务流程要考虑的。</p>
<h3><span id="作用">作用</span></h3><ul>
<li>塑造主线剧情和世界观。</li>
<li>带入角色。</li>
<li>烘托环境和氛围。</li>
<li>教学作用。</li>
<li>引导行动路线。</li>
</ul>
<h3><span id="获取方式">获取方式</span></h3><ul>
<li>主线任务：游戏系统强加的任务，是游戏的主要剧情。</li>
<li>npc触发的支线任务。</li>
<li>区域触发的支线任务。</li>
<li>物品触发的支线任务。</li>
<li>时间触发的支线任务。</li>
</ul>
<h3><span id="完成方式">完成方式</span></h3><ul>
<li>战斗。不一定要胜利。</li>
<li>收集某些物品。</li>
<li>对话。</li>
<li>护送某人或某物到达某地。</li>
<li>移动到某地。</li>
<li>探索新的地图。</li>
<li>摧毁某些物品或建筑。</li>
<li>解密。</li>
<li>升级。</li>
</ul>
<h3><span id="优秀的任务系统">优秀的任务系统</span></h3><ul>
<li>重复性较低。</li>
<li>任务的产生和流程是逻辑自洽的。</li>
<li>支线任务的塑造很完善，npc有人物性格。</li>
<li>任务在地图上的节点设计非常合理。</li>
</ul>
]]></content>
      <tags>
        <tag>unity2d</tag>
      </tags>
  </entry>
  <entry>
    <title>栈的表示和操作实现</title>
    <url>/2024/04/05/%E6%A0%88%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E6%93%8D%E4%BD%9C%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#%E4%B8%80-%E9%A1%BA%E5%BA%8F%E6%A0%88">一、顺序栈</a></li>
<li><a href="#%E4%BA%8C-%E9%93%BE%E6%A0%88">二、链栈</a></li>
<li><a href="#%E4%B8%89-%E7%94%A8%E5%A0%86%E6%A0%88%E6%B1%82%E8%A7%A3%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F">三、用堆栈求解后缀表达式</a></li>
</ul>
<!-- tocstop -->

<p>[TOC]</p>
<h3><span id="一-顺序栈">一、顺序栈</span></h3><ul>
<li>存储结构：顺序存储</li>
<li>后进后出，插入和删除只在栈顶进行</li>
<li>递归</li>
<li>附设指针top指示栈顶元素在顺序栈的位置</li>
</ul>
<h4><span id="1定义">1.定义</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define MAXSIZE 100 //存储空间的初始分配量</span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line"></span><br><span class="line">int *base; //栈底指针，在构造前和销毁后，base的值为NULL</span><br><span class="line"></span><br><span class="line">int *top; //栈顶指针,指向栈顶元素的下一个位置</span><br><span class="line"></span><br><span class="line">int stacksize; //栈可用的最大容量</span><br><span class="line"></span><br><span class="line">&#125;SqStack;</span><br><span class="line">SqStack S;</span><br></pre></td></tr></table></figure>

<p>①看栈空</p>
<p>S.top &#x3D; -1; &#x2F;&#x2F;指针指向元素</p>
<p>S.top &#x3D; NULL; </p>
<p>S.top &#x3D; 0; &#x2F;&#x2F;指针指向栈顶元素的下一个位置</p>
<p>s.top &#x3D; S.base; </p>
<p>②看栈长</p>
<p>length &#x3D; S.top - S.base; &#x2F;&#x2F;指针指向栈顶元素的下一个位置</p>
<p>③看栈满</p>
<p>top - base &#x3D; stacksize;  &#x2F;&#x2F;指针指向栈顶元素的下一个位置</p>
<h4><span id="2初始化">2.初始化</span></h4><ul>
<li>分配存储空间，new int[]</li>
<li>如果分配失败，!base，返回-1</li>
<li>否则使空栈，栈顶&#x3D;栈底</li>
<li>使定义中的stacksize获得最大容量</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int InitStack(SqStack &amp;S)&#123;</span><br><span class="line">//构造一个空栈</span><br><span class="line"></span><br><span class="line">S.base = new int[MAXSIZE]; //为顺序栈分配一个指定最大容量的存储空间</span><br><span class="line"></span><br><span class="line">if(S.base==NULL) return -1; //存储分配失败</span><br><span class="line"></span><br><span class="line">S.top = S.base; //空栈</span><br><span class="line"></span><br><span class="line">S.stacksize = MAXSIZE; //stacksize置为最大容量</span><br><span class="line"></span><br><span class="line">return 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="3入栈">3.入栈</span></h4><ul>
<li>判断栈满</li>
<li>否则对e取值</li>
<li>移动指针</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int Push(SqStack &amp;S,int e)&#123;</span><br><span class="line">//插入元素e为新的栈顶</span><br><span class="line"></span><br><span class="line">if(S.top-S.base = stacksize) return -1; //栈满</span><br><span class="line"></span><br><span class="line">*S.top++ = e;  //元素e压入栈顶后，指针+1</span><br><span class="line"></span><br><span class="line">//等价于*S.top = e; S.top++;</span><br><span class="line"></span><br><span class="line">return 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="4出栈">4.出栈</span></h4><ul>
<li>判断栈空</li>
<li>否则栈顶-1</li>
<li>出栈元素赋给元素e</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int Pop(SqStack &amp;S,int &amp;e)&#123;</span><br><span class="line">//删除S的栈顶元素，用e返回其值</span><br><span class="line"></span><br><span class="line">if(S.top == S.base) return -1; //栈空</span><br><span class="line"></span><br><span class="line">e = *--S.top; //栈顶指针-1，将栈顶元素赋给e</span><br><span class="line"></span><br><span class="line">//等价于--S.top; e=*S.top;</span><br><span class="line"></span><br><span class="line">return 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="5取栈顶元素">5.取栈顶元素</span></h4><ul>
<li>判断栈非空</li>
<li>返回当前栈顶元素的值，不修改指针</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int GetTop(SqStack S)&#123;</span><br><span class="line">//返回S的栈顶元素，不修改栈顶指针</span><br><span class="line"></span><br><span class="line">if(S.top! = S.base) //栈非空</span><br><span class="line"></span><br><span class="line">return *(S.top-1); //这是因为栈顶指针指向的不是真实元素，而是元素的下一个</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="二-链栈">二、链栈</span></h3><h4><span id="1定义">1.定义</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct StackNode &#123;</span><br><span class="line"></span><br><span class="line">int data;    </span><br><span class="line"></span><br><span class="line">struct StackNode* next; </span><br><span class="line"></span><br><span class="line">&#125;StackLink, *Linkstack;</span><br><span class="line"></span><br><span class="line">LinkStack S;</span><br></pre></td></tr></table></figure>

<p>链栈是操作受限的单链表，只能在链表的头部进行操作，故没有必要附加头结点。</p>
<ul>
<li>栈顶指针就是链表的头结点。</li>
<li>链栈插入与删除仅在栈顶处执行(头插法&#x2F;头删法)。</li>
<li>栈无栈满问题，空间可扩充适合于多栈操作。</li>
</ul>
<h4><span id="2初始化">2.初始化</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int InitStack(LinkStack &amp;S)&#123;</span><br><span class="line">//构造一个空栈S，栈顶指针置空</span><br><span class="line"></span><br><span class="line">S= NULL;</span><br><span class="line"></span><br><span class="line">return 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="3入栈">3.入栈</span></h4><ul>
<li>为入栈元素e分配空间，用指针p指向 p&#x3D; new LinkStack</li>
<li>对新结点赋值e</li>
<li>把新结点插入到栈顶</li>
<li>修改栈顶指针为p</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int Push(LinkStack &amp;S,int e)&#123;</span><br><span class="line">//在栈顶插入元素e</span><br><span class="line"></span><br><span class="line">p = new LinkStack; //生成新结点</span><br><span class="line">if(!p) return -1;</span><br><span class="line"></span><br><span class="line">p-&gt;data = e; //赋值</span><br><span class="line"></span><br><span class="line">p-&gt;next = S; //将新栈顶插入</span><br><span class="line"></span><br><span class="line">S = p; //使p成为栈顶指针</span><br><span class="line"></span><br><span class="line">return 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="4出栈">4.出栈</span></h4><ul>
<li>判断栈空</li>
<li>否则将栈顶元素赋值给e</li>
<li>用结点p临时保存栈顶元素的空间</li>
<li>下移栈顶指针</li>
<li>释放p结点</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int Pop(LinkStack &amp;S，int &amp;e)&#123;</span><br><span class="line">//删除S的栈顶元素，用e返回其值</span><br><span class="line"></span><br><span class="line">if(S=NULL) return -1; //栈空</span><br><span class="line"></span><br><span class="line">e = S-&gt;data; //赋值</span><br><span class="line"></span><br><span class="line">LinkStack* p;</span><br><span class="line"></span><br><span class="line">p = S; //用p临时保存栈顶元素空间</span><br><span class="line"></span><br><span class="line">S = S-&gt;next; //下移栈顶指针</span><br><span class="line"></span><br><span class="line">free(p); //释放</span><br><span class="line"></span><br><span class="line">return 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="5读栈顶元素">5.读栈顶元素</span></h4><ul>
<li>当栈非空，返回S的值，栈顶S保持不变</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int GetTop(LinkStack S)&#123;</span><br><span class="line">//返回S的栈顶元素，不修改栈顶指针</span><br><span class="line"></span><br><span class="line">if(S!=NULL) </span><br><span class="line"></span><br><span class="line">return S-&gt;data;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="三-用堆栈求解后缀表达式">三、用堆栈求解后缀表达式</span></h3><h4><span id="1定义">1.定义</span></h4><p>后缀表达式是一种不需要括号的表达式，其本身是对栈的一种应用。</p>
<p>与之对应的是中缀表达式，即我们现在使用的四则运算。</p>
<h4><span id="2运算规则">2.运算规则</span></h4><p>顺序：从左到右入栈。</p>
<p>对于数字直接入栈，对于运算符号，就把栈最上面的两个数出栈，进行运算后再重新入栈。式子最后的结果出栈。</p>
<p>栈顶元素永远在运算符的右边。</p>
<h4><span id="3例子">3.例子</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）令P代表入栈，O代表出栈。当利用堆栈求解后缀表达式1 2 3 + * 4 –时，堆栈操作序列是：</span><br><span class="line"></span><br><span class="line">A.PPPOOPOO</span><br><span class="line"></span><br><span class="line">B.PPOOPPOOPPOO</span><br><span class="line"></span><br><span class="line">C.PPPOOPOOPPOO</span><br><span class="line"></span><br><span class="line">D.PPPOOPOOPPOOPO</span><br></pre></td></tr></table></figure>

<p>1、2、3：进栈，PPP</p>
<p>+：对最顶上的3、2出栈，计算2+3&#x3D;5，把结果进栈，OOP</p>
<p>*：对5、1出栈，计算5x1&#x3D;5，把结果进栈，OOP</p>
<p>4：进栈，P</p>
<p>-：对4、5出栈，计算4-5&#x3D;-1，把结果进栈，OOP</p>
<p>最后输出结果：O</p>
<p>答案为D。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（2）表达式`a*(b+c)-d`的后缀表达式是：</span><br><span class="line"></span><br><span class="line">A.`a b c + * d -`</span><br><span class="line"></span><br><span class="line">B.`a b c d * + -`</span><br><span class="line"></span><br><span class="line">C.`a b c * + d -`</span><br><span class="line"></span><br><span class="line">D.`- + * a b c d`</span><br></pre></td></tr></table></figure>

<p>数字优先进栈，所以abc</p>
<p>括号内的式子优先计算，所以首先遇到+，为abc+</p>
<p>算完加法算乘法，所以abc+*</p>
<p>继续将d进栈，然后算减法，所以是abc+*d-</p>
<p>答案为A。</p>
]]></content>
      <tags>
        <tag>数据结构笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念英语 L2</title>
    <url>/2024/07/12/%E6%96%B0%E6%A6%82%E5%BF%B5%E8%8B%B1%E8%AF%AD-L2/</url>
    <content><![CDATA[<h2><span id="单词">单词</span></h2><h3><span id="equal"><strong>equal</strong></span></h3><p>v. &#x2F; adj 与…相等</p>
<p>be equal to  等于</p>
<p>[eg]Wealth is not equal to happiness.</p>
<h3><span id="raise"><strong>raise</strong></span></h3><p>vt 饲养，筹集，提升</p>
<p>raise kids 培养孩子</p>
<p>raise money 筹钱</p>
<p>raise the roof  怒发冲冠</p>
<h3><span id="rise"><strong>rise</strong></span></h3><p>vi</p>
<p>The sun also rises. 太阳照常升起</p>
<h3><span id="torch"><strong>torch</strong></span></h3><p>n.手电筒</p>
<p>carry a torch for sb 暗恋</p>
<h3><span id="cause"><strong>cause</strong></span></h3><p>n原因  v产生，引起</p>
<p>for one cause or another 为了各种各样的事情</p>
<p>for one thing or another</p>
<h3><span id="strike"><strong>strike</strong></span></h3><p>v罢工，打，攻击 n</p>
<p>strike matches 划火柴</p>
<p>strike sb</p>
<p>strike sb as odd  给某人留下奇怪的印象</p>
<p>be struck by her beauty 被美丽打动了</p>
<h3><span id="startled-震惊"><strong>Startled</strong> 震惊</span></h3><p>Surprised 吃惊 astounded&#x2F;astounded :非常吃惊</p>
<p>Amazed :astonished :extremely surprised 美好的事物让人吃惊</p>
<p>Stunned 吃惊程度最深。</p>
<h2><span id="短语">短语</span></h2><h3><span id="1used-to-do-过去常常做某事">1.Used to do :过去常常做某事</span></h3><p>Be&#x2F;get used to doing 习惯做某事</p>
<p>Be used to do 被用作什么</p>
<h3><span id="2be-forever-doing-不厌其烦">2.be forever doing 不厌其烦</span></h3><p>Eg ：Peter is forever taking about his girl friend.</p>
<h3><span id="3be-always-doing-sth-一直在做某事说话人态度不满意">3.be always doing sth :一直在做某事，说话人态度不满意</span></h3><p>Eg：He is always finding faults with me .他总是找我毛病。</p>
<p>Eg: Things are always keeping coming up at the last minute 事情总是赶在最后才出现。</p>
<h3><span id="4have-sth-done-叫-做">4.Have sth done 叫… 做</span></h3><p>have sb do 让… 做</p>
<p>Have sth to do 有… 要做</p>
]]></content>
      <tags>
        <tag>新概念3</tag>
      </tags>
  </entry>
  <entry>
    <title>计组复习笔记</title>
    <url>/2024/12/15/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2><span id="一-全书名词解释">一、【全书】名词解释</span></h2><p>1.主机</p>
<p>2.存储字</p>
<p>3.存储单元</p>
<p>4.机器字长</p>
<p>5.存储字长</p>
<p>6.CPU</p>
<p>7.CU</p>
<p>8.PC</p>
<p>9.ALU</p>
<p>10.IR</p>
<p>11.MAR</p>
<p>12.MDR</p>
<p>13.主存</p>
<p>14.辅存</p>
<p>15.Cache</p>
<p>16.IO接口：主机和IO设备之间的硬件电路和相应的软件控制程序。</p>
<p>17.IO设备：</p>
<p>18.中断</p>
<p>19.组合逻辑控制器</p>
<p>20.微程序控制器</p>
<p>21.存取周期</p>
<p>22.存储器带宽</p>
<p>23.随机存储器RAM</p>
<p>24.只读存储器ROM</p>
<p>25.指令流水线</p>
<p>26.系统总线</p>
<p>27.内部总线</p>
<p>28.DMA</p>
<p>29.指令系统</p>
<p>30.机器语言</p>
<p>31.寄存器</p>
<p>32.微命令</p>
<p>33.微操作</p>
<p>34.微指令</p>
<p>35.微程序</p>
<p>36.算术移位</p>
<p>37.逻辑移位</p>
<p>38.定点数</p>
<p>39.浮点数</p>
<p>40.寻址方式</p>
<p>41.逻辑地址</p>
<p>42.物理地址</p>
<p>43.中断源</p>
<p>44.向量地址</p>
<p>45.中断屏蔽</p>
<h2><span id="二-简答题">二、简答题</span></h2><p>【第一章】简答题</p>
<p>什么是计算机系统、计算机硬件和计算机软件？硬件和软件哪个更重要？</p>
<p>计算机的层次结构如何划分？计算机组织和结构有什么不同含义？【作业】</p>
<p>冯诺依曼计算机的主要特点是什么？计算机由哪些部分组成？【作业】</p>
<p>画出计算机硬件组成框图，说明各部件的作用及计算机硬件的主要技术指标。【作业】</p>
<p>【第三章】简答题</p>
<p>三级时序系统中的三级指的是哪三级？每一级的作用是什么？【作业】</p>
<p>组合逻辑控制器的设计分为哪几步？每步的具体内容是什么？【作业】</p>
<p>【第四章】简答题</p>
<p>画出示意图，简述实地址模式下的存储器寻址的过程。【作业】</p>
<p>8086微处理器标志寄存器中各标志位有什么意义？</p>
<p>8086微处理器的基本结构寄存器组包括哪些寄存器，各有什么用途？</p>
<p>【第六章】简答题</p>
<p>说明存储器的存取时间和存取周期之间的联系和区别。【作业】</p>
<p>什么是存储器的带宽？如果存储器的总线宽度为32位，存取周期为250模式，那么该存储器带宽为多少？【作业】</p>
<p>ROM和RAM的区别是什么？【作业】</p>
<p>地址映像方法有哪几种？它们各有什么优缺点？【作业】</p>
<p>简述Cache-主存 和主存-辅存的区别？【重点】</p>
<p>存储系统采用层次结构的目的是什么？实现存储器层次结构的先决条件是什么？</p>
<p>【第七章】简答题</p>
<p>&#x3D;&#x3D;1.计算机IO系统的功能是什么？它由哪几个部分组成？【作业】&#x3D;&#x3D;</p>
<p>①<strong>功能</strong>：解决<strong>主机与外部设备</strong>的<u>信息通信</u>，<u>提供信息通路</u>，使得外部设备与主机能够<u>协调一致工作</u>。</p>
<p>②<strong>组成</strong>：由IO硬件和IO软件组成。</p>
<p>（IO硬件有系统总线、IO接口、IO设备、设备控制器；IO软件有用户IO程序、设备驱动程序、设备控制程序）</p>
<p>&#x3D;&#x3D;2.什么是IO端口？IO端口有哪些编址方式？各自的特点是什么？【作业】&#x3D;&#x3D;</p>
<p>①<strong>定义</strong>：IO接口中 <u>可编址的寄存器</u> 称为IO端口。</p>
<p>②<strong>编址方式</strong>：</p>
<p>a.<strong>独立编址方式（专用IO端口编址方式）。</strong></p>
<p>b.<strong>存储器映射编址方式（统一编址方式）。</strong></p>
<p>③<strong>特点</strong>：</p>
<p>a.<strong>独</strong>立编址方式的特点：<strong>IO端口和存储器 在 两个<u>独立的地址空间</u> 中进行编址。</strong></p>
<p>IO端口的读写操作由<u>专用的控制信号</u>（IOR&#x2F;IOW）来实现，在指令系统中需要有<u>专用的IO指令</u>实现对IO端口的访问。</p>
<p>（总线结构作图表现为 IO控制总线 直接连接 处理器）</p>
<p>b.<strong>存</strong>储器映射编址方式的特点：<strong>IO端口和存储器 共用 <u>统一的地址空间</u>。</strong></p>
<p>一旦地址空间分配给IO端口，存储器就不能再占用这一部分的地址空间。</p>
<p>IO端口的读写操作由<u>访存的控制信号</u>（MEMR&#x2F;MEMW）来实现，所有访问存储器的指令都可以访问IO端口。</p>
<p>（总线结构作图表现为 IO控制总线 连接了 控制总线）</p>
<p>3.IO硬件包括哪几个部分？各部分的作用是什么？</p>
<p>①<strong>组成部分</strong>：<u>系统总线、IO接口、IO设备、设备控制器</u>。</p>
<p>②<strong>作用</strong>：</p>
<p>a.系统总线：CPU、主存等各大部件之间的<u>信息传输线</u>。</p>
<p>b.IO接口：是主机和IO设备之间设置的一个硬件电路及其相应的控制软件。<u>在系统总线和外设之间传输信号，并起缓冲作用</u>。</p>
<p>c.IO设备：主机和外部打交道的一个工具。</p>
<p>d.设备控制器：用来控制IO设备。</p>
<p>4.什么是用户IO程序？什么是设备驱动程序？什么是设备控制程序？</p>
<p>①用户IO程序：用户利用操作系统提供的 调用界面 编写的 具体IO设备 的输入输出程序。</p>
<p>②设备驱动程序：可以使<u>计算机和设备通信</u>的特殊程序。相当于<u>操作系统和硬件的接口</u>。</p>
<p>③设备控制程序：驱动程序中 <u>具体对设备进行控制</u>的程序。通过<u>接口</u>控制逻辑电路，发出控制命令字。</p>
<p>5.什么是IO接口？IO接口有哪些功能？接口有哪些类型？</p>
<p>①<strong>定义</strong>：【是<strong>主机和IO设备</strong>之间设置的一个<u>硬件电路</u>。】用于在 <strong>系统总线和外设</strong> 之间<u>传输信号</u>，起到缓冲作用。</p>
<p>②<strong>功能</strong>：</p>
<p>a.识别<u>设备地址</u>，选择指定设备。</p>
<p>b.<u>传输控制命令</u>及返回<u>状态信息</u>。使得IO设备可以把设备的状态信息返回给CPU。</p>
<p>c.数据<u>传送</u>和数据<u>缓冲</u>。（主机和IO需要输入输出→数据传输，主机和外设速度不匹配→数据缓冲）</p>
<p>d.数据<u>格式转换</u>。</p>
<p>e.检错纠错，中断，DMA，时序控制。</p>
<p>③<strong>类型</strong>：</p>
<p>a.按<u>通用性</u>分类：通用接口，专用接口。</p>
<p>b.按<u>可编程性</u>分类：可编程接口，不可编程接口。</p>
<p>c.按<u>数据传送方式</u>分类：并行IO接口（传送按字节），串行IO接口（一位位传送）。</p>
<p>d.按<u>数据传送的控制方式</u>分类：程序型接口（慢速外设），DMA接口（高速外设）。</p>
<p>6.程序查询方式、<strong>程序中断方式</strong>、DMA方式各自适用什么范围？</p>
<p>①程序查询方式属于直接程序控制方式，适用于<u>CPU速度不高</u>、<u>CPU工作效率不是很重要</u>、<u>需要调试或诊断IO接口及设备的情况</u>。有关操作的时间未知或不定时，往往采用程序查询方式。</p>
<p>②程序中断方式适用于<u>随机出现的服务</u>，一旦提出要求，立即响应。</p>
<p>③DMA方式适用于<u>高速IO设备与主存</u>的<u>成组数据</u>传输。</p>
<p>7.DMA接口由哪些逻辑电路组成？各逻辑电路的作用是什么？</p>
<p>①<u>主存地址寄存器</u>。存放 <u>设备与主存交换信息</u>时 的<u>主存地址</u>，可以计数。</p>
<p>②<u>字计数器</u>。存放交换的字数，可以计数（以负数补码形式存储，全0时结束）。当数据传送结束时向中断机构发出溢出信号。</p>
<p>③<u>中断机构</u>。接收字计数器的溢出信号，通过<u>中断</u>向<u>CPU</u>报告DMA传送的数据交换完成。</p>
<p>④<u>数据缓冲寄存器</u>。暂存每次传送时的一个数据字。</p>
<p>⑤<u>DMA请求触发器</u>。</p>
<p>⑥<u>控制&#x2F;状态逻辑器</u>。</p>
<p>&#x3D;&#x3D;8.简述DMA传送的工作过程。【作业】【重点】&#x3D;&#x3D;</p>
<p>工作过程分为三个阶段：预处理（初始化）、数据传送、后处理。</p>
<p><strong>①预处理：</strong></p>
<p>a.指明方向：CPU向<u>DMA控制逻辑</u>发送<u>读写控制信号</u>。</p>
<p>b.发送设备地址：CPU向<u>DMA设备寄存器</u>发送<u>设备地址</u>，启动指定设备。</p>
<p>c.发送起始地址：CPU向<u>DMA主存地址</u>寄存器发送需传送数据的<u>主存缓冲区起始地址</u>。</p>
<p>d.发送字数：CPU向<u>DMA字计数器</u>发送需传送的字数。</p>
<p><strong>②数据传送：</strong>CPU继续执行主程序，同时设备与内存传送一批数据。</p>
<p>a.设备做准备。</p>
<p>b.DMA申请总线控制权，成为总线主设备。</p>
<p>c.主存地址送总线，数据送IO设备或主存。</p>
<p>d.释放总线控制权。</p>
<p>e.主存地址+1，字计数器+1。</p>
<p>f.若数据块传送结束，向CPU申请中断。</p>
<p><strong>③后处理：</strong>通过中断服务程序对DMA进行结束处理。</p>
<p>a.对送入内存的数据进行校验。</p>
<p>b.测试传送过程中是否有错误。有错则转错误诊断和处理程序进行处理。</p>
<p>c.决定是否继续使用DMA方式传送数据。若需要，则继续对DMA进行初始化，不需要则停止外设工作。</p>
<p>9.简述中断处理的过程，指出其中哪些工作是由硬件实现的，哪些是由软件实现的。</p>
<p>①关中断。Y</p>
<p>②保存端点。Y</p>
<p>③将中断服务程序入口地址送PC，转向中断服务程序。Y&#x2F;R</p>
<p>④保护现场、置屏蔽字、开中断。R</p>
<p>⑤设备服务。R</p>
<p>⑥退出中断。R</p>
]]></content>
      <tags>
        <tag>2024-2025-1课内笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>用链表实现交集和并集</title>
    <url>/2024/03/24/%E7%94%A8%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E4%BA%A4%E9%9B%86%E5%92%8C%E5%B9%B6%E9%9B%86/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#7-1-%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%BA%8F%E5%88%97%E7%9A%84%E4%BA%A4%E9%9B%86"><strong>7-1 两个有序链表序列的交集</strong></a><ul>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F">输入格式:</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F">输出格式:</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B">输入样例:</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B">输出样例:</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">代码实现：</a></li>
</ul>
</li>
<li><a href="#7-2-%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%BA%8F%E5%88%97%E7%9A%84%E5%90%88%E5%B9%B6"><strong>7-2 两个有序链表序列的合并</strong></a><ul>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-1">输入格式:</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-1">输出格式:</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B-1">输入样例:</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B-1">输出样例:</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1">代码实现：</a></li>
</ul>
</li>
<li><a href="#7-3-%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%90%88%E5%B9%B6%E6%96%B0%E8%A1%A8%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0"><strong>7-3 两个有序链表合并（新表不含重复元素）</strong></a><ul>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-2">输入格式:</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-2">输出格式:</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B-2">输入样例:</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B-2">输出样例:</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2">代码实现：</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<p>[TOC]</p>
<h2><span id="7-1-两个有序链表序列的交集"><strong>7-1 两个有序链表序列的交集</strong></span></h2><p>已知两个非降序链表序列S1与S2，设计函数构造出S1与S2的交集新链表S3。</p>
<h3><span id="输入格式">输入格式:</span></h3><p>输入分两行，分别在每行给出由若干个正整数构成的非降序序列，用−1表示序列的结尾（−1不属于这个序列）。数字用空格间隔。</p>
<h3><span id="输出格式">输出格式:</span></h3><p>在一行中输出两个输入序列的交集序列，数字间用空格分开，结尾不能有多余空格；若新链表为空，输出<code>NULL</code>。</p>
<h3><span id="输入样例">输入样例:</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 5 -1</span><br><span class="line">2 4 5 8 10 -1</span><br></pre></td></tr></table></figure>

<h3><span id="输出样例">输出样例:</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 5</span><br></pre></td></tr></table></figure>

<h3><span id="代码实现">代码实现：</span></h3><p>这段程序的通过难点主要在于关心交集为空的情况，分为两种：</p>
<p>①集合1和集合2之间最少有一个为空</p>
<p>②集合1和集合2不是空集，但是相同元素的个数为0</p>
<p>针对第二种情况，只需要设置一个计数器i&#x3D;0，当集合1的元素&#x3D;&#x3D;集合2的元素时，i++，若运行到循环结束，i仍然为0，说明得到的交集为空</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef struct LNode&#123;</span><br><span class="line">    int data;</span><br><span class="line">    struct LNode *next;</span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"></span><br><span class="line">int creatlist(LinkList &amp;S1,LinkList &amp;S2)&#123;</span><br><span class="line">    LNode *p1,*p2,*r;</span><br><span class="line">    p1=S1,p2=S2;</span><br><span class="line">    r=S1;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        p1=new LNode;</span><br><span class="line">        cin&gt;&gt;p1-&gt;data;</span><br><span class="line">        if(p1-&gt;data==-1) break;//在链表录入-1前结束循环</span><br><span class="line">        p1-&gt;next=NULL;</span><br><span class="line">        r-&gt;next=p1;</span><br><span class="line">        r=p1;</span><br><span class="line">    &#125;//尾插法</span><br><span class="line">    r=S2;//循环利用变量r</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        p2=new LNode;</span><br><span class="line">        cin&gt;&gt;p2-&gt;data;</span><br><span class="line">        if(p2-&gt;data==-1) break;</span><br><span class="line">        p2-&gt;next=NULL;</span><br><span class="line">        r-&gt;next=p2;</span><br><span class="line">        r=p2;</span><br><span class="line">    &#125;//尾插法</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int jiaoji(LinkList &amp;S1,LinkList &amp;S2)&#123;</span><br><span class="line">    LNode *S3,*p3,*r;</span><br><span class="line">    LNode *p1,*p2;</span><br><span class="line">    p1=S1-&gt;next,p2=S2-&gt;next;</span><br><span class="line">    S3=new LNode;</span><br><span class="line">    S3-&gt;next=NULL;</span><br><span class="line">    r=S3;</span><br><span class="line">    int i=0;//统计S3的长度</span><br><span class="line">    if(S1==NULL || S2==NULL)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;NULL&quot;;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    while(p1&amp;&amp;p2)&#123;</span><br><span class="line">        if(p1-&gt;data==p2-&gt;data)&#123;</span><br><span class="line">            i++;</span><br><span class="line">            p3=new LNode;</span><br><span class="line">            p3-&gt;data=p1-&gt;data;</span><br><span class="line">            p3-&gt;next=NULL;</span><br><span class="line">            r-&gt;next=p3;</span><br><span class="line">            r=p3;</span><br><span class="line">            p1=p1-&gt;next;</span><br><span class="line">            p2=p2-&gt;next;</span><br><span class="line">        &#125;else if(p1-&gt;data&gt;p2-&gt;data) p2=p2-&gt;next;</span><br><span class="line">        else if(p1-&gt;data&lt;p2-&gt;data) p1=p1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    if(i==0) &#123;</span><br><span class="line">        cout&lt;&lt;&quot;NULL&quot;;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    p3=S3-&gt;next;//p3重新退回头结点指向的位置</span><br><span class="line">    while(p3-&gt;next)&#123;</span><br><span class="line">        cout&lt;&lt;p3-&gt;data&lt;&lt;&quot; &quot;;</span><br><span class="line">        p3=p3-&gt;next;</span><br><span class="line">    &#125;cout&lt;&lt;p3-&gt;data;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    LNode *S1,*S2;</span><br><span class="line">    S1=new LNode;</span><br><span class="line">    S1-&gt;next=NULL;</span><br><span class="line">    S2=new LNode;</span><br><span class="line">    S2-&gt;next=NULL;</span><br><span class="line">    creatlist(S1,S2);</span><br><span class="line">    jiaoji(S1,S2);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>测试点</td>
<td>提示</td>
<td>内存(KB)</td>
<td>用时(ms)</td>
<td>结果</td>
<td>得分</td>
<td></td>
</tr>
<tr>
<td>0</td>
<td>样例等价</td>
<td>300</td>
<td>2</td>
<td>答案正确</td>
<td>2 &#x2F; 2</td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>交集为空</td>
<td>488</td>
<td>3</td>
<td>答案正确</td>
<td>2 &#x2F; 2</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>完全相交</td>
<td>276</td>
<td>3</td>
<td>答案正确</td>
<td>2 &#x2F; 2</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>其中一个序列完全属于交集</td>
<td>492</td>
<td>2</td>
<td>答案正确</td>
<td>2 &#x2F; 2</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>其中一个序列为空</td>
<td>492</td>
<td>3</td>
<td>答案正确</td>
<td>2 &#x2F; 2</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>大规模数据</td>
<td>31864</td>
<td>291</td>
<td>答案正确</td>
<td>2 &#x2F; 2</td>
<td></td>
</tr>
</tbody></table>
<h2><span id="7-2-两个有序链表序列的合并"><strong>7-2 两个有序链表序列的合并</strong></span></h2><p>已知两个非降序链表序列S1与S2，设计函数构造出S1与S2合并后的新的非降序链表S3。</p>
<h3><span id="输入格式">输入格式:</span></h3><p>输入分两行，分别在每行给出由若干个正整数构成的非降序序列，用−1表示序列的结尾（−1不属于这个序列）。数字用空格间隔。</p>
<h3><span id="输出格式">输出格式:</span></h3><p>在一行中输出合并后新的非降序链表，数字间用空格分开，结尾不能有多余空格；若新链表为空，输出<code>NULL</code>。</p>
<h3><span id="输入样例">输入样例:</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 3 5 -1</span><br><span class="line">2 4 6 8 10 -1</span><br></pre></td></tr></table></figure>

<h3><span id="输出样例">输出样例:</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3 4 5 6 8 10</span><br></pre></td></tr></table></figure>

<h3><span id="代码实现">代码实现：</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef struct LNode&#123;</span><br><span class="line">    int data;</span><br><span class="line">    struct LNode *next;</span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"></span><br><span class="line">int creatlist(LinkList &amp;S1,LinkList &amp;S2)&#123;</span><br><span class="line">    LNode *p1,*p2,*r;</span><br><span class="line">    r=S1;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        p1=new LNode;</span><br><span class="line">        cin&gt;&gt;p1-&gt;data;</span><br><span class="line">        if(p1-&gt;data==-1) break;</span><br><span class="line">        p1-&gt;next=NULL;</span><br><span class="line">        r-&gt;next=p1;</span><br><span class="line">        r=p1;</span><br><span class="line">    &#125;</span><br><span class="line">    r=S2;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        p2=new LNode;</span><br><span class="line">        cin&gt;&gt;p2-&gt;data;</span><br><span class="line">        if(p2-&gt;data==-1) break;</span><br><span class="line">        p2-&gt;next=NULL;</span><br><span class="line">        r-&gt;next=p2;</span><br><span class="line">        r=p2;</span><br><span class="line">    &#125;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line">int bingji(LinkList &amp;S1,LinkList &amp;S2)&#123;</span><br><span class="line">    LNode *p1,*p2;</span><br><span class="line">    p1=S1-&gt;next,p2=S2-&gt;next;</span><br><span class="line">    LNode *S3,*p3;</span><br><span class="line">    S3=S1;</span><br><span class="line">    p3=S3;</span><br><span class="line">    while(p1&amp;&amp;p2)&#123;</span><br><span class="line">        if(p1-&gt;data&lt;=p2-&gt;data)&#123;</span><br><span class="line">            p3-&gt;next=p1;</span><br><span class="line">            p3=p1;</span><br><span class="line">            p1=p1-&gt;next;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            p3-&gt;next=p2;</span><br><span class="line">            p3=p2;</span><br><span class="line">            p2=p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    p3-&gt;next=p1?p1:p2;</span><br><span class="line">    //三目运算符，等价于</span><br><span class="line">    //if(p1)p3-&gt;next=p1; </span><br><span class="line">    //else if(p2)p3-a.next=p2;</span><br><span class="line">    </span><br><span class="line">    free(S2);//释放头结点</span><br><span class="line">    p3=S3-&gt;next;</span><br><span class="line">    if(p3==NULL)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;NULL&quot;;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    while(p3-&gt;next)&#123;</span><br><span class="line">        cout&lt;&lt;p3-&gt;data&lt;&lt;&quot; &quot;;</span><br><span class="line">        p3=p3-&gt;next;</span><br><span class="line">    &#125;cout&lt;&lt;p3-&gt;data;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    return 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    LNode *S1,*S2;</span><br><span class="line">    S1=new LNode,S2=new LNode;</span><br><span class="line">    S1-&gt;next=NULL,S2-&gt;next=NULL;</span><br><span class="line">    creatlist(S1,S2);</span><br><span class="line">    bingji(S1,S2);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>测试点</th>
<th>提示</th>
<th>内存(KB)</th>
<th>用时(ms)</th>
<th>结果</th>
<th>得分</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>样例等价</td>
<td>400</td>
<td>2</td>
<td>答案正确</td>
<td>5 &#x2F; 5</td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>有并列</td>
<td>288</td>
<td>2</td>
<td>答案正确</td>
<td>5 &#x2F; 5</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>链表为空</td>
<td>400</td>
<td>2</td>
<td>答案正确</td>
<td>5 &#x2F; 5</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>大规模输入</td>
<td>46228</td>
<td>370</td>
<td>答案正确</td>
<td>5 &#x2F; 5</td>
<td></td>
</tr>
</tbody></table>
<h2><span id="7-3-两个有序链表合并新表不含重复元素"><strong>7-3 两个有序链表合并（新表不含重复元素）</strong></span></h2><p>已知两个非降序链表序列S1与S2，设计函数构造出S1与S2合并后的新的非降序链表S3。<br>要求S3中没有重复元素。</p>
<h3><span id="输入格式">输入格式:</span></h3><p>输入分两行，分别在每行给出由若干个正整数构成的非降序序列，用−1表示序列的结尾（−1不属于这个序列）。数字用空格间隔。</p>
<h3><span id="输出格式">输出格式:</span></h3><p>在一行中输出合并后新的非降序链表，要求链表中没有重复元素。数字间用空格分开，结尾不能有多余空格；若新链表为空，输出NULL。</p>
<h3><span id="输入样例">输入样例:</span></h3><p>在这里给出一组输入。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 3 3 5 8 -1</span><br><span class="line">2 3 4 6 8 10 -1</span><br></pre></td></tr></table></figure>

<h3><span id="输出样例">输出样例:</span></h3><p>在这里给出相应的输出。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3 4 5 6 8 10</span><br></pre></td></tr></table></figure>

<h3><span id="代码实现">代码实现：</span></h3><p>这一段程序相对于上一题的难点在于：</p>
<p>①要求并集中的元素不可重复，因此必须细致的分类讨论集合1大于、小于或等于集合2，以及集合1和集合2的值分别等不等于并集已存在的值</p>
<p>②设置了测试点：一个是空表，一个只有两个相同的元素。如果不加上p3-&gt;next&#x3D;NULL，程序会报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef struct LNode&#123;</span><br><span class="line">    int data;</span><br><span class="line">    struct LNode *next;</span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"></span><br><span class="line">int creatlist(LinkList &amp;S1,LinkList &amp;S2)&#123;</span><br><span class="line">    LNode *p1,*p2,*r;</span><br><span class="line">    r=S1;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        p1=new LNode;</span><br><span class="line">        cin&gt;&gt;p1-&gt;data;</span><br><span class="line">        if(p1-&gt;data==-1) break;</span><br><span class="line">        p1-&gt;next=NULL;</span><br><span class="line">        r-&gt;next=p1;</span><br><span class="line">        r=p1;</span><br><span class="line">    &#125;</span><br><span class="line">    r=S2;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        p2=new LNode;</span><br><span class="line">        cin&gt;&gt;p2-&gt;data;</span><br><span class="line">        if(p2-&gt;data==-1) break;</span><br><span class="line">        p2-&gt;next=NULL;</span><br><span class="line">        r-&gt;next=p2;</span><br><span class="line">        r=p2;</span><br><span class="line">    &#125;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line">int bingji(LinkList &amp;S1,LinkList &amp;S2)&#123;</span><br><span class="line">    LNode *p1,*p2;</span><br><span class="line">    p1=S1-&gt;next,p2=S2-&gt;next;</span><br><span class="line">    LNode *S3,*p3;</span><br><span class="line">    S3=S1;</span><br><span class="line">    p3=S3;</span><br><span class="line">    while(p1&amp;&amp;p2)&#123;</span><br><span class="line">        if(p1-&gt;data&lt;p2-&gt;data &amp;&amp;p1-&gt;data!=p3-&gt;data)&#123;</span><br><span class="line">            p3-&gt;next=p1;</span><br><span class="line">            p3=p1;</span><br><span class="line">            p1=p1-&gt;next;</span><br><span class="line">        &#125;else if(p1-&gt;data&gt;p2-&gt;data&amp;&amp;p2-&gt;data!=p3-&gt;data)&#123;</span><br><span class="line">            p3-&gt;next=p2;</span><br><span class="line">            p3=p2;</span><br><span class="line">            p2=p2-&gt;next;</span><br><span class="line">        &#125;else if(p1-&gt;data==p2-&gt;data&amp;&amp;p1-&gt;data!=p3-&gt;data)&#123;</span><br><span class="line">            p3-&gt;next=p1;</span><br><span class="line">            p3=p1;</span><br><span class="line">            p1=p1-&gt;next;</span><br><span class="line">            p2=p2-&gt;next;</span><br><span class="line">        &#125;else if(p1-&gt;data==p3-&gt;data) p1=p1-&gt;next;</span><br><span class="line">        else if(p2-&gt;data==p3-&gt;data) p2=p2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    while(p1)&#123;</span><br><span class="line">        if(p3-&gt;data!=p1-&gt;data)&#123;</span><br><span class="line">            p3-&gt;next=p1;</span><br><span class="line">            p3=p1;</span><br><span class="line">        &#125;</span><br><span class="line">        p1=p1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    while(p2)&#123;</span><br><span class="line">        if(p3-&gt;data!=p2-&gt;data)&#123;</span><br><span class="line">            p3-&gt;next=p2;</span><br><span class="line">            p3=p2;</span><br><span class="line">        &#125;</span><br><span class="line">        p2=p2-&gt;next;</span><br><span class="line">    &#125;//不能简单地使用三目运算符，因为必须考虑值相等的情况</span><br><span class="line">    p3-&gt;next=NULL;//如果没有这一条，会报错一个测试点</span><br><span class="line">    free(S2);//释放头结点</span><br><span class="line">    p3=S3-&gt;next;</span><br><span class="line">    if(p3==NULL)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;NULL&quot;;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    while(p3-&gt;next)&#123;</span><br><span class="line">        cout&lt;&lt;p3-&gt;data&lt;&lt;&quot; &quot;;</span><br><span class="line">        p3=p3-&gt;next;</span><br><span class="line">    &#125;cout&lt;&lt;p3-&gt;data;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    return 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    LNode *S1,*S2;</span><br><span class="line">    S1=new LNode,S2=new LNode;</span><br><span class="line">    S1-&gt;next=NULL,S2-&gt;next=NULL;</span><br><span class="line">    creatlist(S1,S2);</span><br><span class="line">    bingji(S1,S2);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>测试点</td>
<td>提示</td>
<td>内存(KB)</td>
<td>用时(ms)</td>
<td>结果</td>
<td>得分</td>
<td></td>
</tr>
<tr>
<td>0</td>
<td>样例</td>
<td>316</td>
<td>2</td>
<td>答案正确</td>
<td>5 &#x2F; 5</td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>一个是空表，另一个只有两个相同元素</td>
<td>316</td>
<td>2</td>
<td>答案正确</td>
<td>5 &#x2F; 5</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>两个表都只有一个元素且相同</td>
<td>316</td>
<td>2</td>
<td>答案正确</td>
<td>5 &#x2F; 5</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>两个表有很多相同元素</td>
<td>452</td>
<td>2</td>
<td>答案正确</td>
<td>5 &#x2F; 5</td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>数据结构笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>见缝插针游戏</title>
    <url>/2024/07/10/%E8%A7%81%E7%BC%9D%E6%8F%92%E9%92%88%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90">案例分析</a></li>
<li><a href="#1%E7%BB%98%E5%88%B6%E5%9C%86%E7%9B%98%E4%B8%8E%E9%92%88">1.绘制圆盘与针</a></li>
<li><a href="#2%E9%92%88%E7%9A%84%E6%97%8B%E8%BD%AC">2.针的旋转</a></li>
<li><a href="#3%E5%88%A9%E7%94%A8%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%A0%B9%E9%92%88%E7%9A%84%E7%BB%98%E5%88%B6">3.利用数组实现多根针的绘制</a></li>
<li><a href="#4%E6%89%B9%E9%87%8F%E7%BB%98%E5%88%B6%E5%87%BD%E6%95%B0">4.批量绘制函数</a></li>
<li><a href="#5%E9%92%88%E7%9A%84%E5%8F%91%E5%B0%84%E4%B8%8E%E6%96%B0%E5%A2%9E">5.针的发射与新增</a></li>
<li><a href="#6%E6%B8%B8%E6%88%8F%E5%A4%B1%E8%B4%A5%E5%88%A4%E6%96%AD">6.游戏失败判断</a></li>
<li><a href="#7%E5%85%A8%E9%83%A8%E4%BB%A3%E7%A0%81">7.全部代码</a></li>
</ul>
<!-- tocstop -->

<p>[TOC]</p>
<h2><span id="案例分析">案例分析</span></h2><p>首先绘制圆盘与针，利用三角函数实现针的旋转；</p>
<p>然后利用数组实现多根针的效果；</p>
<p>接着利用批量绘制函数分析绘制效果改进方法；</p>
<p>最后分析针的发射与增加、游戏失败判断、得分与显示效果的改进方法。</p>
<h2><span id="1绘制圆盘与针">1.绘制圆盘与针</span></h2><p>line(x1,y1,x2,y2)可以画一条直线，(x1,y1)(x2,y2)是直线两个端点的位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;graphics.h&gt;</span><br><span class="line">#include&lt;conio.h&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int width = 800;</span><br><span class="line">	int height = 600;</span><br><span class="line">	initgraph(width, height);//新建画布</span><br><span class="line">	setbkcolor(RGB(255, 255, 255));//背景为白色</span><br><span class="line">	cleardevice();// 以背景色清空背景</span><br><span class="line"></span><br><span class="line">	setlinestyle(PS_SOLID, 3);//实线，线条宽度3</span><br><span class="line">	setlinecolor(RGB(0, 0, 0));//线为黑色</span><br><span class="line">	line(width / 2, height / 2, width / 2 + 160, height / 2);//画一根针</span><br><span class="line">	</span><br><span class="line">	setlinecolor(HSVtoRGB(0, 0.9, 0.8));//设置圆盘线条为红色</span><br><span class="line">	circle(width / 2, height / 2, 60);</span><br><span class="line">	</span><br><span class="line">	_getch();//防止闪退</span><br><span class="line">	return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/10/%E8%A7%81%E7%BC%9D%E6%8F%92%E9%92%88%E6%B8%B8%E6%88%8F/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240711085111.png" alt="微信截图_20240711085111"></p>
<h2><span id="2针的旋转">2.针的旋转</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;graphics.h&gt;</span><br><span class="line">#include&lt;conio.h&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">	const float PI = 3.1415926;</span><br><span class="line">	int width = 800;</span><br><span class="line">	int height = 600;</span><br><span class="line">	initgraph(width, height);//新建画布</span><br><span class="line">	setbkcolor(RGB(255, 255, 255));//背景为白色</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	float linelength = 160;</span><br><span class="line">	float xend, yend;//针的末端坐标，起始坐标为圆心</span><br><span class="line">	float angle = 0;//针的旋转角度</span><br><span class="line">	float rotatespeed = PI / 360;//针的旋转速度</span><br><span class="line">	</span><br><span class="line">	setlinestyle(PS_SOLID, 3);//实线，线条宽度3</span><br><span class="line">	</span><br><span class="line">	while (1) &#123;</span><br><span class="line">		cleardevice();// 以背景色清空背景</span><br><span class="line">		angle += rotatespeed;//角度增加</span><br><span class="line">		if (angle &gt; 2 * PI) angle -= 2 * PI;</span><br><span class="line">		xend = linelength * cos(-angle) + width / 2;</span><br><span class="line">		yend = linelength * sin(-angle) + height / 2;</span><br><span class="line">		setlinecolor(RGB(0, 0, 0));//线为黑色</span><br><span class="line">		line(width / 2, height / 2,xend,yend);//画一根针</span><br><span class="line">		setlinecolor(HSVtoRGB(0, 0.9, 0.8));//设置圆盘线条为红色</span><br><span class="line">		circle(width / 2, height / 2, 60);</span><br><span class="line">		</span><br><span class="line">		Sleep(10);</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	_getch();//防止闪退</span><br><span class="line">	return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中核心代码为：</p>
<p>angle +&#x3D; rotatespeed;&#x2F;&#x2F;角度增加</p>
<p>if (angle &gt; 2 * PI) angle -&#x3D; 2 * PI;</p>
<p>xend &#x3D; linelength * cos(-angle) + width &#x2F; 2;<br>yend &#x3D; linelength * sin(-angle) + height &#x2F; 2;</p>
<h2><span id="3利用数组实现多根针的绘制">3.利用数组实现多根针的绘制</span></h2><p>要实现多根针的绘制，需要记录每根针的角度值。</p>
<p>int linenum&#x3D;20;&#x2F;&#x2F;假设有20根针</p>
<p>float angles[20];&#x2F;&#x2F;定义浮点数数组存储所有针的旋转角度</p>
<p>for(int i&#x3D;0;i&lt;linenum;i++)&#x2F;&#x2F;利用for循环让数组中针的角度均匀分布到0-2*PI</p>
<p>  angles[i] &#x3D; i* 2 * PI&#x2F;linenum;</p>
<h2><span id="4批量绘制函数">4.批量绘制函数</span></h2><p>当绘制的元素较多时，会出现明显的画面闪烁，这时可以使用批量绘图函数。</p>
<p>BeginBatchDraw()用于开始批量绘图</p>
<p>FlushBatchDraw()用于执行未完成的绘制任务</p>
<p>EndBatchDraw()用于结束批量绘制</p>
<h2><span id="5针的发射与新增">5.针的发射与新增</span></h2><p>初始linenum置为0；</p>
<p>if (_kbhit()) {<br>    char input &#x3D; _getch();<br>    if (input &#x3D;&#x3D; ‘ ‘) {<br>        linenum++;&#x2F;&#x2F;针的个数增加<br>        angles[linenum - 1] &#x3D; PI;&#x2F;&#x2F;这根新增针的初始角度<br>        xend &#x3D; linelength * cos(-angles[linenum - 1]) + width &#x2F; 2;<br>        yend &#x3D; linelength * sin(-angles[linenum] - 1) + height &#x2F; 2;<br>        line(width &#x2F; 2, height &#x2F; 2,xend, yend);&#x2F;&#x2F;画出这根新增的针<br>    }<br>}</p>
<h2><span id="6游戏失败判断">6.游戏失败判断</span></h2><p>abs();是求绝对值的函数；</p>
<p>当然也可以用fabs();</p>
<p>当新增加的针和已有针发生碰撞时，游戏失败，在此设定当两根针的旋转角度差的绝对值小于PI&#x2F;60时，认为两根针足够接近，即发生了碰撞。</p>
<p>for (int i &#x3D; 0; i &lt; linenum - 1; i++) {&#x2F;&#x2F;拿新增加的针和之前所有针做比较<br>    if (fabs(angles[linenum - 1] - angles[i]) &lt; PI &#x2F; 60) {<br>    rotatespeed &#x3D; 0;&#x2F;&#x2F;旋转速度置为0<br>    break;<br>    }<br>}</p>
<p><img src="/2024/07/10/%E8%A7%81%E7%BC%9D%E6%8F%92%E9%92%88%E6%B8%B8%E6%88%8F/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240711103025.png" alt="微信截图_20240711103025"></p>
<h2><span id="7全部代码">7.全部代码</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;graphics.h&gt;</span><br><span class="line">#include&lt;conio.h&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">	const float PI = 3.1415926;</span><br><span class="line">	int width = 800;</span><br><span class="line">	int height = 600;</span><br><span class="line">	initgraph(width, height);//新建画布</span><br><span class="line">	setbkcolor(RGB(255, 255, 255));//背景为白色</span><br><span class="line">	setlinestyle(PS_SOLID, 3);//实线，线条宽度3</span><br><span class="line"></span><br><span class="line">	float linelength = 160;</span><br><span class="line">	float xend, yend;//针的末端坐标，起始坐标为圆心</span><br><span class="line">	float rotatespeed = PI / 360;//针的旋转速度</span><br><span class="line">	int linenum = 0;//在旋转的针的个数</span><br><span class="line">	float angles[1000];</span><br><span class="line">	</span><br><span class="line">	int score = 0;//记录得分</span><br><span class="line">	</span><br><span class="line">	BeginBatchDraw();</span><br><span class="line">	while (1) &#123;</span><br><span class="line">		cleardevice();// 以背景色清空背景</span><br><span class="line">		setlinecolor(RGB(0, 0, 0));//线为黑色</span><br><span class="line">		line(0, height / 2, linelength, height / 2);//左边发射区域的一根针</span><br><span class="line">	</span><br><span class="line">		for (int i = 0; i &lt; linenum; i++) &#123;</span><br><span class="line">			angles[i] += rotatespeed;//角度增加</span><br><span class="line">			if (angles[i] &gt; 2 * PI) //如果超过2PI，就减去2PI</span><br><span class="line">				angles[i] -= 2 * PI;</span><br><span class="line">			xend = linelength * cos(-angles[i]) + width / 2;</span><br><span class="line">			yend = linelength * sin(-angles[i]) + height / 2;</span><br><span class="line">			line(width / 2, height / 2, xend, yend);//画一根针</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		if (_kbhit()) &#123;</span><br><span class="line">			char input = _getch();</span><br><span class="line">			if (input == &#x27; &#x27;) &#123;</span><br><span class="line">				linenum++;//针的个数增加</span><br><span class="line">				angles[linenum - 1] = PI;//这根新增针的初始角度</span><br><span class="line">				xend = linelength * cos(-angles[linenum - 1]) + width / 2;</span><br><span class="line">				yend = linelength * sin(-angles[linenum] - 1) + height / 2;</span><br><span class="line">				line(width / 2, height / 2,xend, yend);//画出这根新增的针</span><br><span class="line">				for (int i = 0; i &lt; linenum - 1; i++) &#123;//拿新增加的针和之前所有针做比较</span><br><span class="line">					if (fabs(angles[linenum - 1] - angles[i]) &lt; PI / 60) &#123;</span><br><span class="line">						rotatespeed = 0;//旋转速度置为0</span><br><span class="line">						break;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				&#125;score++;</span><br><span class="line">			&#125;</span><br><span class="line">		setfillcolor(HSVtoRGB(0, linenum / 60.0, 0.8));//针越多，中间圆盘颜色越鲜艳</span><br><span class="line">		setlinecolor(HSVtoRGB(0, 0.9, 0.8));//设置圆盘线条为红色</span><br><span class="line">		circle(width / 2, height / 2, 60);</span><br><span class="line">	</span><br><span class="line">		TCHAR s[20];</span><br><span class="line">		_stprintf_s(s, _T(&quot;%d&quot;), score);</span><br><span class="line">		settextstyle(50, 0, _T(&quot;Times&quot;));//设置文字大小，字体</span><br><span class="line">		settextcolor(RGB(50, 50, 50));//设置文字颜色</span><br><span class="line">		outtextxy(65, 200, s);//输出得分文字</span><br><span class="line">	</span><br><span class="line">		FlushBatchDraw();</span><br><span class="line">		Sleep(10);</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/10/%E8%A7%81%E7%BC%9D%E6%8F%92%E9%92%88%E6%B8%B8%E6%88%8F/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240711105542.png" alt="微信截图_20240711105542"></p>
]]></content>
      <tags>
        <tag>C++_EasyX 项目</tag>
      </tags>
  </entry>
  <entry>
    <title>电路的一般分析方法</title>
    <url>/2024/03/14/%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#%E7%94%B5%E8%B7%AF%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%AE%9A%E5%BE%8B">电路的基本概念和基本定律</a><ul>
<li><a href="#1%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8F%98%E9%87%8F">1.电路分析的基本变量</a></li>
<li><a href="#2%E5%9F%BA%E5%B0%94%E9%9C%8D%E5%A4%AB%E5%AE%9A%E5%BE%8B">2.基尔霍夫定律</a></li>
<li><a href="#3%E7%94%B5%E8%B7%AF%E5%85%83%E4%BB%B6">3.电路元件</a></li>
</ul>
</li>
<li><a href="#%E7%94%B5%E9%98%BB%E7%94%B5%E8%B7%AF%E7%9A%84%E4%B8%80%E8%88%AC%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95">电阻电路的一般分析方法</a><ul>
<li><a href="#%E7%AD%89%E6%95%88%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90%E6%B3%95">等效电路分析法</a></li>
<li><a href="#%E7%BD%91%E5%AD%94%E5%88%86%E6%9E%90%E6%B3%95%E4%BE%8B%E9%A2%98p39">网孔分析法（例题p39)</a></li>
<li><a href="#%E8%8A%82%E7%82%B9%E5%88%86%E6%9E%90%E6%B3%95">节点分析法</a></li>
<li><a href="#%E5%BC%A5%E5%B0%94%E6%9B%BC%E5%AE%9A%E7%90%86">弥尔曼定理</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<p>[TOC]</p>
<h2><span id="电路的基本概念和基本定律">电路的基本概念和基本定律</span></h2><h3><span id="1电路分析的基本变量">1.电路分析的基本变量</span></h3><h4><span id="1电流">（1）电流</span></h4><ul>
<li><input disabled type="checkbox"> <strong>电流</strong>：是电路中电荷流动量的度量，它代表单位时间流过电路中某一截面的净电荷量。</li>
<li><input disabled type="checkbox"> 习惯上把正电荷移动的方向规定为电流方向。</li>
<li><input disabled type="checkbox"> 1A &#x3D; 10³mA &#x3D; 10⁶μA</li>
<li><input disabled type="checkbox"> 恒定电流&#x2F;<strong>直流</strong>的大小和方向不随时间变化，用<strong>I</strong>表示；交变电流&#x2F;<strong>交流</strong>用<strong>i</strong>表示。</li>
<li><input disabled type="checkbox"> 如果电流的真实方向和参考方向一致，电流为正值。</li>
</ul>
<h4><span id="2电压">（2）电压</span></h4><ul>
<li><input disabled type="checkbox"> <strong>电压</strong>：电路中两点之间的电位差。(规定电位下降的方向为电压的真实方向)</li>
<li><input disabled type="checkbox"> <strong>电位</strong>：描述电路中电位能分布的物理量。如果正电荷由a点转移到b点时获得能量，则a点为低电位（负极），b点为高电位（正极）。</li>
<li><input disabled type="checkbox"> <strong>电压降</strong>：电压Uab表示单位正电荷从a点移动到b点所失去的电位能。</li>
<li><input disabled type="checkbox"> <strong>参考点</strong>：又叫“零电位点”，此处的电压为0，用<strong>⊥</strong>表示。</li>
<li><input disabled type="checkbox"> 符号：U</li>
<li><input disabled type="checkbox"> 单位：<strong>伏特（V）</strong></li>
</ul>
<p><img src="/2024/03/14/%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E7%AC%94%E8%AE%B0/26b97bbf08071e65df06f449d76d53a.png" alt="26b97bbf08071e65df06f449d76d53a"></p>
<h4><span id="3电功率">（3）电功率</span></h4><ul>
<li><input disabled type="checkbox"> <strong>电功率</strong>：是电路元件消耗电能快慢的度量，它表示单位时间内电路元件消耗的电场能量。</li>
<li><input disabled type="checkbox"> 符号：p或p(t)</li>
<li><input disabled type="checkbox"> 单位：<strong>瓦特（W）</strong></li>
<li><input disabled type="checkbox"> 公式：<strong>p&#x3D; dw&#x2F;dt &#x3D; ui; P&#x3D;UI;</strong>  (非关联参考方向：p&#x3D;-ui或P&#x3D;-UI)</li>
<li><input disabled type="checkbox"> <strong>功率平衡原理</strong>：电路中所有元件的功率之和为0（即能量守恒）。</li>
<li><input disabled type="checkbox"> 当p&gt;0，p是元件的吸收功率；p&lt;0，元件向外部电路提供功率。</li>
</ul>
<h4><span id="4电阻">（4）电阻</span></h4><ul>
<li><p><input disabled type="checkbox"> 
伏安特性：欧姆定律。</p>
</li>
<li><p><input disabled type="checkbox"> 
符号：R</p>
</li>
<li><p><input disabled type="checkbox"> 
单位：<strong>欧姆(Ω)</strong></p>
</li>
<li><p><input disabled type="checkbox"> 
“电阻值”公式：<strong>R &#x3D;U &#x2F; I</strong>（或R&#x3D;-U&#x2F;I）</p>
</li>
<li><p><input disabled type="checkbox"> 
“电阻元件功率”计算公式：<strong>PR &#x3D; U * I &#x3D; R * i2 &#x3D; U2 &#x2F; R</strong></p>
<p><img src="/2024/03/14/%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E7%AC%94%E8%AE%B0/d9bd6db9355927a8f2d38264806ee63.png" alt="d9bd6db9355927a8f2d38264806ee63"></p>
</li>
</ul>
<h4><span id="5电导">（5）电导</span></h4><ul>
<li><input disabled type="checkbox"> 符号：G</li>
<li><input disabled type="checkbox"> 公式：<strong>G&#x3D;1&#x2F;R，U&#x3D;1&#x2F;G，I&#x3D;GU</strong></li>
<li><input disabled type="checkbox"> 单位：<strong>西门子（S）</strong></li>
<li><input disabled type="checkbox"> 电阻元件可以用电导来表征。</li>
<li><input disabled type="checkbox"> G→0，R→∞</li>
</ul>
<h3><span id="2基尔霍夫定律">2.基尔霍夫定律</span></h3><h4><span id="1术语">（1）术语</span></h4><ul>
<li><input disabled type="checkbox"> 节点：两条或两条以上的连接点。</li>
<li><input disabled type="checkbox"> 回路：电路中任一闭合的路径。</li>
<li><input disabled type="checkbox"> 网孔：回路内部中不含支路的回路。</li>
<li><input disabled type="checkbox"> 网络：含元件较多的电路。</li>
</ul>
<h4><span id="2基尔霍夫电流定律kcl">（2）基尔霍夫电流定律（KCL）：</span></h4><p>在任意时刻流进<strong>任意一个结点</strong>的所有支路电流的代数和总是为零。</p>
<p>即：流出&#x3D;流入。</p>
<p>KCL是运用于电路中节点的，也可以将其推广运用到电路的一个封闭面。</p>
<h4><span id="3基尔霍夫电压定律kvl">（3）基尔霍夫电压定律（KVL）：</span></h4><p>在任意时刻绕<strong>任意一个回路</strong>一周所有支路电压的代数和总是为零。</p>
<p><img src="/2024/03/14/%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E7%AC%94%E8%AE%B0/895aa3a1c25920a4277fa7b3db697b3.png" alt="895aa3a1c25920a4277fa7b3db697b3"></p>
<h3><span id="3电路元件">3.电路元件</span></h3><p>电路元件是实际电器元件的理想化模型，是构成电路的基本单元。</p>
<p>从元件对能量的表现划分为：耗能元件（电阻元件），供能元件（独立电源），储能元件，能量控制元件。</p>
<h4><span id="1电阻元件">（1）电阻元件</span></h4><p>分为线性电阻和非线性电阻。</p>
<h4><span id="2供能元件">（2）供能元件</span></h4><p>①<strong>理想电压源</strong></p>
<ul>
<li><p><strong>理想电压源</strong>：二端元件两端电压不随流过它的电流变化，保持固定的数值&#x2F;变化规律。</p>
</li>
<li><p>“理想电压源”的<strong>伏安特性</strong>： 一条平行于电流轴的直线。</p>
</li>
<li><p>流过理想电压源的电流，是由与之相连接的外部电路来决定的。</p>
</li>
</ul>
<p><img src="/2024/03/14/%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E7%AC%94%E8%AE%B0/cc334c63dede1974a4ab95262f2535d.png" alt="cc334c63dede1974a4ab95262f2535d"></p>
<p>②<strong>理想电流源</strong></p>
<ul>
<li><strong>理想电流源</strong>：二端元件两端电源不随流过它的电压变化，保持固定的数值&#x2F;变化规律。</li>
<li>“理想电流源”的<strong>伏安特性</strong>： 一条平行于电压轴的直线。</li>
<li>理想电流源的端电压，是由与之相连接的外部电路决定的。</li>
</ul>
<p><img src="/2024/03/14/%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E7%AC%94%E8%AE%B0/b2940520b48402f779fb7a04f351340.png" alt="b2940520b48402f779fb7a04f351340"></p>
<h4><span id="3电容元件例题p19-p20">（3）电容元件（例题p19、p20）</span></h4><ul>
<li><input disabled type="checkbox"> 电容器是一种能储存电场能量的部件。</li>
<li><input disabled type="checkbox"> <strong>电容元件</strong>：指存储在极板上的“电荷量 q ”与两极板之间的“电压 u ”的代数关系。</li>
<li><input disabled type="checkbox"> 符号：<strong>C（电容量）</strong></li>
<li><input disabled type="checkbox"> 单位：<strong>法拉（F）</strong></li>
<li><input disabled type="checkbox"> 公式：<strong>1F &#x3D; 1C &#x2F; 1V</strong>，**<u>i(t)&#x3D;C<em>du(t)&#x2F;dt</em></u><strong>，</strong>w&#x3D;1&#x2F;2C<em>u²(t)</em></li>
<li><input disabled type="checkbox"> 电容器两端的电压不可能发生跃变（电流→∞）而只能是连续变化的。电容器C在某一时刻的储能只取决于该时刻的电容电压值。</li>
</ul>
<p><img src="/2024/03/14/%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E7%AC%94%E8%AE%B0/2a28d4d268fadbec868ec19c0631fa2.png" alt="2a28d4d268fadbec868ec19c0631fa2"></p>
<ul>
<li><input disabled type="checkbox"> 两电容器的并联：等效电容量&#x3D;两电容量之和。C&#x3D;C1+C2。</li>
</ul>
<p>相当于电容极板面积增大。</p>
<ul>
<li><input disabled type="checkbox"> 两电容器的串联：两电容倒数之和&#x3D;等效电容量的倒数。1&#x2F;C&#x3D;1&#x2F;C1 + 1&#x2F;C2 。</li>
</ul>
<h4><span id="4电感元件例题p23">（4）电感元件（例题p23）</span></h4><ul>
<li><input disabled type="checkbox"> <strong>电感</strong>：流过线圈的“磁通量”与流过线圈的“电流 i ”的代数关系。</li>
<li><input disabled type="checkbox"> 电感元件的原型：空心线圈。</li>
<li><input disabled type="checkbox"> 符号：<strong>L（电感量）</strong></li>
<li><input disabled type="checkbox"> 单位：<strong>亨利（H）</strong></li>
<li><input disabled type="checkbox"> 公式：**<u>u&#x3D;L*di&#x2F;dt</u><strong>（i对t求导），</strong>wL&#x3D;1&#x2F;2Li²(t)**</li>
</ul>
<p><img src="/2024/03/14/%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E7%AC%94%E8%AE%B0/d86662a10020fea5a2b57a231223f5e.png" alt="d86662a10020fea5a2b57a231223f5e"></p>
<ul>
<li><input disabled type="checkbox"> 电感的串联：等效电感量&#x3D;两电感之和。L&#x3D;L1+L2。</li>
</ul>
<p>相当于线圈的匝数增多。</p>
<ul>
<li><input disabled type="checkbox"> 电感的并联：两电感倒数之和&#x3D;等效电感量的倒数。L&#x3D;1&#x2F;L1 + 1&#x2F;L2。</li>
<li><input disabled type="checkbox"> 电感中电流不能发生跃变。</li>
</ul>
<p><img src="/2024/03/14/%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E7%AC%94%E8%AE%B0/69732c59464c97ef9824e0b9011a78f.png" alt="69732c59464c97ef9824e0b9011a78f"></p>
<h4><span id="5控能元件受控电源">（5）控能元件——受控电源</span></h4><p>①VCVS：电压控制电压源</p>
<p>②CCVS：电流控制电压源</p>
<p>③VCCS：电压控制电流源</p>
<p>④CCCS：电流控制电流源</p>
<p><img src="/2024/03/14/%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E7%AC%94%E8%AE%B0/14e0a9a236d237b6ec38351e0eded56.png" alt="14e0a9a236d237b6ec38351e0eded56"></p>
<p>理想：对<strong>受控电压源</strong>来说，其输出电阻为0；对<strong>受控电流源</strong>来说，其输出电阻为无限大。对<strong>电压控制的受控源</strong>来说，其输入电阻为无限大；对<strong>电流控制的受控源</strong>来说，其输入电阻为0。</p>
<p><u>在电路分析时，受控源可看作独立电源，然后进行电源的等效变换。</u></p>
<p><img src="/2024/03/14/%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E7%AC%94%E8%AE%B0/bcc8038ff63ca6cb7d0fee91f5653a7.png" alt="bcc8038ff63ca6cb7d0fee91f5653a7"></p>
<h2><span id="电阻电路的一般分析方法">电阻电路的一般分析方法</span></h2><h3><span id="等效电路分析法">等效电路分析法</span></h3><h4><span id="1电源模型的等效互换">1.电源模型的等效互换</span></h4><p>电源等效互换的依据是电源的外特性相同。</p>
<p><img src="/2024/03/14/%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E7%AC%94%E8%AE%B0/132db370bc2f286ff83b54d52a9a3b2.png" alt="132db370bc2f286ff83b54d52a9a3b2"></p>
<p>（1）<strong>等效电路</strong>：两个电路具有完全相同的“对外连接端”，两者分别和任意其他的电路成分构成完整电路，如果电路的其它部分工作完全一致，则这两个电路互为<strong>等效电路</strong>。</p>
<p>（2）电路外特性：电路外接端上的电压与电流之间的关系。每个元件可视为一个电路部分，它的特性即是<strong>外特性</strong>。</p>
<p>电路中的一部分用其等效电路替换后，电路其它部分的工作情况保持不变；等效只能适合用于外部，对于互相等效的两个电路内部工作一般是不等效的。</p>
<h4><span id="2电阻的串联和并联">2.电阻的串联和并联</span></h4><p>（1）<strong>串联</strong></p>
<ul>
<li><strong>“电阻串联”等效为“单个电阻元件”</strong>；</li>
<li>两个电阻串联的等效条件：<strong>R &#x3D; R1 + R2</strong>；</li>
</ul>
<p><img src="/2024/03/14/%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E7%AC%94%E8%AE%B0/59e11257ee94fbad7830734dc0360eb.png" alt="59e11257ee94fbad7830734dc0360eb"></p>
<p>（2）<strong>并联</strong></p>
<ul>
<li><strong>“电阻并联”也等效为“单个电阻元件”</strong>；</li>
<li>两个电阻并联的等效条件： <strong>G &#x3D; G1 + G2</strong> 或 <strong>R &#x3D; R1 * R2 &#x2F; R1 + R2</strong></li>
</ul>
<p><img src="/2024/03/14/%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E7%AC%94%E8%AE%B0/961340a8100133f28d58f7f3c92b046.png" alt="961340a8100133f28d58f7f3c92b046"></p>
<p>3.电阻的混联及Y-Δ等效变换</p>
<p><img src="/2024/03/14/%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E7%AC%94%E8%AE%B0/4444eafb8d5297a15e32c3fe4f04a1d.png" alt="4444eafb8d5297a15e32c3fe4f04a1d"></p>
<p><img src="/2024/03/14/%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E7%AC%94%E8%AE%B0/7c514345062324cc216b14a44f06b06.png" alt="7c514345062324cc216b14a44f06b06"></p>
<h3><span id="网孔分析法例题p39">网孔分析法（例题p39)</span></h3><ul>
<li>对支路电流法所列的方程中做如下处理，可得到网孔方程：<br>1）对每个网孔按顺时针方向设定一个网孔电流；<br>2）将各支路电流表示成网孔电流的叠加。</li>
<li>将含源支路转化为电压源U与电阻R串联的形式。</li>
<li>自电阻总是正的，而互电阻既可为正也可为负，取决于流过互电阻的两个网孔电流是否一致，一致时取正。</li>
</ul>
<p><img src="/2024/03/14/%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E7%AC%94%E8%AE%B0/e1ca0f90aaf322d807af84bad6afa0f.png" alt="e1ca0f90aaf322d807af84bad6afa0f"></p>
<h3><span id="节点分析法">节点分析法</span></h3><ul>
<li>选取参考节点如4，则节点4的电位为0，其他3个节点分别对参考节点的电位是U1，U2，U3，即为节点电位。</li>
<li>将含源支路转化为电流源I与电导G并联的形式。</li>
</ul>
<p><img src="/2024/03/14/%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E7%AC%94%E8%AE%B0/e11d4d54a9561856fb79a5ce741c6f9.png" alt="e11d4d54a9561856fb79a5ce741c6f9"></p>
<p><strong>总结：</strong>①网络的独立节点数少于网孔数，用节点分析法。</p>
<p>②已知的电源是电流源，用节点分析法；电源是电压源，用网孔分析法。</p>
<p>③网孔分析法只适合平面网络。</p>
<h3><span id="弥尔曼定理">弥尔曼定理</span></h3><p><img src="/2024/03/14/%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E7%AC%94%E8%AE%B0/55339e45bbf28eac69264f6abd4248b.png" alt="55339e45bbf28eac69264f6abd4248b"></p>
]]></content>
      <categories>
        <category>课堂笔记</category>
      </categories>
      <tags>
        <tag>电子电路基础</tag>
      </tags>
  </entry>
  <entry>
    <title>队列的表示和操作实现</title>
    <url>/2024/05/26/%E9%98%9F%E5%88%97%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E6%93%8D%E4%BD%9C%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#%E4%B8%80-%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E9%98%9F%E5%88%97%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8">一、循环队列（队列的顺序存储）</a></li>
<li><a href="#%E4%BA%8C-%E9%93%BE%E6%A0%88">二、链栈</a></li>
</ul>
<!-- tocstop -->

<p>[TOC]</p>
<h3><span id="一-循环队列队列的顺序存储">一、循环队列（队列的顺序存储）</span></h3><p>如果用户的应用程序中设有循环队列，就必须为它设定一个最大队列长度。</p>
<h4><span id="1定义">1.定义</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define MAXQSIZE 100 //队列可能达到的长度</span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line"></span><br><span class="line">int *base; //存储空间的基地址</span><br><span class="line"></span><br><span class="line">int front; //头指针，若队列不空，指向队列头元素（实位）</span><br><span class="line"></span><br><span class="line">int rear; //尾指针，若队列不空，指向队列尾元素的下一个位置（虚位）</span><br><span class="line"></span><br><span class="line">&#125;SqQueue;</span><br><span class="line"></span><br><span class="line">SqQueue Q;</span><br></pre></td></tr></table></figure>

<h5><span id="顺序队列非循环队列">顺序队列——非循环队列</span></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">初始化队列：Q.front=Q.rear=0;</span><br><span class="line"></span><br><span class="line">入队：新元素按 rear 指示位置加入，再将队尾指针加一，即</span><br><span class="line">Q.base[Q.rear] = e;</span><br><span class="line">Q.rear = Q.rear+1;</span><br><span class="line"></span><br><span class="line">出队：将front指示的元素取出，再将队头指针加一，即 </span><br><span class="line">e=Q.base[O.front];</span><br><span class="line">Q.front= Q.front+ 1;</span><br><span class="line"></span><br><span class="line">队空：Q.front==Q.rear;</span><br><span class="line"></span><br><span class="line">队满：Q.rear-Q.front==MAXQSIZE;</span><br><span class="line"></span><br><span class="line">求队长：Q.rear-Q.front;</span><br></pre></td></tr></table></figure>

<p>存在“假上溢”的现象：<u>因数组越界而导致的程序非法操作错误，并且此时队列的实际可用空间并未占满。</u></p>
<h5><span id="循环队列">循环队列</span></h5><p>防假上溢：少用一个元素空间，即队列空间大小为m时，有m-1个元素就认为是队满。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">队列初始化： Q.front = Q.rear =0;</span><br><span class="line"></span><br><span class="line">队空：Q.front == Q.rear;</span><br><span class="line"></span><br><span class="line">队满：(Q.rear + 1)%MAXQSIZE ==Q.front;</span><br><span class="line"></span><br><span class="line">入队：（1）队列不满，新元素e插入Q.rear所指的位置</span><br><span class="line">      Q.base[Q.rear] = e;</span><br><span class="line">      （2）Q.rear = (Q.rear+1)%MAXQSIZE;</span><br><span class="line">出队：（1）队列不空，删除Q.front所指的元素</span><br><span class="line">      e = Q.base[Q.front];</span><br><span class="line">     （2）Q.front = (Q.front+1)%MAXQSIZE;</span><br><span class="line">求队长：</span><br><span class="line">(Q.rear - Q.front + MAXQSIZE)%MAXQSIZE;</span><br></pre></td></tr></table></figure>

<h4><span id="2初始化">2.初始化</span></h4><ul>
<li>分配一个最大容量为MAXQSIZE的存储空间Q.base &#x3D; new int[]</li>
<li>判断分配失败</li>
<li>否则将头指针和尾指针置为0，表示队列为空</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int InitQueue(SqQueue &amp;Q)&#123;</span><br><span class="line">//构造一个空队列</span><br><span class="line"></span><br><span class="line">Q.base = new int[MAXQSIZE]; //分配存储空间</span><br><span class="line"></span><br><span class="line">if(!Q.base) return -1; //分配失败</span><br><span class="line"></span><br><span class="line">Q.front = Q.rear=0; //头指针、尾指针置为0，表示队列为空</span><br><span class="line"></span><br><span class="line">return 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="3入队">3.入队</span></h4><ul>
<li>判断队满</li>
<li>否则将新元素插入队尾</li>
<li>队尾指针+1</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int EnQueue(SqQueue &amp;Q,int e)&#123;</span><br><span class="line">//插入元素e为Q的新队尾元素</span><br><span class="line"></span><br><span class="line">if((Q.rear+1)%MAXQSIZE==Q.front)</span><br><span class="line">//尾指针在循环意义上+1后等于头指针，表示队满</span><br><span class="line"></span><br><span class="line">return -1;</span><br><span class="line"></span><br><span class="line">Q.base[Q.rear] = e; //新元素插入队尾</span><br><span class="line"></span><br><span class="line">Q.rear = (Q.rear+1)%MAXQSIZE; //队尾指针+1</span><br><span class="line"></span><br><span class="line">return 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="4出队">4.出队</span></h4><ul>
<li>判断队空</li>
<li>否则保存队头元素</li>
<li>队头指针+1</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int DeQueue(SqQueue &amp;Q,int &amp;e)&#123;</span><br><span class="line">//删除Q的队头元素，用e返回其值</span><br><span class="line"></span><br><span class="line">if(Q.front == Q.rear) return -1;//队空</span><br><span class="line"></span><br><span class="line">e = Q.base[Q.front]; //保存队头元素</span><br><span class="line"></span><br><span class="line">Q.front = (Q.front + 1 )%MAXQSIZE； //队头指针+1</span><br><span class="line"></span><br><span class="line">return 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="5取队头元素">5.取队头元素</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int GetHead(SqQueue Q)&#123;</span><br><span class="line">//返回Q的队头元素，不修改队头指针</span><br><span class="line"></span><br><span class="line">if(Q.front!=Q.rear) //非空</span><br><span class="line"></span><br><span class="line">return Q.base[Q.front];//返回队头</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="二-链栈">二、链栈</span></h3><p>采用链式存储结构实现的队列称为<strong>链队列</strong>。</p>
<p>为了使操作更加方便，将队头指针指向链队列的头结点，而队尾指针指向终端结点。 </p>
<p><strong>空队列时，front和rear都指向头结点，即front&#x3D;&#x3D;rear</strong></p>
<h4><span id="1定义">1.定义</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct QNode&#123;</span><br><span class="line">int data;</span><br><span class="line">struct QNode *next;</span><br><span class="line">&#125;QNode,*QueuePtr;</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">QueuePtr front; //队头指针</span><br><span class="line">QueuePtr rear; //队尾指针</span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/05/26/%E9%98%9F%E5%88%97%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E6%93%8D%E4%BD%9C%E5%AE%9E%E7%8E%B0/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240526020235.png" alt="微信截图_20240526020235"></p>
<h4><span id="2初始化">2.初始化</span></h4><p>构造一个只有一个头结点的空队。</p>
<ul>
<li>生成新结点作为头结点，队头和队尾指针指向此结点</li>
<li>头结点的指针域置空</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int InitQueue(LinkQueue &amp;Q)&#123;</span><br><span class="line"></span><br><span class="line">//构造一个空队列Q</span><br><span class="line"></span><br><span class="line">Q.front = Q.rear =new QNode;  //生成新结点作为头结点，队头和队尾指针指向此结点</span><br><span class="line"></span><br><span class="line">Q.front-&gt;next = NULL; //头结点的指针域置空</span><br><span class="line"></span><br><span class="line">return 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="3入队">3.入队</span></h4><p><strong>链队在入队前不需要判断队满，需要为入队元素分配结点空间。</strong></p>
<ul>
<li>为入队元素分配结点空间，用指针p指向</li>
<li>将新结点数据域置为e</li>
<li>将新结点插入到队尾</li>
<li>修改队尾指针为p</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int EnQueue(LinkQueue &amp;Q,int e)&#123;</span><br><span class="line">//插入元素e为Q的新队尾元素</span><br><span class="line"></span><br><span class="line">p = new QNode; //分配新结点</span><br><span class="line"></span><br><span class="line">p-&gt;data = e; //把p的数据域置为e</span><br><span class="line"></span><br><span class="line">p-&gt;next = NULL; Q.rear-&gt;next = p;//把新结点插到队尾</span><br><span class="line"></span><br><span class="line">Q.rear = p; //修改队尾指针</span><br><span class="line"></span><br><span class="line">return 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="4出队">4.出队</span></h4><p><strong>链队在出队前需要判断队列是否为空，不同的是，链队在出队后需要放出队头元素的所占空间。</strong></p>
<ul>
<li>判断队空</li>
<li>否则临时保存队头元素的空间，等待释放</li>
<li>修改头结点的指针域，指向下一个结点</li>
<li>判断出队元素是否为最后一个元素，若是，则将队尾指针重新赋值，指向头结点</li>
<li>释放原队头元素</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int DeQueue(LinkQueue &amp;Q,int &amp;e)&#123;</span><br><span class="line">//删除Q的队头元素，用e返回其值</span><br><span class="line"></span><br><span class="line">if(Q.front==Q.rear) retrun -1; //队空</span><br><span class="line"></span><br><span class="line">p = Q.front-&gt;next; //p指向队头元素</span><br><span class="line"></span><br><span class="line">e = p-&gt;data; //e保存队头元素的值</span><br><span class="line"></span><br><span class="line">Q.front-&gt;next = p-&gt;next;  //修改头结点的指针域</span><br><span class="line"></span><br><span class="line">if(Q.rear == p) Q.rear = Q.front; //最后一个元素被删，队尾指针指向头结点</span><br><span class="line"></span><br><span class="line">free(p); //释放原队头元素</span><br><span class="line"></span><br><span class="line">return 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.求队头元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int GetHead(LinkQueue Q)&#123;</span><br><span class="line">//返回Q的队头元素，不修改队头指针</span><br><span class="line"></span><br><span class="line">if(Q.front!=Q.rear)</span><br><span class="line"></span><br><span class="line">return Q.front-&gt;next-&gt;data;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>数据结构笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>见缝插圆游戏</title>
    <url>/2024/07/10/%E8%A7%81%E7%BC%9D%E6%8F%92%E5%9C%86%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#1%E5%88%A9%E7%94%A8%E6%95%B0%E7%BB%84%E8%AE%B0%E5%BD%95%E5%A4%9A%E4%B8%AA%E9%9A%8F%E6%9C%BA%E5%9C%86">1.利用数组记录多个随机圆</a></li>
<li><a href="#2%E6%AF%8F%E6%AC%A1%E5%A2%9E%E5%8A%A0%E4%B8%80%E4%B8%AA%E9%9A%8F%E6%9C%BA%E5%9C%86">2.每次增加一个随机圆</a></li>
<li><a href="#3%E6%96%B0%E5%9C%86%E4%B8%8D%E5%92%8C%E5%B7%B2%E6%9C%89%E5%9C%86%E7%9B%B8%E4%BA%A4">3.新圆不和已有圆相交</a></li>
<li><a href="#4%E6%96%B0%E5%9C%86%E5%8D%8A%E5%BE%84%E6%9C%80%E5%A4%A7%E5%8C%96">4.新圆半径最大化</a></li>
</ul>
<!-- tocstop -->

<p>[TOC]</p>
<h2><span id="1利用数组记录多个随机圆">1.利用数组记录多个随机圆</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;conio.h&gt;</span><br><span class="line">#include&lt;graphics.h&gt;</span><br><span class="line">#include&lt;time.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int width = 600;</span><br><span class="line">	int height = 600;</span><br><span class="line">	initgraph(width, height);</span><br><span class="line">	setbkcolor(WHITE);</span><br><span class="line">	cleardevice();</span><br><span class="line">	srand(time(0));</span><br><span class="line"></span><br><span class="line">//定义三个数组存储所有圆的圆心坐标和半径</span><br><span class="line">	int x[100];</span><br><span class="line">	int y[100];</span><br><span class="line">	int r[100];</span><br><span class="line">	int rmin = 8;</span><br><span class="line">	int rmax = 50;</span><br><span class="line">	int circlenum = 100;</span><br><span class="line">	</span><br><span class="line">	for (int i = 0; i &lt; circlenum; i++) &#123;</span><br><span class="line">		x[i] = rand() % width;</span><br><span class="line">		y[i] = rand() % height;</span><br><span class="line">		r[i] = rand() % (rmax - rmin + 1) + rmin;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//遍历画图</span><br><span class="line">	for (int i = 0; i &lt; circlenum; i++) &#123;</span><br><span class="line">		setlinecolor(RED);</span><br><span class="line">		setfillcolor(YELLOW);</span><br><span class="line">		fillcircle(x[i], y[i], r[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	_getch();</span><br><span class="line">	return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/10/%E8%A7%81%E7%BC%9D%E6%8F%92%E5%9C%86%E6%B8%B8%E6%88%8F/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240711124734.png" alt="微信截图_20240711124734"></p>
<h2><span id="2每次增加一个随机圆">2.每次增加一个随机圆</span></h2><p>每隔一百毫秒，添加一个随机圆并绘制。</p>
<p><code>int circlenum = 0;</code><br><code>float x, y, r;//新增圆的属性</code></p>
<p><code>while(circlenum&lt;100)&#123;</code><br>    <code>x = rand() % width;</code><br>    <code>y = rand() % height;</code><br>    <code>r = rand() % (rmax - rmin + 1) + rmin;</code></p>
<p>​	<code>xarray[circlenum] = x;</code><br>​	<code>yarray[circlenum] = y;</code><br>​	<code>rarray[circlenum] = r;</code><br>​	<code>circlenum++;</code><br><code>	 ​	`setlinecolor(RED);` ​	`setfillcolor(YELLOW);` ​	`fillcircle(x,y,r);` </code>	<br>​	<code>Sleep(100);</code></p>
<p><code>&#125;</code></p>
<p><img src="/2024/07/10/%E8%A7%81%E7%BC%9D%E6%8F%92%E5%9C%86%E6%B8%B8%E6%88%8F/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240711135733.png" alt="微信截图_20240711135733"></p>
<h2><span id="3新圆不和已有圆相交">3.新圆不和已有圆相交</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;conio.h&gt;</span><br><span class="line">#include&lt;graphics.h&gt;</span><br><span class="line">#include&lt;time.h&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">//求解两个点之间的距离</span><br><span class="line">float Dist(float x1, float y1, float x2, float y2) &#123;</span><br><span class="line">	float result;</span><br><span class="line">	result = sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));</span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//判断两个圆是否相交</span><br><span class="line">int xiangjiao(float x1, float y1, float r1,float x2, float y2,float r2) &#123;</span><br><span class="line">	if (Dist(x1, y1, x2, y2) &lt; r1 + r2) return 1;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//生成随机整数</span><br><span class="line">int randbetween(int min, int max) &#123;</span><br><span class="line">	int r = rand() % (max - min + 1) + min;</span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int width = 600;</span><br><span class="line">	int height = 600;</span><br><span class="line">	initgraph(width, height);</span><br><span class="line">	setbkcolor(WHITE);</span><br><span class="line">	cleardevice();</span><br><span class="line">	srand(time(0));</span><br><span class="line"></span><br><span class="line">	int xarray[100];</span><br><span class="line">	int yarray[100];</span><br><span class="line">	int rarray[100];</span><br><span class="line">	int rmin = 8;</span><br><span class="line">	int rmax = 50;</span><br><span class="line">	int circlenum = 0;</span><br><span class="line">	float x, y, r;//新增圆的属性</span><br><span class="line">	int isnewcircleOK;//用于判断新生成的圆是否满足条件</span><br><span class="line">	int i = 0;</span><br><span class="line">	</span><br><span class="line">	while(circlenum&lt;100)&#123;</span><br><span class="line">		isnewcircleOK = 0;</span><br><span class="line">		while (isnewcircleOK == 0) &#123;</span><br><span class="line">			x = rand() % width;</span><br><span class="line">			y = rand() % height;</span><br><span class="line">			r = randbetween(rmin, rmax);</span><br><span class="line">		</span><br><span class="line">		for (i = 0; i &lt; circlenum; i++)</span><br><span class="line">			if (xiangjiao(xarray[i], yarray[i], rarray[i], x, y, r)) break;</span><br><span class="line">		if (i == circlenum) isnewcircleOK = 1;</span><br><span class="line">	     &#125;</span><br><span class="line">		xarray[circlenum] = x;</span><br><span class="line">		yarray[circlenum] = y;</span><br><span class="line">		rarray[circlenum] = r;</span><br><span class="line">		circlenum++;</span><br><span class="line">	</span><br><span class="line">		setlinecolor(RED);</span><br><span class="line">		setfillcolor(YELLOW);</span><br><span class="line">		fillcircle(x,y,r);</span><br><span class="line">	</span><br><span class="line">		Sleep(10);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	_getch();</span><br><span class="line">	closegraph();</span><br><span class="line">	return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/10/%E8%A7%81%E7%BC%9D%E6%8F%92%E5%9C%86%E6%B8%B8%E6%88%8F/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240711142536.png" alt="微信截图_20240711142536"></p>
<h2><span id="4新圆半径最大化">4.新圆半径最大化</span></h2><p><code>while(circlenum&lt;100)&#123;</code><br>    <code>isnewcircleOK = 0;</code><br>    <code>while (isnewcircleOK == 0) &#123;</code><br>        <code>x = rand() % width;</code><br>        <code>y = rand() % height;</code><br>        <code>r = rmin;//新圆的半径开始设置为最小半径</code></p>
<p><code>for (i = 0; i &lt; circlenum; i++)</code><br>    <code>if (xiangjiao(xarray[i], yarray[i], rarray[i], x, y, r)) break;</code><br><code>if (i == circlenum) isnewcircleOK = 1;</code><br> <code>&#125;</code></p>
<p><code>isnewcircleOK = 0;//继续设置为不ok，接下来要让这个新圆的半径最大</code><br><code>while (isnewcircleOK == 0 &amp;&amp; r &lt; rmax) &#123;</code><br>    <code>r++;</code><br>    <code>for (int j = 0; j &lt; circlenum; j++) &#123;</code><br>        <code>if (xiangjiao(xarray[i], yarray[i], rarray[i], x, y, r)) &#123;</code><br>            <code>isnewcircleOK = 1;</code><br>            <code>break;</code><br>        <code>&#125;</code><br>    <code>&#125;</code><br><code>&#125;</code></p>
<p><img src="/2024/07/10/%E8%A7%81%E7%BC%9D%E6%8F%92%E5%9C%86%E6%B8%B8%E6%88%8F/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240711143335.png" alt="微信截图_20240711143335"></p>
]]></content>
      <tags>
        <tag>C++_EasyX 项目</tag>
      </tags>
  </entry>
  <entry>
    <title>绘制”旋转蛇“错觉</title>
    <url>/2024/07/09/%E7%BB%98%E5%88%B6%E2%80%9D%E6%97%8B%E8%BD%AC%E8%9B%87%E2%80%9C%E9%94%99%E8%A7%89/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#1%E7%BB%98%E5%88%B6%E6%89%87%E5%BD%A2">1.绘制扇形</a></li>
<li><a href="#2rgb%E9%A2%9C%E8%89%B2%E6%A8%A1%E5%9E%8B">2.RGB颜色模型</a></li>
<li><a href="#3%E7%BB%98%E5%88%B6%E4%B8%80%E4%B8%AA%E6%89%87%E5%BD%A2%E5%8D%95%E5%85%83">3.绘制一个扇形单元</a></li>
<li><a href="#4%E5%BE%AA%E7%8E%AF%E5%B5%8C%E5%A5%97">4.循环嵌套</a></li>
<li><a href="#5%E5%A4%9A%E4%B8%AA%E5%9C%86%E7%9B%98">5.多个圆盘</a></li>
<li><a href="#6hsv%E9%A2%9C%E8%89%B2%E6%A8%A1%E5%9E%8B">6.HSV颜色模型</a></li>
<li><a href="#7%E5%85%A8%E9%83%A8%E4%BB%A3%E7%A0%81">7.全部代码</a></li>
</ul>
<!-- tocstop -->

<p>[TOC]</p>
<h2><span id="1绘制扇形">1.绘制扇形</span></h2><p>函数solidpie(left,top,right,bottom,stangle,endangle)可以绘制无边框的填充扇形。</p>
<p>其中，stangle是扇形的起初角，endangle是终止角，角度单位为弧度。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;graphics.h&gt;</span><br><span class="line">#include&lt;conio.h&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">	float PI = 3.14159;//圆周率</span><br><span class="line">	initgraph(600, 600);//打开一个窗口</span><br><span class="line">	int centerX = 300;//圆心坐标</span><br><span class="line">	int centerY = 300;</span><br><span class="line">	int radius = 200;//圆半径</span><br><span class="line">	circle(centerX, centerY, radius);//画出圆边框</span><br><span class="line">	int left = centerX - radius;</span><br><span class="line">	int top = centerY - radius;</span><br><span class="line">	int right = centerX + radius;</span><br><span class="line">	int bottom = centerY + radius;</span><br><span class="line">	solidpie(left, top, right, bottom, PI / 6, PI / 3);//画填充扇形，角度为PI/6到PI/3</span><br><span class="line">	_getch();</span><br><span class="line">	closegraph();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/09/%E7%BB%98%E5%88%B6%E2%80%9D%E6%97%8B%E8%BD%AC%E8%9B%87%E2%80%9C%E9%94%99%E8%A7%89/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240709215127.png" alt="微信截图_20240709215127"></p>
<h2><span id="2rgb颜色模型">2.RGB颜色模型</span></h2><p>EasyX可以设置绘图颜色（要先设置颜色，再绘图）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setbkcolor(WHITE);//设置背景颜色为白色</span><br><span class="line">setlinecolor(RED);//设置线条为红色</span><br><span class="line">setfillcolor(GREEN);//设置填充颜色为绿色</span><br><span class="line">cleardevice();//以背景颜色清空画布</span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/09/%E7%BB%98%E5%88%B6%E2%80%9D%E6%97%8B%E8%BD%AC%E8%9B%87%E2%80%9C%E9%94%99%E8%A7%89/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240709215600.png" alt="微信截图_20240709215600"></p>
<h2><span id="3绘制一个扇形单元">3.绘制一个扇形单元</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;graphics.h&gt;</span><br><span class="line">#include&lt;conio.h&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">	float PI = 3.14159;//圆周率</span><br><span class="line"></span><br><span class="line">	initgraph(600, 600);//打开一个窗口</span><br><span class="line">	setbkcolor(RGB(128, 128, 128));//设置背景颜色为灰色</span><br><span class="line">	cleardevice();//以背景颜色清空画布</span><br><span class="line">	</span><br><span class="line">	int centerX = 300;//圆心坐标</span><br><span class="line">	int centerY = 300;</span><br><span class="line">	int radius = 200;//圆半径</span><br><span class="line">	circle(centerX, centerY, radius);//画出圆边框</span><br><span class="line">	int left = centerX - radius;</span><br><span class="line">	int top = centerY - radius;</span><br><span class="line">	int right = centerX + radius;</span><br><span class="line">	int bottom = centerY + radius;</span><br><span class="line">	</span><br><span class="line">	int i;</span><br><span class="line">	float offset;</span><br><span class="line">	for (i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">		offset = i * PI / 10;//各组扇形之间的偏移的角度</span><br><span class="line">		setfillcolor(GREEN);</span><br><span class="line">		solidpie(left, top, right, bottom,offset, 2 * PI / 60 + offset);//画填充扇形</span><br><span class="line">		setfillcolor(WHITE);</span><br><span class="line">		solidpie(left, top, right, bottom, 2 * PI / 60 + offset, 3 * PI / 60 + offset);//画填充扇形</span><br><span class="line">		setfillcolor(RED);</span><br><span class="line">		solidpie(left, top, right, bottom, 3 * PI / 60 + offset, 5 * PI / 60 + offset);//画填充扇形</span><br><span class="line">		setfillcolor(BLUE);</span><br><span class="line">		solidpie(left, top, right, bottom, 5 * PI / 60 + offset, 6 * PI / 60 + offset);//画填充扇形</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	_getch();</span><br><span class="line">	closegraph();</span><br><span class="line">	return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/09/%E7%BB%98%E5%88%B6%E2%80%9D%E6%97%8B%E8%BD%AC%E8%9B%87%E2%80%9C%E9%94%99%E8%A7%89/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240709220912.png" alt="微信截图_20240709220912"></p>
<h2><span id="4循环嵌套">4.循环嵌套</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;graphics.h&gt;</span><br><span class="line">#include&lt;conio.h&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">	float PI = 3.14159;//圆周率</span><br><span class="line"></span><br><span class="line">	initgraph(600, 600);//打开一个窗口</span><br><span class="line">	setbkcolor(RGB(128, 128, 128));//设置背景颜色为灰色</span><br><span class="line">	cleardevice();//以背景颜色清空画布</span><br><span class="line">	</span><br><span class="line">	int centerX = 300;//圆心坐标</span><br><span class="line">	int centerY = 300;</span><br><span class="line">	int radius = 200;//圆半径</span><br><span class="line">	circle(centerX, centerY, radius);//画出圆边框</span><br><span class="line">	</span><br><span class="line">	int i;</span><br><span class="line">	float offset;//同一半径各组扇形之间的偏移的角度</span><br><span class="line">	float totaloffset = 0;//不同半径之间的角度偏移量</span><br><span class="line">	for (radius = 200; radius &gt; 0; radius = radius - 50) &#123;//半径从小到大绘制</span><br><span class="line">		int left = centerX - radius;</span><br><span class="line">		int top = centerY - radius;</span><br><span class="line">		int right = centerX + radius;</span><br><span class="line">		int bottom = centerY + radius;</span><br><span class="line">		for (i = 0; i &lt; 20; i++) &#123;//旋转一周，绘制扇形区域</span><br><span class="line">			offset = i * PI / 10 + totaloffset;</span><br><span class="line">			setfillcolor(GREEN);</span><br><span class="line">			solidpie(left, top, right, bottom, offset, 2 * PI / 60 + offset);//画填充扇形</span><br><span class="line">			setfillcolor(WHITE);</span><br><span class="line">			solidpie(left, top, right, bottom, 2 * PI / 60 + offset, 3 * PI / 60 + offset);//画填充扇形</span><br><span class="line">			setfillcolor(RED);</span><br><span class="line">			solidpie(left, top, right, bottom, 3 * PI / 60 + offset, 5 * PI / 60 + offset);//画填充扇形</span><br><span class="line">			setfillcolor(BLUE);</span><br><span class="line">			solidpie(left, top, right, bottom, 5 * PI / 60 + offset, 6 * PI / 60 + offset);//画填充扇形</span><br><span class="line">		&#125;</span><br><span class="line">		totaloffset = totaloffset + PI / 20;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	_getch();</span><br><span class="line">	closegraph();</span><br><span class="line">	return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/09/%E7%BB%98%E5%88%B6%E2%80%9D%E6%97%8B%E8%BD%AC%E8%9B%87%E2%80%9C%E9%94%99%E8%A7%89/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240710112241.png" alt="微信截图_20240710112241"></p>
<h2><span id="5多个圆盘">5.多个圆盘</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (centerX - 200; centerX &lt; 1200; centerX = centerX + 400) &#123;</span><br><span class="line">		for (centerY = 200; centerY &lt; 800; centerY = centerY + 400) &#123;</span><br><span class="line">			for (radius = 200; radius &gt; 0; radius = radius - 50) &#123;//半径从小到大绘制</span><br><span class="line">				int left = centerX - radius;</span><br><span class="line">				int top = centerY - radius;</span><br><span class="line">				int right = centerX + radius;</span><br><span class="line">				int bottom = centerY + radius;</span><br><span class="line">				for (i = 0; i &lt; 20; i++) &#123;//旋转一周，绘制扇形区域</span><br><span class="line">					offset = i * PI / 10 + totaloffset;</span><br><span class="line">					setfillcolor(GREEN);</span><br><span class="line">					solidpie(left, top, right, bottom, offset, 2 * PI / 60 + offset);//画填充扇形</span><br><span class="line">					setfillcolor(WHITE);</span><br><span class="line">					solidpie(left, top, right, bottom, 2 * PI / 60 + offset, 3 * PI / 60 + offset);//画填充扇形</span><br><span class="line">					setfillcolor(RED);</span><br><span class="line">					solidpie(left, top, right, bottom, 3 * PI / 60 + offset, 5 * PI / 60 + offset);//画填充扇形</span><br><span class="line">					setfillcolor(BLUE);</span><br><span class="line">					solidpie(left, top, right, bottom, 5 * PI / 60 + offset, 6 * PI / 60 + offset);//画填充扇形</span><br><span class="line">				&#125;</span><br><span class="line">				totaloffset = totaloffset + PI / 20;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/09/%E7%BB%98%E5%88%B6%E2%80%9D%E6%97%8B%E8%BD%AC%E8%9B%87%E2%80%9C%E9%94%99%E8%A7%89/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240710112926.png" alt="微信截图_20240710112926"></p>
<h2><span id="6hsv颜色模型">6.HSV颜色模型</span></h2><p><img src="/2024/07/09/%E7%BB%98%E5%88%B6%E2%80%9D%E6%97%8B%E8%BD%AC%E8%9B%87%E2%80%9C%E9%94%99%E8%A7%89/7bf1ea45469a405eba4aef2d57781387.jpg" alt="7bf1ea45469a405eba4aef2d57781387"></p>
<p>在HSV模型中，颜色是由<strong>色度</strong>（Hue），<strong>饱和度</strong>（Saturation），<strong>明度</strong>（Value）共同组成</p>
<p><img src="/2024/07/09/%E7%BB%98%E5%88%B6%E2%80%9D%E6%97%8B%E8%BD%AC%E8%9B%87%E2%80%9C%E9%94%99%E8%A7%89/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240710113808.png" alt="微信截图_20240710113808"></p>
<p>COLORREFN color;&#x2F;&#x2F;定义颜色变量</p>
<p>color &#x3D; HSVtoRGB(1,1,1);&#x2F;&#x2F;HSV设置的颜色</p>
<p>setfillcolor(color);&#x2F;&#x2F;设置填充颜色为color</p>
<h2><span id="7全部代码">7.全部代码</span></h2><p>使用srand(time(0))表示用当前时间对随机函数初始化，必须添加头文件#include&lt;time.h&gt;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;graphics.h&gt;</span><br><span class="line">#include&lt;conio.h&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;time.h&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">	float PI = 3.14159;//圆周率</span><br><span class="line"></span><br><span class="line">	initgraph(1600, 800);//打开一个窗口</span><br><span class="line">	setbkcolor(RGB(128, 128, 128));//设置背景颜色为灰色</span><br><span class="line">	cleardevice();//以背景颜色清空画布</span><br><span class="line">	srand(time(0));//随机种子函数</span><br><span class="line">	</span><br><span class="line">	int centerX = 300;//圆心坐标</span><br><span class="line">	int centerY = 300;</span><br><span class="line">	int radius = 200;//圆半径</span><br><span class="line">	</span><br><span class="line">	int i;</span><br><span class="line">	float offset;//同一半径各组扇形之间的偏移的角度</span><br><span class="line">	float totaloffset = 0;//不同半径之间的角度偏移量</span><br><span class="line">	for (centerX - 200; centerX &lt; 1200; centerX = centerX + 400) &#123;</span><br><span class="line">		for (centerY = 200; centerY &lt; 800; centerY = centerY + 400) &#123;</span><br><span class="line">			float h = rand() % 180;//随机色调</span><br><span class="line">			COLORREF color1 = HSVtoRGB(h, 0.9, 0.8);//色调1生成的颜色1</span><br><span class="line">			COLORREF color2 = HSVtoRGB(h + 180, 0.9, 0.8);//色调2生成的颜色2</span><br><span class="line">			for (radius = 200; radius &gt; 0; radius = radius - 50) &#123;//半径从小到大绘制</span><br><span class="line">				int left = centerX - radius;</span><br><span class="line">				int top = centerY - radius;</span><br><span class="line">				int right = centerX + radius;</span><br><span class="line">				int bottom = centerY + radius;</span><br><span class="line">				for (i = 0; i &lt; 20; i++) &#123;//旋转一周，绘制扇形区域</span><br><span class="line">					offset = i * PI / 10 + totaloffset;</span><br><span class="line">					setfillcolor(color1);</span><br><span class="line">					solidpie(left, top, right, bottom, offset, 2 * PI / 60 + offset);//画填充扇形</span><br><span class="line">					setfillcolor(WHITE);</span><br><span class="line">					solidpie(left, top, right, bottom, 2 * PI / 60 + offset, 3 * PI / 60 + offset);//画填充扇形</span><br><span class="line">					setfillcolor(color2);</span><br><span class="line">					solidpie(left, top, right, bottom, 3 * PI / 60 + offset, 5 * PI / 60 + offset);//画填充扇形</span><br><span class="line">					setfillcolor(BLUE);</span><br><span class="line">					solidpie(left, top, right, bottom, 5 * PI / 60 + offset, 6 * PI / 60 + offset);//画填充扇形</span><br><span class="line">				&#125;</span><br><span class="line">				totaloffset = totaloffset + PI / 20;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	_getch();</span><br><span class="line">	closegraph();</span><br><span class="line">	return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/09/%E7%BB%98%E5%88%B6%E2%80%9D%E6%97%8B%E8%BD%AC%E8%9B%87%E2%80%9C%E9%94%99%E8%A7%89/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240710180813.png" alt="微信截图_20240710180813"></p>
]]></content>
      <tags>
        <tag>C++_EasyX 项目</tag>
      </tags>
  </entry>
  <entry>
    <title>高等数学下笔记</title>
    <url>/2024/03/25/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#8-%E5%90%91%E9%87%8F%E4%BB%A3%E6%95%B0%E4%B8%8E%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95">8 - 向量代数与空间解析几何</a><ul>
<li><a href="#8-1-%E5%90%91%E9%87%8F%E5%8F%8A%E5%85%B6%E7%BA%BF%E6%80%A7%E8%BF%90%E7%AE%97">8-1 向量及其线性运算</a></li>
<li><a href="#8-2-%E7%A9%BA%E9%97%B4%E7%9B%B4%E8%A7%92%E5%9D%90%E6%A0%87%E7%B3%BB">8-2 空间直角坐标系</a></li>
<li><a href="#8-3-%E5%90%91%E9%87%8F%E7%9A%84%E7%BB%BC%E5%90%88%E6%80%A7%E8%B4%A8%E5%92%8C%E8%BF%90%E7%AE%97">8-3 向量的综合性质和运算</a></li>
<li><a href="#8-4-%E6%95%B0%E9%87%8F%E7%A7%AF-%E5%90%91%E9%87%8F%E7%A7%AF">8-4 数量积、向量积</a></li>
<li><a href="#8-5-%E5%B9%B3%E9%9D%A2%E5%8F%8A%E5%85%B6%E6%96%B9%E7%A8%8B">8-5 平面及其方程</a></li>
<li><a href="#8-6-%E7%A9%BA%E9%97%B4%E7%9B%B4%E7%BA%BF%E5%8F%8A%E5%85%B6%E6%96%B9%E7%A8%8B">8-6 空间直线及其方程</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<p>[TOC]</p>
<h2><span id="8-向量代数与空间解析几何">8 - 向量代数与空间解析几何</span></h2><h3><span id="8-1-向量及其线性运算">8-1 向量及其线性运算</span></h3><p>1.由三角形两边之和大于第三边，有：|<strong>a</strong> + <strong>b</strong>|&lt;&#x3D;|<strong>a</strong>|+|<strong>b</strong>|; |<strong>a</strong> - <strong>b</strong>|&lt;&#x3D;|<strong>a</strong>|+|<strong>b</strong>|</p>
<p>2.数乘：|λ<strong>a</strong>| &#x3D; |λ||<strong>a</strong>|</p>
<p>3.单位向量<strong>e</strong>&#x3D;<strong>a</strong>&#x2F;|<strong>a</strong>|</p>
<p>4.<strong>a</strong>&#x2F;&#x2F;<strong>b</strong>等价于<strong>b</strong>&#x3D;λ<strong>a</strong>（<strong>a</strong>!&#x3D;0）</p>
<h3><span id="8-2-空间直角坐标系">8-2 空间直角坐标系</span></h3><img src="/2024/03/25/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8B%E7%AC%94%E8%AE%B0/be8b438d8dab4f26425537c8e52ffa4.png" alt="be8b438d8dab4f26425537c8e52ffa4" style="zoom:80%;">

<img src="/2024/03/25/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8B%E7%AC%94%E8%AE%B0/ed720f4486e49cb4f94f47c876630bf.png" alt="ed720f4486e49cb4f94f47c876630bf" style="zoom:80%;">

<p>向量OF（x，y，z）是点O关于点F的向径，<u>求点F的坐标就是求向量OP的坐标</u></p>
<p>①若点F在yoz面上，x&#x3D;0；</p>
<p>②点F在zox面上，y&#x3D;0；点F在xoy面上，z&#x3D;0；</p>
<p>③点F在x轴上，y&#x3D;z&#x3D;0；</p>
<p>④点F在y轴上，z&#x3D;x&#x3D;0；点F在z轴上，x&#x3D;y&#x3D;0；</p>
<p>⑤点F为原点，x&#x3D;y&#x3D;z&#x3D;0。</p>
<h3><span id="8-3-向量的综合性质和运算">8-3 向量的综合性质和运算</span></h3><img src="/2024/03/25/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8B%E7%AC%94%E8%AE%B0/微信截图_20240326011004.png" alt="微信截图_20240326011004" style="zoom:80%;">

<h4><span id="题型"><strong>题型：</strong></span></h4><h5><span id="1向量模的坐标表达式">1.向量模的坐标表达式</span></h5><h5><span id="2两点距离公式">2.两点距离公式：</span></h5><p>求证三角形的类型（等腰、直角、等边）</p>
<p>求已知向量的定向单位向量</p>
<p>求与某几点等距离的点</p>
<h5><span id="3方向角与方向余弦">3.方向角与方向余弦：</span></h5><p>已知角度求点的坐标</p>
<p>已知向量求方向角、余弦和模</p>
<h5><span id="4投影">4.投影</span></h5><p>已知向量求向量在某轴上的投影</p>
<p>已知投影求向量</p>
<h3><span id="8-4-数量积-向量积">8-4 数量积、向量积</span></h3><img src="/2024/03/25/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8B%E7%AC%94%E8%AE%B0/微信截图_20240326013200.png" alt="微信截图_20240326013200" style="zoom:80%;">

<h4><span id="题型"><strong>题型</strong>：</span></h4><p>1.用数量积公式求夹角、投影</p>
<p>2.用向量积求三角形面积（用到正弦）</p>
<p>3.用数量积、向量积定义证垂直或平行</p>
<p>4.（多用）用向量积求平面方程</p>
<h3><span id="8-5-平面及其方程">8-5 平面及其方程</span></h3><h4><span id="1平面的点法式方程">1.平面的点法式方程</span></h4><p><strong>A（x-x₀）+B（y-y₀）+C（z-z₀）&#x3D;0</strong></p>
<p>其中<strong>n</strong>&#x3D;（A,B,C），M₀&#x3D;（x₀，y₀，z₀）</p>
<h4><span id="2平面的一般方程">2.平面的一般方程</span></h4><p><strong>Ax0 + By0 + Cz0 +D&#x3D;0</strong></p>
<p><strong>n</strong>&#x3D;（A,B,C）</p>
<p>①<strong>D&#x3D;0</strong>时，方程表示一个通过<strong>原点</strong>的平面</p>
<p>②<strong>A&#x3D;0</strong>时，<strong>n</strong>垂直于x轴，方程表示一个平行于（或包含）<strong>x轴</strong>的平面；<strong>B&#x3D;0，C&#x3D;0</strong>同理</p>
<p>③<strong>A&#x3D;B&#x3D;0</strong>，<strong>n</strong>同时垂直x轴和y轴，方程表示一个平行于（或重合）<strong>x0y面</strong>的平面；<strong>A&#x3D;C&#x3D;0,B&#x3D;C&#x3D;0</strong>同理</p>
<h4><span id="3平面的截距式方程">3.平面的截距式方程</span></h4><p><strong>x&#x2F;a + y&#x2F;b + z&#x2F;c &#x3D; 1</strong></p>
<p>a、b、c分别是平面在xyz轴上的截距</p>
<h4><span id="4两平面夹角-点到平面距离">4.两平面夹角、点到平面距离</span></h4><p><strong>两平面互相垂直</strong>相当于<strong>A₁A₂ + B₁B₂ + C₁C₂ &#x3D; 0</strong></p>
<p><strong>两平面互相平行或重合</strong>相当于<strong>A₁&#x2F;A₂ &#x3D; B₁&#x2F;B₂ &#x3D; C₁&#x2F;C₂</strong></p>
<img src="/2024/03/25/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8B%E7%AC%94%E8%AE%B0/微信截图_20240326015143.png" alt="微信截图_20240326015143" style="zoom:80%;">



<h3><span id="8-6-空间直线及其方程">8-6 空间直线及其方程</span></h3><h4><span id="1直线的点向式方程对称式方程">1.直线的点向式方程（对称式方程）</span></h4><p>其中，<strong>s</strong>&#x3D;(m,n,p)，M₀&#x3D;(x₀,y₀,z₀)</p>
<p>要素：①方向向量 ②点</p>
<h4><span id="2直线的参数方程">2.直线的参数方程</span></h4><h4><span id="3直线的一般方程">3.直线的一般方程</span></h4><p>表现为两个平面的交线</p>
<h4><span id="4线面角">4.线面角</span></h4><p>范围是【0，90°】</p>
<img src="/2024/03/25/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8B%E7%AC%94%E8%AE%B0/微信截图_20240326015259.png" alt="微信截图_20240326015259" style="zoom:80%;">

<h4><span id="5线线角">5.线线角</span></h4><p>和面面角公式相同，用cos</p>
<h4><span id="6性质">6.性质</span></h4><p><strong>两直线相互垂直（包括异面、相交）</strong>相当于 <strong>m₁m₂ + n₁n₂ + p₁p₂ &#x3D; 0</strong></p>
<p><strong>两直线互相平行或重合</strong> 相当于 <strong>m₁&#x2F;m₂ &#x3D; n₁&#x2F;n₂ &#x3D; p₁&#x2F;p₂</strong></p>
<p><strong>直线与平面平行或直线在平面上</strong> 相当于 <strong>Am + Bn + Cp &#x3D;0</strong></p>
]]></content>
      <tags>
        <tag>高等数学</tag>
      </tags>
  </entry>
  <entry>
    <title>tag</title>
    <url>/tag/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
