<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>c++队列queue用法</title>
    <url>/2024/05/26/c-%E9%98%9F%E5%88%97queue%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#%E5%AE%9A%E4%B9%89">定义</a></li>
<li><a href="#%E4%B8%80-queue%E5%88%9D%E5%A7%8B%E5%8C%96">一、queue初始化</a></li>
<li><a href="#%E4%BA%8C-queue%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0">二、queue常用函数</a><ul>
<li><a href="#1%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0">1.常用函数</a></li>
<li><a href="#2%E5%87%BD%E6%95%B0%E8%BF%90%E7%94%A8%E7%A4%BA%E4%BE%8B">2.函数运用示例</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<p>[TOC]</p>
<h2><span id="定义">定义</span></h2><p>queue是一种容器转换器模板，调用#include&lt; queue&gt;即可使用队列类。</p>
<h2><span id="一-queue初始化">一、queue初始化</span></h2><p>queue&lt;Type, Container&gt; (&lt;数据类型，容器类型&gt;）<br>初始化时必须要有数据类型，容器可省略，省略时则默认为deque 类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">queue&lt;int&gt;q1;</span><br><span class="line"></span><br><span class="line">queue&lt;double&gt;q2; </span><br><span class="line"></span><br><span class="line">queue＜char＞q3；</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">queue＜char, list＜char＞＞q1；</span><br><span class="line">//用list容器实现的queue </span><br><span class="line"></span><br><span class="line">queue＜int, deque＜int＞＞q2；</span><br><span class="line"> //用deque容器实现的queue </span><br></pre></td></tr></table></figure>

<h2><span id="二-queue常用函数">二、queue常用函数</span></h2><h3><span id="1常用函数">1.常用函数</span></h3><ol>
<li>push() 在队尾插入一个元素</li>
<li>pop() 删除队列第一个元素</li>
<li>size() 返回队列中元素个数</li>
<li>empty() 如果队列空则返回true</li>
<li>front() 返回队列中的第一个元素</li>
<li>back() 返回队列中最后一个元素</li>
</ol>
<h3><span id="2函数运用示例">2.函数运用示例</span></h3><h4><span id="1push在队尾插入一个元素">（1）<strong>push（）在队尾插入一个元素</strong></span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">queue &lt;string&gt; q;</span><br><span class="line">   q.push(&quot;first&quot;);</span><br><span class="line">   q.push(&quot;second&quot;);</span><br><span class="line">   cout&lt;&lt;q.front()&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p>输出 first</p>
<h4><span id="2pop-将队列中最靠前位置的元素删除没有返回值">（2）<strong>pop() 将队列中最靠前位置的元素删除，没有返回值</strong></span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">queue &lt;string&gt; q;</span><br><span class="line">	q.push(&quot;first&quot;);</span><br><span class="line">	q.push(&quot;second&quot;);</span><br><span class="line">	q.pop();</span><br><span class="line">	cout&lt;&lt;q.front()&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p>输出 second</p>
<h4><span id="3size-返回队列中元素个数">（3）<strong>size() 返回队列中元素个数</strong></span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">queue &lt;string&gt; q;</span><br><span class="line">  q.push(&quot;first&quot;);</span><br><span class="line">  q.push(&quot;second&quot;);</span><br><span class="line">  cout&lt;&lt;q.size()&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p>输出2</p>
<h4><span id="4empty-如果队列空则返回true">（4）<strong>empty() 如果队列空则返回true</strong></span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">queue &lt;string&gt; q;</span><br><span class="line">    cout&lt;&lt;q.empty()&lt;&lt;endl;</span><br><span class="line">    q.push(&quot;first&quot;);</span><br><span class="line">    q.push(&quot;second&quot;);</span><br><span class="line">    cout&lt;&lt;q.empty()&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p>分别输出1和0</p>
<h4><span id="5front-返回队列中的第一个元素">（5）<strong>front() 返回队列中的第一个元素</strong></span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">queue &lt;string&gt; q;</span><br><span class="line">    q.push(&quot;first&quot;);</span><br><span class="line">    q.push(&quot;second&quot;);</span><br><span class="line">    cout&lt;&lt;q.front()&lt;&lt;endl;</span><br><span class="line">    q.pop();</span><br><span class="line">    cout&lt;&lt;q.front()&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p>第一行输出first；<br>第二行输出second</p>
<h4><span id="6back-返回队列中最后一个元素">（6）<strong>back() 返回队列中最后一个元素</strong></span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">queue &lt;string&gt; q;</span><br><span class="line">q.push(&quot;first&quot;);</span><br><span class="line">q.push(&quot;second&quot;);</span><br><span class="line">cout&lt;&lt;q.back()&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p>输出最后一个元素second</p>
]]></content>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>控制角色移动</title>
    <url>/2024/03/19/unity-%E6%8E%A7%E5%88%B6%E8%A7%92%E8%89%B2%E7%A7%BB%E5%8A%A8/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line">//控制角色移动、生命、动画等</span><br><span class="line">public class NewBehaviourScript : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    public float speed = 5f;//移动速度</span><br><span class="line">    // Start is called before the first frame update</span><br><span class="line">    void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Update is called once per frame</span><br><span class="line">void Update()</span><br><span class="line">&#123;</span><br><span class="line">    float moveX = Input.GetAxisRaw(&quot;Horizontal&quot;);//控制水平方向移动，A：-1，D：1,0</span><br><span class="line">    float moveY = Input.GetAxisRaw(&quot;Vertical&quot;);//控制垂直方向W1 S-1 0</span><br><span class="line"></span><br><span class="line">    Vector2 position = transform.position;</span><br><span class="line">    position.x +=moveX * speed * Time.deltaTime;</span><br><span class="line">    position.y +=moveY * speed * Time.deltaTime;</span><br><span class="line">    transform.position = position;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>unity2d</tag>
      </tags>
  </entry>
  <entry>
    <title>stack容器基本知识</title>
    <url>/2024/04/03/stack%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>写作业的时候看到有人用stack容器做题，试了下效率起飞，二话不说记录一下XD</p>
<!-- toc -->

<ul>
<li><a href="#1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">1.基础知识</a><ul>
<li><a href="#%E5%A4%B4%E6%96%87%E4%BB%B6"><strong>头文件</strong></a></li>
<li><a href="#%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><strong>常用操作</strong></a></li>
<li><a href="#stack%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0">stack对象的默认构造</a></li>
<li><a href="#stack%E7%9A%84%E5%87%BA%E6%A0%88%E5%92%8C%E8%BF%9B%E6%A0%88">stack的出栈和进栈</a></li>
<li><a href="#stack%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E4%B8%8E%E8%B5%8B%E5%80%BC">stack的拷贝构造与赋值</a></li>
<li><a href="#stack%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96">stack的数据存取</a></li>
<li><a href="#stack%E7%9A%84%E5%A4%A7%E5%B0%8F">stack的大小</a></li>
</ul>
</li>
<li><a href="#2%E4%BE%8B%E9%A2%98">2.例题</a><ul>
<li><a href="#7-2-%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D"><strong>7-2 括号匹配</strong></a></li>
<li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">代码实现</a></li>
<li><a href="#7-3-%E5%9B%9E%E6%96%87%E5%88%A4%E6%96%AD"><strong>7-3 回文判断</strong></a></li>
<li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1">代码实现</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<p>[TOC]</p>
<h2><span id="1基础知识">1.基础知识</span></h2><h3><span id="头文件"><strong>头文件</strong></span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stack&gt;</span><br></pre></td></tr></table></figure>



<h3><span id="常用操作"><strong>常用操作</strong></span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stack&lt;int&gt; q;	//以int型为例</span><br><span class="line">int x;</span><br><span class="line">q.push(x);		//将x压入栈顶</span><br><span class="line">q.top();		//返回栈顶的元素</span><br><span class="line">q.pop();		//删除栈顶的元素</span><br><span class="line">q.size();		//返回栈中元素的个数</span><br><span class="line">q.empty();		//检查栈是否为空,若为空返回true,否则返回false</span><br></pre></td></tr></table></figure>

<h3><span id="stack对象的默认构造">stack对象的默认构造</span></h3><p>stack对象的默认构造形式： stack <t> stkT;  </t></p>
<p>尖括号里面还可以设置指针或者其他数据类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stack &lt;int&gt; stkInt;            //一个存放int的stack容器。</span><br><span class="line"></span><br><span class="line">stack &lt;float&gt; stkFloat;     //一个存放float的stack容器。</span><br><span class="line"></span><br><span class="line">stack &lt;string&gt; stkString;     //一个存放string的stack容器。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3><span id="stack的出栈和进栈">stack的出栈和进栈</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stack.push(elem);            //往栈头添加元素</span><br><span class="line"></span><br><span class="line">stack.pop();                     //往栈头移除第一个元素</span><br></pre></td></tr></table></figure>

<h3><span id="stack的拷贝构造与赋值">stack的拷贝构造与赋值</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stack(const stack &amp;stk);                  //拷贝构造函数</span><br><span class="line"></span><br><span class="line">stack&amp; operator = (const stack &amp;stk);          //重载等号操作符</span><br><span class="line"></span><br><span class="line">stack&lt;int&gt;stkIntB(stkIntA);            //拷贝构造</span><br><span class="line">stack&lt;int&gt;stkIntC;</span><br><span class="line">stkIntC = stkIntA;                     //赋值</span><br></pre></td></tr></table></figure>

<h3><span id="stack的数据存取">stack的数据存取</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stack.top();     //返回最后一个压入栈元素</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stack&lt;int&gt; stkIntA;</span><br><span class="line"></span><br><span class="line">stkIntA.push(1);</span><br><span class="line"></span><br><span class="line">stkIntA.push(3);</span><br><span class="line"></span><br><span class="line">stkIntA.push(5);</span><br><span class="line"></span><br><span class="line">stkIntA.push(7);</span><br><span class="line"></span><br><span class="line">stkIntA.push(9);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">int iTop = stkIntA.top(); //9</span><br><span class="line"></span><br><span class="line">stkIntA.top() = 19; //19</span><br></pre></td></tr></table></figure>

<h3><span id="stack的大小">stack的大小</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stack.empty();                    //判断堆栈是否为空</span><br><span class="line"></span><br><span class="line">stack.size();                        //返回堆栈的大小</span><br></pre></td></tr></table></figure>



<h2><span id="2例题">2.例题</span></h2><h3><span id="7-2-括号匹配"><strong>7-2 括号匹配</strong></span></h3><p>给定一串字符，不超过100个字符，可能包括括号、数字、字母、标点符号、空格，编程检查这一串字符中的( ) ,[ ],{ }是否匹配。</p>
<p><strong>输入格式:</strong></p>
<p>输入在一行中给出一行字符串，不超过100个字符，可能包括括号、数字、字母、标点符号、空格。</p>
<p><strong>输出格式:</strong></p>
<p>如果括号配对，输出yes，否则输出no。</p>
<p><strong>输入样例1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sin(10+20)</span><br></pre></td></tr></table></figure>

<p><strong>输出样例1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yes</span><br></pre></td></tr></table></figure>

<p><strong>输入样例2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;[&#125;]</span><br></pre></td></tr></table></figure>

<p><strong>输出样例2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">no</span><br></pre></td></tr></table></figure>

<p><strong>输入样例3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(()())</span><br></pre></td></tr></table></figure>

<p><strong>输出样例3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yes</span><br></pre></td></tr></table></figure>

<h3><span id="代码实现">代码实现</span></h3><p>c&#x2F;c++ strlen(str)和str.length()和str.size()都可以求字符串长度。<br>其中**str.length()<strong>和</strong>str.size()**是用于求string类对象的成员函数<br>**strlen(str)*<em>是用于求字符数组的长度，其参数是char</em>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include&lt;stack&gt; //stack头文件</span><br><span class="line">int judge(string s)&#123;</span><br><span class="line">    stack&lt;char&gt;stk;//设置一个存放char的stack容器</span><br><span class="line">    for(int i=0;i&lt;s.length();i++)&#123;</span><br><span class="line">        switch(s[i])&#123;</span><br><span class="line">                case&#x27;(&#x27;:</span><br><span class="line">                   stk.push(s[i]);//左括号，进栈</span><br><span class="line">                break;</span><br><span class="line">                case&#x27;[&#x27;:</span><br><span class="line">                   stk.push(s[i]);</span><br><span class="line">                break;</span><br><span class="line">                case&#x27;&#123;&#x27;:</span><br><span class="line">                   stk.push(s[i]);</span><br><span class="line">                break;</span><br><span class="line">                case&#x27;)&#x27;:</span><br><span class="line">                   if(stk.empty()) return 0;//如果栈空，返回0</span><br><span class="line">                   if (stk.top() == &#x27;(&#x27;) stk.pop();</span><br><span class="line">                   //如果栈顶是左括号，配对成功，将其出栈，进行下一步</span><br><span class="line">                   else return 0;</span><br><span class="line">                break;</span><br><span class="line">                case&#x27;]&#x27;:</span><br><span class="line">                   if(stk.empty()) return 0;</span><br><span class="line">                   if (stk.top() == &#x27;[&#x27;) stk.pop();</span><br><span class="line">                   else return 0;</span><br><span class="line">                break;</span><br><span class="line">                case&#x27;&#125;&#x27;:</span><br><span class="line">                   if(stk.empty()) return 0;</span><br><span class="line">                   if (stk.top() == &#x27;&#123;&#x27;) stk.pop();</span><br><span class="line">                   else return 0;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return stk.empty();//最终若括号一一配对，栈空，返回1值</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    string s;</span><br><span class="line">    getline(cin,s);</span><br><span class="line">    if(judge(s)==1)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;yes&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        cout&lt;&lt;&quot;no&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="7-3-回文判断"><strong>7-3 回文判断</strong></span></h3><p>回文是指正读反读均相同的字符序列，如“abba”和“abdba”均是回文，但“good”不是回文。编写一个程序，使用栈判定给定的字符序列是否为回文。</p>
<p>若用C++，可借助STL的容器实现。</p>
<p><strong>输入格式:</strong></p>
<p>输入待判断的字符序列，按回车键结束，字符序列长度&lt;20。</p>
<p><strong>输出格式:</strong></p>
<p>若字符序列是回文，输出“YES”；否则，输出“NO”。</p>
<p><strong>输入样例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abdba</span><br></pre></td></tr></table></figure>

<p><strong>输出样例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">YES</span><br></pre></td></tr></table></figure>

<h3><span id="代码实现">代码实现</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">    string s;</span><br><span class="line">    int flag;</span><br><span class="line">    getline(cin,s);</span><br><span class="line">    stack&lt;char&gt;stk;</span><br><span class="line">    for(int i=0;i&lt;s.length();i++)&#123;</span><br><span class="line">        stk.push(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    for(int i=0;i&lt;s.length()/2;i++)&#123;</span><br><span class="line">        flag=0;</span><br><span class="line">        if(s[i]==stk.top())&#123;</span><br><span class="line">            stk.pop();</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;</span><br><span class="line">            flag=1;</span><br><span class="line">            break;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(flag==0) cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>【python】数据采集的基本知识</title>
    <url>/2024/05/29/%E3%80%90python%E3%80%91%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>记录了在书上看到的一些方法，大体有用，不过代码本身有点老</p>
<!-- toc -->

<ul>
<li><a href="#%E4%BD%BF%E7%94%A8request%E5%BA%93%E8%AF%B7%E6%B1%82%E7%BD%91%E7%AB%99">使用request库请求网站</a><ul>
<li><a href="#%E4%B8%80-%E7%88%AC%E8%99%AB%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86">一、爬虫的基本原理</a></li>
<li><a href="#%E4%BA%8C-%E4%BD%BF%E7%94%A8get%E6%96%B9%E5%BC%8F%E6%8A%93%E5%8F%96%E6%95%B0%E6%8D%AE">二、使用GET方式抓取数据</a></li>
<li><a href="#%E4%B8%89-%E4%BD%BF%E7%94%A8post%E6%96%B9%E5%BC%8F%E6%8A%93%E5%8F%96%E6%95%B0%E6%8D%AE">三、使用POST方式抓取数据</a></li>
</ul>
</li>
<li><a href="#%E4%BD%BF%E7%94%A8beautiful-soup%E8%A7%A3%E6%9E%90%E7%BD%91%E9%A1%B5">使用Beautiful Soup解析网页</a><ul>
<li><a href="#1%E7%94%A8get%E6%8A%93%E5%8F%96%E6%95%B0%E6%8D%AE">1.用get抓取数据</a></li>
<li><a href="#2%E6%8F%90%E5%8F%96%E6%95%B0%E6%8D%AE">2.提取数据</a></li>
<li><a href="#3%E5%A4%84%E7%90%86%E7%BD%91%E9%A1%B5%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98">3.处理网页编码问题</a></li>
<li><a href="#4%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E5%BC%82%E5%B8%B8">4.处理网络异常</a></li>
<li><a href="#5%E7%BD%91%E9%A1%B5%E6%95%B0%E6%8D%AE%E6%8F%90%E5%8F%96%E6%8A%80%E5%B7%A7">5.网页数据提取技巧</a></li>
<li><a href="#6%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97">6.数据清洗</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<p>[TOC]</p>
<h1><span id="使用request库请求网站">使用request库请求网站</span></h1><h3><span id="一-爬虫的基本原理">一、爬虫的基本原理</span></h3><h4><span id="1网页请求的过程">1.网页请求的过程</span></h4><p>（1）Request（请求）</p>
<p>（2）Response（相应）</p>
<h4><span id="2网页请求的方式">2.网页请求的方式</span></h4><p>（1）GET：参数设置在URL中，是大多数网站的使用方式，只需一次发送和返回，响应速度快</p>
<p>（2）POST：通过request body传递参数，相比GET，可发送请求的信息大</p>
<h3><span id="二-使用get方式抓取数据">二、使用GET方式抓取数据</span></h3><p>复制任意一条首页首条新闻的标题，在源码页面按ctrl+F调出搜索框，将标题粘贴到搜索框，按回车。</p>
<p>标题在源码可以被搜索到，请求对象是www.***.cn，请求方式是GET。</p>
<p>确定好请求对象和方式后，输入代码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests #导入reques包</span><br><span class="line">url=&#x27;https://www3.nhk.or.jp/news/&#x27; #这里选择的是NHK新闻网</span><br><span class="line">strhtml=requests.get(url) #GET方式，并把获取到的数据保存在strhtml变量</span><br><span class="line">print(strhtml.text)</span><br></pre></td></tr></table></figure>

<p><img src="/2024/05/29/%E3%80%90python%E3%80%91%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240529161828.png" alt="微信截图_20240529161828"></p>
<h3><span id="三-使用post方式抓取数据">三、使用POST方式抓取数据</span></h3><p>进入某翻译页面，按快捷键ctrl+shift+i进入开发者模式（F12也可以），在翻译页面输入文本并点击翻译。</p>
<p>在开发者模式中点击“网络”→“XHR”，在“负载”中找到翻译数据，单击“标头”，发现请求数据的方式为POST。</p>
<p>找到数据所在之处并且明确请求方式之后，接下来开始写代码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import json</span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line"># POST请求的目标URL</span><br><span class="line">def get_translate_date(word=None):</span><br><span class="line">    url = &quot;https://dict.youdao.com/webtranslate&quot;</span><br><span class="line">    Form_data = &#123;</span><br><span class="line">        &quot;type&quot;:&quot;AUTO&quot;,</span><br><span class="line">        &quot;i&quot;:&quot;i love python&quot;,</span><br><span class="line">        &quot;doctype&quot;:&quot;json&quot;,</span><br><span class="line">        &quot;xmlVersion&quot;:&quot;1.8&quot;,</span><br><span class="line">        &quot;keyfrom&quot;:&quot;fanyi.web&quot;,</span><br><span class="line">        &quot;ue&quot;:&quot;UTF-8&quot;,</span><br><span class="line">        &quot;action&quot;:&quot;FY_BY_ENTER&quot;,</span><br><span class="line">        &quot;typoResult&quot;:&quot;true&quot;</span><br><span class="line">&#125;</span><br><span class="line">    #使用requests.post请求表单数据</span><br><span class="line">    response = requests.post(url, data=Form_data)</span><br><span class="line">    #将字符串格式转换成json格式的数据，并提取打印</span><br><span class="line">    content = json.loads(response.text)</span><br><span class="line">    print(content[&#x27;translateResult&#x27;][0][0][&#x27;tgt&#x27;])</span><br><span class="line"></span><br><span class="line">get_translate_date(&#x27;好的&#x27;)</span><br></pre></td></tr></table></figure>



<h1><span id="使用beautiful-soup解析网页">使用Beautiful Soup解析网页</span></h1><h3><span id="1用get抓取数据">1.用get抓取数据</span></h3><h3><span id="2提取数据">2.提取数据</span></h3><p>用选择器（select）定位数据：把鼠标光标移动到要定位的标题-右键-检查-复制selector</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#调用bs4库</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line"></span><br><span class="line">import requests</span><br><span class="line">url=(&#x27;https://www3.nhk.or.jp/shutoken-news/nhk_shutoken.xml?_=1716982796021&#x27;)</span><br><span class="line">strhtml=requests.get(url)</span><br><span class="line">print(strhtml.text)</span><br><span class="line"></span><br><span class="line">#使用lxml解析网页文档</span><br><span class="line">soup=BeautifulSoup(strhtml.text,&#x27;lxml&#x27;)</span><br><span class="line">data=soup.select(&#x27;#main &gt; article.module.module--news-main.index-main &gt; &#x27;</span><br><span class="line">                 &#x27;section &gt; div.content--header &gt; div &gt; h1 &gt; a &gt; em&#x27;)</span><br><span class="line">print(data)</span><br></pre></td></tr></table></figure>

<p><img src="/2024/05/29/%E3%80%90python%E3%80%91%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240529195222.png" alt="微信截图_20240529195222"></p>
<h3><span id="3处理网页编码问题">3.处理网页编码问题</span></h3><p>当爬取网页时，经常会遇到不同网页使用不同编码格式的情况。在处理网页编码问题时，我们可以使用 Requests 库的编码自动识别功能。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 处理网页编码问题</span><br><span class="line">response.encoding = response.apparent_encoding</span><br><span class="line">print(response.text)</span><br></pre></td></tr></table></figure>

<h3><span id="4处理网络异常">4.处理网络异常</span></h3><p>在实际应用中，网络异常是常见的情况。为了保证爬虫的稳定性，应该对网络异常进行适当处理。我们可以使用 Try-Except 来捕获异常情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">    response = requests.get(url)</span><br><span class="line">    response.raise_for_status()</span><br><span class="line">except requests.exceptions.RequestException as e:</span><br><span class="line">    print(&quot;Error: %s&quot; % e)</span><br></pre></td></tr></table></figure>



<h3><span id="5网页数据提取技巧">5.网页数据提取技巧</span></h3><h4><span id="1提取文本信息">（1）提取文本信息</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line">url = &#x27;https://example.com&#x27;</span><br><span class="line">response = requests.get(url)</span><br><span class="line">soup = BeautifulSoup(response.content, &#x27;html.parser&#x27;)</span><br><span class="line">text = soup.get_text()</span><br><span class="line">print(text)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4><span id="2提取图片信息">（2）提取图片信息</span></h4><p>将输出网页中所有图片的链接地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line">url = &#x27;https://example.com&#x27;</span><br><span class="line">response = requests.get(url)</span><br><span class="line">soup = BeautifulSoup(response.content, &#x27;html.parser&#x27;)</span><br><span class="line">images = soup.find_all(&#x27;img&#x27;)</span><br><span class="line">for img in images:</span><br><span class="line">    print(img[&#x27;src&#x27;])</span><br></pre></td></tr></table></figure>

<h4><span id="3提取表格信息">（3）提取表格信息</span></h4><p>按行或按列提取表格数据中的内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line">url = &#x27;https://example.com&#x27;</span><br><span class="line">response = requests.get(url)</span><br><span class="line">soup = BeautifulSoup(response.content, &#x27;html.parser&#x27;)</span><br><span class="line">table = soup.find(&#x27;table&#x27;)</span><br><span class="line">rows = table.find_all(&#x27;tr&#x27;)</span><br><span class="line">for row in rows:</span><br><span class="line">    cells = row.find_all(&#x27;td&#x27;)</span><br><span class="line">    for cell in cells:</span><br><span class="line">        print(cell.text)</span><br></pre></td></tr></table></figure>

<h4><span id="4将数据保存在文件">（4）将数据保存在文件</span></h4><p>将数据保存到名为 <code>data.txt</code> 的文本文件中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data = [&#x27;data1&#x27;, &#x27;data2&#x27;, &#x27;data3&#x27;]</span><br><span class="line"></span><br><span class="line">with open(&#x27;data.txt&#x27;, &#x27;w&#x27;) as file:</span><br><span class="line">    for item in data:</span><br><span class="line">        file.write(item + &#x27;\n&#x27;)</span><br></pre></td></tr></table></figure>

<h4><span id="5将数据保存在数据库">（5）将数据保存在数据库</span></h4><p>数据存储到名为 <code>data.db</code> 的 SQLite 数据库表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import sqlite3</span><br><span class="line"></span><br><span class="line">conn = sqlite3.connect(&#x27;data.db&#x27;)</span><br><span class="line">cursor = conn.cursor()</span><br><span class="line"></span><br><span class="line">cursor.execute(&#x27;&#x27;&#x27;CREATE TABLE IF NOT EXISTS data_table (data text)&#x27;&#x27;&#x27;)</span><br><span class="line"></span><br><span class="line">data = [&#x27;data1&#x27;, &#x27;data2&#x27;, &#x27;data3&#x27;]</span><br><span class="line"></span><br><span class="line">for item in data:</span><br><span class="line">    cursor.execute(&quot;INSERT INTO data_table (data) VALUES (?)&quot;, (item,))</span><br><span class="line"></span><br><span class="line">conn.commit()</span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure>

<h4><span id="6将数据保存在表格中">（6）将数据保存在表格中</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line">data = &#123;&#x27;A&#x27;: [1, 2, 3], &#x27;B&#x27;: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]&#125;</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"></span><br><span class="line">df.to_excel(&#x27;data.xlsx&#x27;, index=False)</span><br></pre></td></tr></table></figure>



<h3><span id="6数据清洗">6.数据清洗</span></h3><h4><span id="处理提取数据中的异常情况">处理提取数据中的异常情况</span></h4><p>在爬虫过程中，数据有可能存在缺失、重复或异常格式等问题，需要进行各种异常情况处理，以下是一些常见的数据异常情况处理方法：</p>
<ul>
<li>数据去重：使用集合或字典对数据进行去重处理。</li>
<li>缺失值处理：填充缺失值、删除缺失值、插值填充等方法。</li>
<li>异常值处理：判断异常值的范围或利用异常检测算法进行处理。</li>
</ul>
<h4><span id="数据清洗技巧">数据清洗技巧</span></h4><p>数据清洗是数据分析中至关重要的一环，有效的数据清洗可以提高数据质量和分析结果的准确性。以下是一些数据清洗的常用技巧：</p>
<ul>
<li>删除重复数据：通过唯一标识符或全部字段的对比删除重复数据。</li>
<li>处理缺失值：填充缺失值、删除缺失值或使用聚合值填充方法。</li>
<li>格式统一化：统一日期格式、字符串格式等，方便后续分析。</li>
<li>异常值处理：判断异常值的来源及处理方式，避免对结果产生误导。</li>
</ul>
<h4><span id="使用正则表达式辅助数据清洗">使用正则表达式辅助数据清洗</span></h4><p>正则表达式在数据清洗中起到了关键的作用，它可以帮助我们快速匹配和提取符合规则的数据。以下是一些正则表达式在数据清洗中的应用场景：</p>
<ul>
<li>提取文本中的特定模式数据，如手机号码、邮箱地址等。</li>
<li>对文本进行分割、替换和匹配，提取需要的信息。</li>
<li>清洗特殊字符，去除无效信息或格式化数据。</li>
</ul>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2024/03/11/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2><span id="quick-start">Quick Start</span></h2><h3><span id="create-a-new-post">Create a new post</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3><span id="run-server">Run server</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3><span id="generate-static-files">Generate static files</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3><span id="deploy-to-remote-sites">Deploy to remote sites</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>上标、下标的字符显示</title>
    <url>/2024/04/02/%E4%B8%8A%E6%A0%87%E3%80%81%E4%B8%8B%E6%A0%87%E7%9A%84%E5%AD%97%E7%AC%A6%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<h3><span id></span></h3><h3><span id="一-上标">一、上标</span></h3><h4><span id="1数字">1.数字</span></h4><p>¹²³⁴⁵⁶⁷⁸⁹⁰⁺⁻⁼˂˃⁽⁾˙*′˙ⁿº</p>
<h4><span id="2字母">2.字母</span></h4><p>ᵃᵇᶜᵈᵉᶠᵍʰⁱʲᵏˡᵐⁿᵒᵖʳˢᵗᵘᵛʷˣʸᶻ</p>
<p>ᴬᴮᒼᴰᴱᶠᴳᴴᴵᴶᴷᴸᴹᴺᴼᴾᴼ̴ᴿˢᵀᵁⱽᵂˣᵞᙆ</p>
<h4><span id="3其他">3.其他</span></h4><p>ᵃ ᵇ ᶜ ᵈ ᵉ ᵍ ʰ ⁱ ʲ ᵏ ˡ ᵐ ⁿ ᵒ ᵖ ᵒ⃒ ʳ ˢ ᵗ ᵘ ᵛ ʷ ˣ ʸ ᙆ ᴬ ᴮ ᒼ ᴰ ᴱ ᴳ ᴴ ᴵ ᴶ ᴷ ᴸ ᴹ ᴺ ᴼ ᴾ ᴼ̴ ᴿ ˢ ᵀ ᵁ ᵂ ˣ ᵞ ᙆ ꝰ ˀ ˁ ˤ ꟸ ꭜ ʱ ꭝ ꭞ ʴ ʵ ʶ ꭟ ˠ ꟹ ᴭ ᴯ ᴲ ᴻ ᴽ ᵄ ᵅ ᵆ ᵊ ᵋ ᵌ ᵑ ᵓ ᵚ ᵝ ᵞ ᵟ ᵠ ᵡ ᵎ ᵔ ᵕ ᵙ ᵜ ᶛ ᶜ ᶝ ᶞ ᶟ ᶡ ᶣ ᶤ ᶥ ᶦ ᶧ ᶨ ᶩ ᶪ ᶫ ᶬ ᶭ ᶮ ᶯ ᶰ ᶱ ᶲ ᶳ ᶴ ᶵ ᶶ ᶷ ᶸ ᶹ ᶺ ᶼ ᶽ ᶾ ᶿ ꚜ ꚝ ჼ ᒃ ᕻ ᑦ ᒄ ᕪ ᑋ ᑊ ᔿ ᐢ ᣕ ᐤ ᣖ ᣴ ᣗ ᔆ ᙚ ᐡ ᘁ ᐜ ᕽ ᙆ ᙇ ᒼ ᣳ ᒢ ᒻ ᔿ ᐤ ᣖ ᣵ ᙚ ᐪ ᓑ ᘁ ᐜ ᕽ ᙆ ᙇ </p>
<h3><span id="二-下标">二、下标</span></h3><h4><span id="1数字">1.数字</span></h4><p>₀ ₁ ₂ ₃ ₄ ₅ ₆ ₇ ₈ ₉ ₊ ₋ ₌ ₍ ₎ ₐ ₑ ₒ ₓ ₔ ₕ ₖ ₗ ₘ ₙ ₚ ₛ ₜ</p>
<h4><span id="2字母">2.字母</span></h4><p>ₐ ₔ ₑ ₕ ᵢ ⱼ ₖ ₗ ₘ ₙ ₒ ₚ ᵣ ₛ ₜ ᵤ ᵥ ₓ ᙮ ᵤ ᵩ ᵦ ₗ ˪ ៳ ៷ ₒ ᵨ ₛ ៴ ᵤ ᵪ ᵧ</p>
]]></content>
      <tags>
        <tag>素材</tag>
      </tags>
  </entry>
  <entry>
    <title>《图解密码技术》 读书笔记</title>
    <url>/2024/04/17/%E3%80%8A%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF%E3%80%8B-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2><span id="基础概念">基础概念</span></h2><h3><span id="1-1-基本名词解释">1-1 基本名词解释</span></h3><p>1.密钥（key）：加密和解密所需的媒介。</p>
<p>2.对称密码：在加密和解密时使用同一密钥的解密方式。</p>
<p>3.公钥密码：在加密和解密时使用不同密钥的解密方式。又叫非对称密码。</p>
<p>4.混合密码系统：结合了对称密码和非对称密码的优势。</p>
<p>5.单向散列函数：是一种保证完整性的密码技术。</p>
<p>为了防止软件被篡改，一些发布者会在发布软件的同时发布该软件的散列值，下载该软件的人自行下载散列值，如果后者与前者的值相等，说明下载的软件是正版的。</p>
<p>6.消息认证码：是一种能够保证完整性和提供认证的密码技术。</p>
<p>为了确认消息是否来自所期望的通信对象，可以使用消息认证码。</p>
<p>7.数字签名：</p>
<p>（1）伪装：第三方伪造发送者的身份传达消息。</p>
<p>（2）篡改：消息在传输的过程中遭到第三方修改。</p>
<p>（3）否认：发送者在事后推翻自己先前的主张。</p>
<p>防止伪装、篡改、否认等威胁的技术，就是数字签名。</p>
<p>8.伪随机数生成器</p>
<p>9.隐写术：密码隐藏的是内容，而隐写术隐藏的是消息本身</p>
<h2><span id="历史密码">历史密码</span></h2><h3><span id="2-1凯撒密码">2-1凯撒密码</span></h3><h4><span id="1概念">1.概念</span></h4><p>通过将明文中所使用的字母表按照一定的字数”平移“来进行加密的密码。</p>
<p>如A→F，B→G</p>
<p>在此例中，密钥为5</p>
<h4><span id="2解密">2.解密</span></h4><p>将所有可能的密钥全部尝试一遍，这种方法称为<strong>暴力破解</strong>。由于这种方法的本质是从所有的密钥中找出正确的密钥，因此又称为<strong>穷举搜索</strong>。</p>
<h3><span id="2-2简单替换密码">2-2简单替换密码</span></h3><h4><span id="1概念">1.概念</span></h4><p>将明文中所使用的字母表替换为另一套字母表的密码。</p>
<h4><span id="2加密">2.加密</span></h4><p>依次将明文中的每一个字母按照替换表替换成另一个字母。</p>
<p>如A→B，B→Z</p>
<h4><span id="3解密">3.解密</span></h4><p>简单替换密码很难通过暴力破解来破译。</p>
<p>一种密码能够使用的所有密钥的集合称为密钥空间。</p>
<p>密钥空间越大，暴力破解越困难。</p>
<p>计算：n!(n是密码所用到的字符的种类)</p>
<p><strong>频率分析法</strong></p>
<p>①明文中的字母的出现频率&#x3D;密文中的字母的出现频率</p>
<p>②除了高频字母以外，低频字母也能够成为线索</p>
<p>③搞清开头和结尾能够成为线索，搞清单词之间的分隔也能成为线索</p>
<p>④密文越长越容易破译</p>
<p>⑤同一个字母连续出现能够成为线索（这是因为在简单替换密码中，某个字母在替换表中所对应的另一个字母是固定的）</p>
]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>串的存储和表现</title>
    <url>/2024/05/31/%E4%B8%B2%E5%92%8C%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#%E4%B8%80-%E4%B8%B2%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84">一、串的存储结构</a><ul>
<li><a href="#1%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8">1.顺序存储</a></li>
<li><a href="#2%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8">2.链式存储</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C-%E4%B8%B2%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95">二、串的模式匹配算法</a><ul>
<li><a href="#1bf%E7%AE%97%E6%B3%95">1.BF算法</a></li>
<li><a href="#2kmp%E7%AE%97%E6%B3%95">2.KMP算法</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<p>[TOC]</p>
<h2><span id="一-串的存储结构">一、串的存储结构</span></h2><h3><span id="1顺序存储">1.顺序存储</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define MAXLEN 255 //串的最大长度</span><br><span class="line">typedef struct&#123;</span><br><span class="line">//串的定长顺序存储结构</span><br><span class="line">char ch[MAXLEN+1]; //存储串的一位数组，下标0的分量闲置不用</span><br><span class="line">int length; //串的当前长度</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line">//串的堆式顺序存储结构</span><br><span class="line">char *ch; //若是非空串，则按串长分配存储区，否则ch为NULL</span><br><span class="line">int length;</span><br><span class="line">&#125;HString;</span><br></pre></td></tr></table></figure>

<h3><span id="2链式存储">2.链式存储</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define CHUNKSIZE 80</span><br><span class="line">typedef struct Chunk&#123;</span><br><span class="line">char ch[CHUNKSIZE];</span><br><span class="line">struct Chunk *next;</span><br><span class="line">&#125;Chunk;</span><br><span class="line">typedef struct&#123;</span><br><span class="line">Chunk *head,*tail; //串的头、尾指针</span><br><span class="line">int length; //串的当前长度</span><br><span class="line">&#125;LString;</span><br></pre></td></tr></table></figure>



<h2><span id="二-串的模式匹配算法">二、串的模式匹配算法</span></h2><h3><span id="1bf算法">1.BF算法</span></h3><ul>
<li><p>分别利用计数指针i和j，指示主串S和模式T中当前正待比较的字符位置，i初值为pos，j初值为0；</p>
</li>
<li><p>如果两个串均未比较到串尾，即i和j均分别小于等于S和T的长度时，循环执行操作：</p>
</li>
<li><p>S.ch[i]和T.ch[i]比较，若相等，则i和j分别指示串中下一个位置，继续比较后续字符；</p>
</li>
<li><p>若不等，指针后退重新匹配，从主串的下一个字符（i&#x3D;i-j+2）起再重新和模式的第一个字符(j&#x3D;0)比较；</p>
</li>
<li><p>如果j&gt;length，说明模式T的每个字符依次和主串S中的一个连续的字符序列相等，则匹配成功，返回和模式T中第一个字符相等的字符在主串S中的符号（i-T.length），否则不成功，返回0。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//算法4.1　BF算法</span><br><span class="line">int Index(SString S, SString T, int pos)</span><br><span class="line">&#123;</span><br><span class="line">	//返回模式T在主串S中第pos个字符之后第s一次出现的位置。若不存在，则返回值为0</span><br><span class="line">	//其中，T非空，1≤pos≤StrLength(S)</span><br><span class="line">	int i = pos;</span><br><span class="line">	int j = 1;</span><br><span class="line">	while(i &lt;= S[0]&amp;&amp;j &lt;= T[0])</span><br><span class="line">	&#123;</span><br><span class="line">		if(S[i]==T[j])</span><br><span class="line">		&#123;</span><br><span class="line">			++i;</span><br><span class="line">			++j;</span><br><span class="line">		&#125; //继续比较后继字符</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			i=i-j+2;</span><br><span class="line">			j=1;</span><br><span class="line">		&#125; //指针后退重新开始匹配</span><br><span class="line">	&#125;</span><br><span class="line">	if (j &gt; T[0])</span><br><span class="line">		return i - T[0];</span><br><span class="line">	else</span><br><span class="line">		return 0;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;//Index</span><br></pre></td></tr></table></figure>

<p>最好情况下的平均时间复杂度是O(n+m);</p>
<p>最坏情况下的平均时间复杂度是O(n*m).</p>
<h3><span id="2kmp算法">2.KMP算法</span></h3><p>特点：指针不需要回溯</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//算法4.2　KMP算法</span><br><span class="line">int Index_KMP(SString S, SString T, int pos, int next[])</span><br><span class="line">&#123; 	// 利用模式串T的next函数求T在主串S中第pos个字符之后的位置的KMP算法</span><br><span class="line">	//其中，T非空，1≤pos≤StrLength(S)</span><br><span class="line">	int i = pos, j = 1;</span><br><span class="line">	while (i &lt;= S[0] &amp;&amp; j &lt;= T[0])</span><br><span class="line">		if (j == 0 || S[i] == T[j]) // 继续比较后继字</span><br><span class="line">		&#123;</span><br><span class="line">			++i;</span><br><span class="line">			++j;</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">			j = next[j]; // 模式串向右移动</span><br><span class="line">	if (j &gt; T[0]) // 匹配成功</span><br><span class="line">		return i - T[0];</span><br><span class="line">	else</span><br><span class="line">		return 0;</span><br><span class="line">&#125;//Index_KMP</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//算法4.3　计算next函数值</span><br><span class="line">void get_next(SString T, int next[])</span><br><span class="line">&#123; //求模式串T的next函数值并存入数组next</span><br><span class="line">	int i = 1, j = 0;</span><br><span class="line">	next[1] = 0;</span><br><span class="line">	while (i &lt; T[0])</span><br><span class="line">		if (j == 0 || T[i] == T[j])</span><br><span class="line">		&#123;</span><br><span class="line">			++i;</span><br><span class="line">			++j;</span><br><span class="line">			next[i] = j;</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">			j = next[j];</span><br><span class="line">&#125;//get_next</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>数据结构笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>半导体器件的基本特性</title>
    <url>/2024/04/23/%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%99%A8%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h2><span id="半导体">半导体</span></h2><p>根据导电性能，物质分为：导体、绝缘体和半导体。</p>
<p>物质的导电特性取决于物质的原子结构。</p>
<p>常见的半导体：硅（Si）、锗（Ge），四价元素。</p>
<h3><span id="1本征半导体">1.<strong>本征半导体</strong></span></h3><ul>
<li>完全纯净的、结构完整的半导体。</li>
<li>在本征半导体中，自由电子和空穴<strong>成对产生，浓度相等</strong>。</li>
</ul>
<h3><span id="2n型半导体">2.N型半导体</span></h3><ul>
<li>在本侦半导体中加入“<strong>五价元素</strong>”。</li>
<li>靠自由电子导电。</li>
<li>对外呈<strong>电中性</strong>。</li>
<li>N型半导体中含有<strong>较高</strong>的自由电子浓度，<strong>自由电子</strong>是<strong>多数载流子（多子）</strong>，空穴浓度较低，是少数载流子（少子）。</li>
<li>多数载流子浓度越高，导电性能越强。</li>
</ul>
<h3><span id="3p型半导体">3.P型半导体</span></h3><ul>
<li>在本征半导体中掺入“<strong>三价元素</strong>”。</li>
<li>对外呈<strong>电中性</strong>。</li>
<li><strong>空穴</strong>为<strong>多数载流子</strong>，而自由电子为少数载流子。</li>
</ul>
<h3><span id="4载流子的运动">4.载流子的运动</span></h3><ul>
<li><strong>漂移运动</strong>： 在<strong>电场</strong>的作用下，载流子的运动称为“漂移运动”，由漂移运动产生的电流为<strong>漂移电流</strong>。</li>
<li><strong>扩散运动</strong>：由于<strong>浓度差</strong>引起的载流子运动称为“扩散运动”，产生的相应电流为<strong>扩散电流</strong>。</li>
<li>漂移运动与扩散运动相反。</li>
<li>漂移运动作用和扩散运动作用相等。</li>
</ul>
<h2><span id="pn结">PN结</span></h2><h3><span id="1形成">1.形成</span></h3><ul>
<li>扩散越多，电场越强，漂移运动越强，对扩散的阻力越大，从而达到<strong>动态平衡</strong>，形成PN结。</li>
<li>PN结的电流为0。</li>
<li>PN区交界处有一个缺少载流子的高阻区，称为<strong>阻挡区</strong>，又叫耗尽区。</li>
</ul>
<p><img src="/2024/04/23/%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%99%A8%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7/20200622205628795.jpg" alt="20200622205628795"></p>
<h3><span id="2单向导电特性">2.单向导电特性</span></h3><h4><span id="1pn结外加正向电压导通">（1）PN结外加正向电压（导通）</span></h4><ul>
<li>**正向偏置：P+N-**。</li>
<li>扩散运动增加，漂流运动减弱，多数载流子向对方区扩散形成<strong>较大的正向电流</strong>。</li>
<li>PN结<strong>导通</strong>。</li>
<li>形成的电阻为正向电阻，阻值很小。</li>
<li><strong>正向电压越大，正向电流越大</strong>。</li>
</ul>
<p><img src="/2024/04/23/%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%99%A8%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7/20200622212041521.jpg" alt="20200622212041521"></p>
<h4><span id="2pn结外加反向电压截止">（2）PN结外加反向电压（截止）</span></h4><ul>
<li>**反向偏置：N+P-**。</li>
<li>漂流作用大于扩散作用，少数载流子做漂移运动，称反向电流。</li>
<li><strong>反向电流很小</strong>。</li>
<li>反向电压再增加，反向电流也不会增加，I&#x3D;-Iₛ。</li>
<li><strong>呈现的电阻为反向电阻，阻值很大</strong>。</li>
</ul>
<p><img src="/2024/04/23/%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%99%A8%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7/20200622211350136.jpg" alt="20200622211350136"></p>
<h4><span id="3伏安特性">（3）伏安特性</span></h4><p>当反向电压超过一定数值（反向击穿电压Uᵦ）后，反向电流会突然<strong>急剧增加</strong>，称为<strong>反向击穿</strong>。</p>
<p><img src="/2024/04/23/%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%99%A8%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7/R-C.png" alt="R-C"></p>
]]></content>
      <tags>
        <tag>电子电路基础</tag>
      </tags>
  </entry>
  <entry>
    <title>c++ map使用方法</title>
    <url>/2024/05/27/c-map%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>在浏览器上搜了一下相关的博文，整理了一部分相对基础的内容，有点难懂的另一部分等以后遇到案例了再重新整理</p>
<!-- toc -->

<ul>
<li><a href="#%E4%B8%80-%E8%AF%B4%E6%98%8E">一、说明</a><ul>
<li><a href="#1%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A">1.名词解释</a></li>
<li><a href="#2%E5%AE%9A%E4%B9%89">2.定义</a></li>
<li><a href="#3%E5%85%83%E7%B4%A0%E7%9A%84%E8%AE%BF%E9%97%AE">3.元素的访问</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0">二、常用函数</a><ul>
<li><a href="#1find">1.find()</a></li>
<li><a href="#2erase">2.erase()</a></li>
<li><a href="#3size">3.size()</a></li>
<li><a href="#4clear">4.clear()</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<p>[TOC]</p>
<h2><span id="一-说明">一、说明</span></h2><h3><span id="1名词解释">1.名词解释</span></h3><ul>
<li><p>map是STL的一个关联容器，它以&lt;key,value&gt;一对一的形式存储，且map的内部自建一个红黑树，使得其可以自动排序(在map内部一切都是有序的)</p>
</li>
<li><p>key可以时任意的数据类型，比如int,char，包括用户自定义数据类型</p>
</li>
<li><p>value是该key对应的存储的值</p>
</li>
</ul>
<p><img src="/2024/05/27/c-map%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/8697326-1c3bfc38aacd4611.webp" alt="8697326-1c3bfc38aacd4611"></p>
<h3><span id="2定义">2.定义</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">map&lt;typename1, typename2&gt; mp;</span><br><span class="line">//例子</span><br><span class="line">map&lt;int string&gt; mis;</span><br><span class="line">map&lt;string, string&gt;mss;</span><br><span class="line">map&lt;float,int&gt; mfi;</span><br><span class="line">map&lt;double,long&gt; mdl;</span><br><span class="line">map&lt;person, int&gt;mpi;//创建一个key为person型、value为int类型的map对象</span><br><span class="line">map&lt;string, int&gt; mp;</span><br></pre></td></tr></table></figure>

<p>注：如果是字符串到整型的映射，必须使用<strong>string</strong>而不能使用char数组。</p>
<h3><span id="3元素的访问">3.元素的访问</span></h3><h4><span id="1通过下标访问">（1）通过下标访问</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">map&lt;char, int&gt; mp;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    mp[&#x27;a&#x27;]=1;</span><br><span class="line">    mp[&#x27;c&#x27;]=2;    </span><br><span class="line">    cout&lt;&lt;mp[&#x27;c&#x27;];</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">返回：2</span><br></pre></td></tr></table></figure>

<h4><span id="2通过迭代器访问">（2）通过迭代器访问</span></h4><p>定义迭代器：</p>
<p>map&lt;typename1, typename2&gt;::iterator it;</p>
<p>map可以使用it-&gt;first来访问键，使用it-&gt;second来访问值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">map&lt;char, int&gt; mp;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    mp[&#x27;a&#x27;]=1;</span><br><span class="line">    mp[&#x27;c&#x27;]=2;    </span><br><span class="line">    mp[&#x27;b&#x27;]=3;</span><br><span class="line">    for(map&lt;char, int&gt;::iterator it=mp.begin();it!=mp.end();it++)&#123;</span><br><span class="line">        cout&lt;&lt;it-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;it-&gt;second&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">返回：</span><br><span class="line">a 1</span><br><span class="line">b 3</span><br><span class="line">c 2</span><br></pre></td></tr></table></figure>

<p><strong>map会以键从小到大的顺序自动排序</strong>，这种方法可以用于遍历</p>
<h2><span id="二-常用函数">二、常用函数</span></h2><h3><span id="1find">1.find()</span></h3><p>find（key）返回键值为key的映射的迭代器，时间复杂度为O（logN），N为map中映射的个数。</p>
<p>如果find()找不到，将返回NULL</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"> #include &lt;map&gt;</span><br><span class="line"> using namespace std;</span><br><span class="line"> map&lt;char, int&gt; mp;</span><br><span class="line"> int main()</span><br><span class="line"> &#123;</span><br><span class="line">     mp[&#x27;a&#x27;]=1;</span><br><span class="line">     mp[&#x27;c&#x27;]=2;    </span><br><span class="line">     mp[&#x27;b&#x27;]=3;</span><br><span class="line">     map&lt;char, int&gt;::iterator it=mp.find(&#x27;c&#x27;);</span><br><span class="line">     cout&lt;&lt;it-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;it-&gt;second;</span><br><span class="line">     return 0;</span><br><span class="line"> &#125;</span><br><span class="line">输出结果：</span><br><span class="line">c 2</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当map的第一个元素是int类型时候，可以这样操作</span><br><span class="line"></span><br><span class="line">map&lt;int, int&gt;mp1;</span><br><span class="line">int sum = 100;</span><br><span class="line">sum += mp1[10];//mp1中不存在关键字10，所以mp1返回的值为0，sum累加后是100</span><br><span class="line"></span><br><span class="line">map&lt;int,int&gt; mp2;</span><br><span class="line">mp2[20]++;//因关键字20不存在，增加一个关键字20，其值从0自增到1， 效果相当于mp2增加一个元素&lt;20,1&gt;</span><br></pre></td></tr></table></figure>



<h3><span id="2erase">2.erase()</span></h3><p>erase()可以删除单个元素，也可以删除一个区间的所有元素。</p>
<h4><span id="1删除单个元素">（1）删除单个元素</span></h4><p>mp.erase(it)，it为需要删除的元素的迭代器，时间复杂度为O(1)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> #include &lt;iostream&gt;</span><br><span class="line"> #include &lt;map&gt;</span><br><span class="line"> using namespace std;</span><br><span class="line"> map&lt;char, int&gt; mp;</span><br><span class="line"> int main()</span><br><span class="line"> &#123;</span><br><span class="line">     mp[&#x27;a&#x27;]=1;</span><br><span class="line">     mp[&#x27;c&#x27;]=2;    </span><br><span class="line">     mp[&#x27;b&#x27;]=3;</span><br><span class="line">     map&lt;char, int&gt;::iterator it=mp.find(&#x27;c&#x27;);</span><br><span class="line">     mp.erase(it);</span><br><span class="line">     for(map&lt;char, int&gt;::iterator it=mp.begin();it!=mp.end();it++)&#123;</span><br><span class="line">             cout&lt;&lt;it-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;it-&gt;second&lt;&lt;endl;</span><br><span class="line">     &#125;</span><br><span class="line">     return 0;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">a 1</span><br><span class="line"></span><br><span class="line">b 3</span><br></pre></td></tr></table></figure>

<p>mp.erase(key)，key为欲删除的映射的键。时间复杂度为O(logN)，N为map内元素的个数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> #include &lt;iostream&gt;</span><br><span class="line"> #include &lt;map&gt;</span><br><span class="line"> using namespace std;</span><br><span class="line"> map&lt;char, int&gt; mp;</span><br><span class="line"> int main()</span><br><span class="line"> &#123;</span><br><span class="line">     mp[&#x27;a&#x27;]=1;</span><br><span class="line">     mp[&#x27;c&#x27;]=2;    </span><br><span class="line">     mp[&#x27;b&#x27;]=3;</span><br><span class="line">     mp.erase(&#x27;c&#x27;);</span><br><span class="line">     for(map&lt;char, int&gt;::iterator it=mp.begin();it!=mp.end();it++)&#123;</span><br><span class="line">             cout&lt;&lt;it-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;it-&gt;second&lt;&lt;endl;</span><br><span class="line">     &#125;</span><br><span class="line">     return 0;</span><br><span class="line"> &#125;</span><br><span class="line">输出结果：</span><br><span class="line">a 1</span><br><span class="line"></span><br><span class="line">b 3</span><br></pre></td></tr></table></figure>

<h4><span id="2删除一个区间内的所有元素">（2）删除一个区间内的所有元素</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"> #include &lt;map&gt;</span><br><span class="line"> using namespace std;</span><br><span class="line"> map&lt;char, int&gt; mp;</span><br><span class="line"> int main()</span><br><span class="line"> &#123;</span><br><span class="line">     mp[&#x27;a&#x27;]=1;</span><br><span class="line">     mp[&#x27;c&#x27;]=2;    </span><br><span class="line">     mp[&#x27;b&#x27;]=3;</span><br><span class="line">     map&lt;char, int&gt;::iterator it=mp.find(&#x27;c&#x27;);    //令it指向键为c的值 </span><br><span class="line">     mp.erase(it, mp.end());    //删除it之后的所有映射 </span><br><span class="line">     for(map&lt;char, int&gt;::iterator it=mp.begin();it!=mp.end();it++)&#123;</span><br><span class="line">             cout&lt;&lt;it-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;it-&gt;second&lt;&lt;endl;</span><br><span class="line">     &#125;</span><br><span class="line">     return 0;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">a 1</span><br><span class="line"></span><br><span class="line">b 3　</span><br></pre></td></tr></table></figure>

<h3><span id="3size">3.size()</span></h3><p>size()用来获得map中映射的对数，时间复杂度为O(1)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> #include &lt;iostream&gt;</span><br><span class="line"> #include &lt;map&gt;</span><br><span class="line"> using namespace std;</span><br><span class="line"> map&lt;char, int&gt; mp;</span><br><span class="line"> int main()</span><br><span class="line"> &#123;</span><br><span class="line">     mp[&#x27;a&#x27;]=1;</span><br><span class="line">     mp[&#x27;c&#x27;]=2;    </span><br><span class="line">     mp[&#x27;b&#x27;]=3;</span><br><span class="line">     cout&lt;&lt;mp.size();</span><br><span class="line">     return 0;</span><br><span class="line"> &#125;</span><br><span class="line">输出结果：</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<h3><span id="4clear">4.clear()</span></h3><p>clear()用来清除map中的所有元素，时间复杂度为O(N)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> #include &lt;iostream&gt;</span><br><span class="line"> #include &lt;map&gt;</span><br><span class="line"> using namespace std;</span><br><span class="line"> map&lt;char, int&gt; mp;</span><br><span class="line"> int main()</span><br><span class="line"> &#123;</span><br><span class="line">     mp[&#x27;a&#x27;]=1;</span><br><span class="line">     mp[&#x27;c&#x27;]=2;    </span><br><span class="line">     mp[&#x27;b&#x27;]=3;</span><br><span class="line">     mp.clear();    //清空map </span><br><span class="line">     cout&lt;&lt;mp.size();</span><br><span class="line">     return 0;</span><br><span class="line"> &#125;</span><br><span class="line">输出结果：</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的表现</title>
    <url>/2024/05/28/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#%E4%B8%80-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E5%92%8C%E5%BB%BA%E7%AB%8B">一、二叉树的遍历和建立</a><ul>
<li><a href="#1%E5%AE%9A%E4%B9%89">1.定义</a></li>
<li><a href="#2%E5%BB%BA%E7%AB%8B%E6%8C%89%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E9%A1%BA%E5%BA%8F">2.建立（按先序遍历的顺序）</a></li>
<li><a href="#3%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86">3.中序遍历</a></li>
<li><a href="#4%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86">4.先序遍历</a></li>
<li><a href="#5%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86">5.后序遍历</a></li>
<li><a href="#6%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86">6.层序遍历</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C-%E5%A4%8D%E5%88%B6%E4%BA%8C%E5%8F%89%E6%A0%91">二、复制二叉树</a></li>
<li><a href="#%E4%B8%89-%E8%AE%A1%E7%AE%97%E4%BA%8C%E5%8F%89%E6%A0%91">三、计算二叉树</a><ul>
<li><a href="#1%E8%AE%A1%E7%AE%97%E6%B7%B1%E5%BA%A6">1.计算深度</a></li>
<li><a href="#2%E8%AE%A1%E7%AE%97%E9%AB%98%E5%BA%A6">2.计算高度</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9B-%E8%AE%A1%E7%AE%97%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%93%E7%82%B9%E6%95%B0">四、计算二叉树的结点数</a><ul>
<li><a href="#1%E8%AE%A1%E7%AE%97%E7%BB%93%E7%82%B9%E6%95%B0">1.计算结点数</a></li>
<li><a href="#2%E8%AE%A1%E7%AE%97%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9%E6%95%B0">2.计算叶子结点数</a></li>
</ul>
</li>
<li><a href="#%E4%BA%94-%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91">五、线索二叉树</a><ul>
<li><a href="#1%E5%AE%9A%E4%B9%89-1">1.定义</a></li>
<li><a href="#2%E5%88%9B%E5%BB%BA">2.创建</a></li>
<li><a href="#3%E7%BA%BF%E7%B4%A2%E5%8C%96">3.线索化</a></li>
<li><a href="#4%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86">4.中序遍历</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<p>[TOC]</p>
<h2><span id="一-二叉树的遍历和建立">一、二叉树的遍历和建立</span></h2><h3><span id="1定义">1.定义</span></h3><h4><span id="1顺序存储表示">（1）顺序存储表示</span></h4><p>仅适用于完全二叉树，层序存储</p>
<p>深度k个结点的二叉树（无论完全与否）都需要长度2^k-1的一维数组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define MAXTSIZE 100</span><br><span class="line">typedef TElemType SqBiTree[MAXTSIZE]; //0号单元存储根结点</span><br><span class="line">SqBiTree bt;</span><br></pre></td></tr></table></figure>

<h4><span id="2链式存储表示">（2）链式存储表示</span></h4><p>这里注意data的数据类型是char！不然是返回不了结点的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct BiTNode&#123;</span><br><span class="line">	char data;</span><br><span class="line">	struct BiTNode *lchild,*rchild; //左右孩子指针 </span><br><span class="line">&#125;BiTNode,*BiTree;</span><br></pre></td></tr></table></figure>

<h3><span id="2建立按先序遍历的顺序">2.建立（按先序遍历的顺序）</span></h3><ul>
<li>读入单个字符ch；</li>
<li>如果ch是#，看作空树，否则：</li>
<li>申请新的结点空间T；</li>
<li>把ch赋给T-&gt;data；</li>
<li>递归创建左、右子树。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void CreateBiTree(BiTree &amp;T)&#123;</span><br><span class="line">//按先序遍历的顺序建立二叉链表 </span><br><span class="line">	char ch;</span><br><span class="line">	cin&gt;&gt;ch;</span><br><span class="line">	if(ch == &#x27;#&#x27;) T=NULL; //递归结束</span><br><span class="line">	else&#123;</span><br><span class="line">		T = new BiTNode; //根结点 </span><br><span class="line">		T-&gt;data =ch;</span><br><span class="line">		CreateBiTree(T-&gt;lchild);//递归创建左子树 </span><br><span class="line">		CreateBiTree(T-&gt;rchild);//递归创建右子树 </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="3中序遍历">3.中序遍历</span></h3><p>若二叉树为空，则空操作，否则：</p>
<ul>
<li>中序遍历左子树；</li>
<li>访问根结点；</li>
<li>中序遍历右子树。</li>
</ul>
<h4><span id="1递归遍历">（1）递归遍历</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void InOrderTraverse(BiTree T)&#123;</span><br><span class="line">//中序遍历的递归算法</span><br><span class="line">if(T)&#123;</span><br><span class="line">	InOrderTraverse(T-&gt;lchild);//中序遍历左子树</span><br><span class="line">	cout&lt;&lt;T-&gt;data;</span><br><span class="line">	InOrderTraverse(T-&gt;rchild);//中序遍历右子树</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="2非递归遍历">（2）非递归遍历</span></h4><p>①对于STL下的stack容器，如果要使链表结点进出栈，就定义类似于</p>
<p>stack&lt;BiTNode*&gt;stk; </p>
<p>然后就可以照常使用了。</p>
<p>②这一段的工作机制是：</p>
<ul>
<li>从根结点开始，遇到结点则将结点压栈；</li>
<li>当遇到无左子树的结点时，将此结点弹栈且访问它并遍历它的右子树；</li>
<li>若该结点为叶子结点，则继续弹栈，开始遍历它的父节点的右子树。</li>
</ul>
<p>③用了一个临时变量BiTNode* top来储存栈顶结点，存完以后stack出栈，top被访问，之后继续遍历</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void InOrderTraverse1(BiTree T)&#123;</span><br><span class="line">//中序遍历的非递归算法（栈）</span><br><span class="line">stack&lt;BiTNode*&gt;stk; </span><br><span class="line">BiTNode *p;</span><br><span class="line">p = T;</span><br><span class="line">while (p || !stk.empty()) &#123;    </span><br><span class="line">// 遍历左子树    </span><br><span class="line">if(p) &#123;    </span><br><span class="line">  stk.push(p);    </span><br><span class="line">  p = p-&gt;lchild;    </span><br><span class="line">&#125;else&#123;    </span><br><span class="line">  BiTNode* top = stk.top();  // 临时变量存储栈顶元素  </span><br><span class="line">  stk.pop();    </span><br><span class="line">  cout &lt;&lt; top-&gt;data; // 访问根结点    </span><br><span class="line">  p = top-&gt;rchild; // 遍历右子树    </span><br><span class="line">&#125;    </span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h3><span id="4先序遍历">4.先序遍历</span></h3><h4><span id="1递归">（1）递归</span></h4><p>若二叉树为空，则空操作，否则：</p>
<ul>
<li>访问根结点；</li>
<li>先序遍历左子树；</li>
<li>先序遍历右子树。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void PreOrderTraverse(BiTree T)&#123;</span><br><span class="line">//先序遍历的递归算法</span><br><span class="line">if(T)&#123;</span><br><span class="line">	cout&lt;&lt;T-&gt;data;</span><br><span class="line">	PreOrderTraverse(T-&gt;lchild);//先序遍历左子树</span><br><span class="line">	PreOrderTraverse(T-&gt;rchild);//先序遍历右子树</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="2非递归">（2）非递归</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void PreOrderTraverse1(BiTree T)&#123;</span><br><span class="line">//先序遍历的非递归算法（栈）</span><br><span class="line">stack&lt;BiTNode*&gt;stk; </span><br><span class="line">BiTNode *p;</span><br><span class="line">p = T;</span><br><span class="line">while (p || !stk.empty()) &#123;    </span><br><span class="line">// 遍历左子树    </span><br><span class="line">    if(p) &#123;</span><br><span class="line">	cout&lt;&lt;p-&gt;data;   //访问根结点 </span><br><span class="line">    stk.push(p);    //根结点进栈 </span><br><span class="line">    p = p-&gt;lchild;   //遍历左子树 </span><br><span class="line">    &#125;else&#123;</span><br><span class="line">	BiTNode* top = stk.top();    </span><br><span class="line">    stk.pop();       </span><br><span class="line">    p = top-&gt;rchild; // 遍历右子树    </span><br><span class="line">    &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3><span id="5后序遍历">5.后序遍历</span></h3><h4><span id="1递归">（1）递归</span></h4><p>若二叉树为空，则空操作，否则：</p>
<ul>
<li>后序遍历左子树；</li>
<li>后序遍历右子树。</li>
<li>访问根结点；</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void PostOrderTraverse(BiTree T)&#123;</span><br><span class="line">//后序遍历的递归算法</span><br><span class="line">if(T)&#123;</span><br><span class="line">	PostOrderTraverse(T-&gt;lchild);//后序遍历左子树</span><br><span class="line">	PostOrderTraverse(T-&gt;rchild);//后序遍历右子树</span><br><span class="line">	cout&lt;&lt;T-&gt;data;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="6层序遍历">6.层序遍历</span></h3><h4><span id="1队列法">（1）队列法</span></h4><ul>
<li>将二叉树的根结点进队；</li>
<li>判断队不为空，则对根结点进行访问：将队头输出；</li>
<li>判断结点有左孩子，就把左孩子进队，结点有右孩子，就把右孩子进队；</li>
<li>遍历过的结点出队。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void LevelOrderTraverse(BiTree &amp;T)&#123;</span><br><span class="line">//用队列实现层序遍历 </span><br><span class="line">queue&lt;BiTNode*&gt;q;</span><br><span class="line">if(T) q.push(T);//根结点进队</span><br><span class="line">while(!q.empty())&#123;</span><br><span class="line">	cout&lt;&lt;q.front()-&gt;data;//访问根结点</span><br><span class="line">	if (q.front()-&gt;lchild)   //如果有左孩子，leftChild入队列</span><br><span class="line">    &#123;</span><br><span class="line">        q.push(q.front()-&gt;lchild);   </span><br><span class="line">    &#125;</span><br><span class="line">    if (q.front()-&gt;rchild)   //如果有右孩子，rightChild入队列</span><br><span class="line">    &#123;</span><br><span class="line">        q.push(q.front()-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">    q.pop();  //已经遍历过的节点出队列</span><br><span class="line">	&#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4><span id="2数组法">（2）数组法</span></h4><ul>
<li>检查根结点是否为空，如果为空立即返回；</li>
<li>创建BiTNode指针类型的指针数组，定义in、out变量，它们模拟了队列的进队和出队，用于跟踪在数组temp中哪个位置是下一个要插入节点的位置（in），以及哪个位置是当前要处理的节点（out）；</li>
<li>进队，保存根结点；</li>
<li>如果已经进队（in&gt;out)，循环执行以下操作：</li>
<li>​    定义临时结点变量，保存队列头部结点，out出队；</li>
<li>​    如果结点存在，访问结点；</li>
<li>​    检查左、右孩子是否存在，把它们加进队列中。</li>
<li>如果in的值溢出，中断返回。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void LevelOrderTraverse1(BiTree T)&#123;</span><br><span class="line">//创建结构体数组实现层序遍历</span><br><span class="line">//#define MAXTSIZE 100</span><br><span class="line">if(!T) return;</span><br><span class="line"></span><br><span class="line">BiTNode* temp[MAXTSIZE]; ////创建BiTNode指针类型的指针数组</span><br><span class="line">int in=0;</span><br><span class="line">int out=0;</span><br><span class="line">temp[in++]=T;//保存根结点</span><br><span class="line">while(in&gt;out)&#123;</span><br><span class="line">	BiTNode* node = temp[out++]; // 取出队列头部节点</span><br><span class="line">	if(node)&#123;</span><br><span class="line">	cout&lt;&lt;node-&gt;data;//访问结点 </span><br><span class="line">	if (node-&gt;lchild) temp[in++] = node-&gt;lchild;  </span><br><span class="line">  if (node-&gt;rchild) temp[in++] = node-&gt;rchild; </span><br><span class="line">	&#125;</span><br><span class="line">	if(in&gt;MAXTSIZE) return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>四种遍历的输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">请输入建立二叉链表的序列：</span><br><span class="line">ABC##DE#G##F###</span><br><span class="line">中序遍历的结果为：</span><br><span class="line">CBEGDFA</span><br><span class="line">先序遍历的结果为：</span><br><span class="line">ABCDEGF</span><br><span class="line">后序遍历的结果为：</span><br><span class="line">CGEFDBA</span><br><span class="line">层序遍历的结果为：</span><br><span class="line">ABCDEFG</span><br></pre></td></tr></table></figure>



<h2><span id="二-复制二叉树">二、复制二叉树</span></h2><p>如果是空树，停止递归，否则：</p>
<ul>
<li>申请一个新结点空间，复制根结点；</li>
<li>递归复制左子树、右子树。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void copy(BiTree T,BiTree &amp;NewT)&#123;</span><br><span class="line">//复制一颗和T完全相同的二叉树</span><br><span class="line">if(T==NULL)&#123;</span><br><span class="line">	NewT=NULL;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">	NewT = new BiTNode;</span><br><span class="line">	NewT-&gt;data=T-&gt;data;//复制根结点</span><br><span class="line">	copy(T-&gt;lchild,NewT-&gt;lchild);//递归复制左子树</span><br><span class="line">	copy(T-&gt;rchild,NewT-&gt;rchild);//递归复制右子树  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历以后可以发现新树和被复制的树完全一致。</p>
<h2><span id="三-计算二叉树">三、计算二叉树</span></h2><h3><span id="1计算深度">1.计算深度</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int Depth(BiTree T)&#123;</span><br><span class="line">//计算二叉树的深度</span><br><span class="line">int m,n;</span><br><span class="line">if(T==NULL) return 0;</span><br><span class="line">else&#123;</span><br><span class="line">	m=Depth(T-&gt;lchild);//递归计算左子树的深度 </span><br><span class="line">	n=Depth(T-&gt;rchild);//递归计算右子树的深度</span><br><span class="line">	if(m&gt;n) return m+1;//取更大者 ，+1 是为了加上当前节点这一层</span><br><span class="line">	else return n+1; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="2计算高度">2.计算高度</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int GetHeight( BinTree BT )&#123;</span><br><span class="line">    if(BT == NULL)</span><br><span class="line">        return 0;</span><br><span class="line">    //left</span><br><span class="line">    int left_height = 0, right_height = 0;//定义左子树和右子树的高度变量</span><br><span class="line">    left_height = 1 + GetHeight(BT-&gt;Left);//遍历</span><br><span class="line">    //right</span><br><span class="line">    right_height = 1 + GetHeight(BT-&gt;Right);//遍历</span><br><span class="line">    if(left_height &gt; right_height)//取更高者</span><br><span class="line">        return left_height;</span><br><span class="line">    else return right_height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="四-计算二叉树的结点数">四、计算二叉树的结点数</span></h2><h3><span id="1计算结点数">1.计算结点数</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int NodeCount(BiTree T) &#123;</span><br><span class="line">	//统计二叉树T中结点的个数</span><br><span class="line">	if (T == NULL) return 0;//如果是空树，则结点个数为0，递归结束</span><br><span class="line">	else return NodeCount(T-&gt;lchild) + NodeCount(T-&gt;rchild) + 1;</span><br><span class="line">	//否则结点个数为左子树的结点个数+右子树的结点个数+1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="2计算叶子结点数">2.计算叶子结点数</span></h3><p>①</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void CountLeaf(BiTree T, int&amp; count) //求叶子结点个数 </span><br><span class="line">&#123;</span><br><span class="line">     if(T) &#123;</span><br><span class="line">        if ((!T-&gt;lchild)&amp;&amp; (!T-&gt;rchild))</span><br><span class="line">           count++;     // 对叶子结点计数	</span><br><span class="line">		CountLeaf( T-&gt;lchild, count);  </span><br><span class="line">      	CountLeaf( T-&gt;rchild, count); </span><br><span class="line">   &#125; // if</span><br><span class="line">&#125; // CountLeaf</span><br></pre></td></tr></table></figure>

<p>②</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int LeafCount ( BiTree T)</span><br><span class="line">&#123;</span><br><span class="line">    int count=0;</span><br><span class="line"></span><br><span class="line">if(T==NULL)&#123;//空树</span><br><span class="line">    return 0;</span><br><span class="line">&#125;else if(T-&gt;lchild==NULL &amp;&amp; T-&gt;rchild==NULL)&#123;//只有一个根节点</span><br><span class="line">    return count+1;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">    count=LeafCount(T-&gt;lchild)+LeafCount(T-&gt;rchild);//关系为左右相加求和</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="五-线索二叉树">五、线索二叉树</span></h2><p><strong>解决问题</strong>：</p>
<ul>
<li>在n个结点的二叉树中，必定有n+1个空链域（叶子结点的左右子树空间浪费了）</li>
<li>二叉树的遍历，无论是递归还是非递归算法，效率都不算高。</li>
</ul>
<p><strong>线索化</strong>：</p>
<p>现将某结点的<a href="https://so.csdn.net/so/search?q=%E7%A9%BA%E6%8C%87%E9%92%88&spm=1001.2101.3001.7020">空指针</a>域指向该结点的前驱后继，定义规则如下</p>
<blockquote>
<ul>
<li>若结点的左子树为空，则该结点的左孩子指针指向其前驱结点</li>
<li>若结点的右子树为空，则该结点的右孩子指针指向其后继结点</li>
</ul>
<p>这种指向前驱和后继的<strong>指针</strong>称为<strong>线索</strong>，将一棵普通的二叉树以某种次序遍历，并添加线索的过程称为线索化。</p>
</blockquote>
<p><img src="/2024/05/28/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E9%81%8D%E5%8E%86/ccb64328668a46c69a90bd7a9059d8bb.png" alt="ccb64328668a46c69a90bd7a9059d8bb"></p>
<p>添加标志位ltag和rtag,并定义以下规则</p>
<ul>
<li>ltag0，指向左孩子；ltag&#x3D;&#x3D;1，指向前驱结点</li>
<li>rtag0，指向右孩子；rtag&#x3D;&#x3D;1，指向后继结点</li>
</ul>
<p>从而区分诸如lchild指向的是左孩子还是前驱结点</p>
<h3><span id="1定义">1.定义</span></h3><p>其中pre是全局变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct BiThrNode&#123;</span><br><span class="line">	char data;</span><br><span class="line">	struct BiThrNode *lchild,*rchild;</span><br><span class="line">	int Ltag,Rtag;</span><br><span class="line">&#125;BiThrNode,*BiThrTree;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BiThrNode* pre;//前驱结点的变量</span><br></pre></td></tr></table></figure>

<h3><span id="2创建">2.创建</span></h3><p>一定要对Ltag和Rtag初始化！！这里排查了好久</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void CreateBiTree(BiThrTree &amp;T)&#123;</span><br><span class="line">//按先序遍历的顺序建立二叉链表 </span><br><span class="line">	char ch;</span><br><span class="line">	cin&gt;&gt;ch;</span><br><span class="line">	if(ch == &#x27;#&#x27;) T=NULL; //递归结束</span><br><span class="line">	else&#123;</span><br><span class="line">		T = new BiThrNode; //根结点 </span><br><span class="line">		T-&gt;data =ch;</span><br><span class="line">		T-&gt;Ltag = 0;       //这里一定要加上，不然后边会出错 </span><br><span class="line">    T-&gt;Rtag = 0;</span><br><span class="line">		CreateBiTree(T-&gt;lchild);//递归创建左子树 </span><br><span class="line">		CreateBiTree(T-&gt;rchild);//递归创建右子树 </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="3线索化">3.线索化</span></h3><ul>
<li>如果p非空，左子树递归线索化；</li>
<li>如果p的左孩子为空，给p加上左线索，Ltag&#x3D;1，让p的左孩子指针指向pre（前驱）；否则Ltag&#x3D;0；</li>
<li>如果p的右孩子为空，给pre加上右线索，Rtag&#x3D;1，让pre的右孩子指向p（后继），否则Rtag&#x3D;0；</li>
<li>将pre指向刚访问过的结点p，即pre&#x3D;p；</li>
<li>右子树递归线索化。</li>
</ul>
<p><img src="/2024/05/28/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E9%81%8D%E5%8E%86/ccb64328668a46c69a90bd7a9059d8bb-1716878459234-2.png" alt="ccb64328668a46c69a90bd7a9059d8bb"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void InThreading(BiThrTree p)&#123;</span><br><span class="line">	if(p)&#123;</span><br><span class="line">    InThreading(p-&gt;lchild);   //递归左子树线索化</span><br><span class="line">    if(!p-&gt;lchild)&#123;           //没有左孩子</span><br><span class="line">        p-&gt;Ltag = 1;    //前驱线索</span><br><span class="line">        p-&gt;lchild = pre; //左孩子指针指向前驱</span><br><span class="line">    &#125;</span><br><span class="line">    if(!pre-&gt;rchild)&#123;     //没有右孩子</span><br><span class="line">        pre-&gt;Rtag = 1;  //后继线索</span><br><span class="line">        pre-&gt;rchild = p; //前驱右孩子指针指向后继(当前结点p)</span><br><span class="line">    &#125;</span><br><span class="line">    pre = p; //保持pre指向p的前驱 </span><br><span class="line">    InThreading(p-&gt;rchild);      //递归右子树线索化</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void InOrderThreading(BiThrTree &amp;Thrt,BiThrTree T)&#123;</span><br><span class="line">	Thrt = new BiThrNode;//建立头结点 </span><br><span class="line">	Thrt-&gt;Ltag=0;//头结点有左孩子，若树非空，则其左孩子为树根</span><br><span class="line">	Thrt-&gt;Rtag=1;//头结点的右孩子指针为右线索</span><br><span class="line">	Thrt-&gt;rchild=Thrt;//初始化时右指针指向自己</span><br><span class="line">	if(!T) Thrt-&gt;lchild=Thrt;//若树为空，则左指针也指向自己</span><br><span class="line">	else&#123;</span><br><span class="line">		Thrt -&gt;lchild=T;//头结点的左孩子指向根 </span><br><span class="line">		pre = Thrt;//pre初值指向头结点 </span><br><span class="line">		InThreading(T);//对以T为根的二叉树进行线索化</span><br><span class="line">		pre-&gt;rchild=Thrt;//结束后，pre为最右结点，pre的右线索指向头结点</span><br><span class="line">		pre-&gt;Rtag=1;</span><br><span class="line">		Thrt-&gt;rchild=pre;//头结点的右线索指向pre </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="4中序遍历">4.中序遍历</span></h3><ul>
<li>指针p指向根结点；</li>
<li>p非空或遍历未结束时：</li>
<li>沿着左孩子向下，到达最左下结点*p，它是中序的第一个结点；</li>
<li>访问*p；</li>
<li>沿着右线索反复查找当前结点*p的后继结点并访问后继结点，直至右线索为0或者遍历结束；</li>
<li>转向p的右子树。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void InOrderThraverse_Thr(BiThrTree T) &#123;  </span><br><span class="line">    BiThrTree p = T-&gt;lchild;  //p指向根结点</span><br><span class="line">    while (p != T) &#123;  //空树或遍历结束时，p==T</span><br><span class="line">    // 遍历左子树  </span><br><span class="line">    while (p-&gt;Ltag == 0) p = p-&gt;lchild;//沿着左孩子向下</span><br><span class="line">	cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;;   //访问其左子树为空的结点</span><br><span class="line">    while (p-&gt;Rtag == 1 &amp;&amp; p-&gt;rchild != T)&#123;  </span><br><span class="line">        p = p-&gt;rchild;  </span><br><span class="line">        cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;;  //沿着右线索访问后继结点</span><br><span class="line">    &#125;  </span><br><span class="line">    p = p-&gt;rchild;  //转向p的右子树</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>数据结构笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>图的表示和操作</title>
    <url>/2024/06/01/%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#%E4%B8%80-%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C">一、图的基本操作</a><ul>
<li><a href="#int-locatevex">int LocateVex();</a></li>
<li><a href="#int-firstadjvex">int FirstAdjVex();</a></li>
<li><a href="#int-nextadjvex">int NextAdjVex();</a></li>
<li><a href="#void-showmatrix">void showMatrix();</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C-%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84">二、图的存储结构</a></li>
<li><a href="#1%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5">1.邻接矩阵</a><ul>
<li><a href="#1%E6%97%A0%E5%90%91%E7%BD%91%E7%9A%84%E5%AE%9A%E4%B9%89">（1）无向网的定义</a></li>
<li><a href="#2%E6%97%A0%E5%90%91%E7%BD%91%E7%9A%84%E5%88%9B%E5%BB%BA">（2）无向网的创建</a></li>
</ul>
</li>
<li><a href="#2%E9%82%BB%E6%8E%A5%E8%A1%A8%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8">2.邻接表（链式存储）</a><ul>
<li><a href="#1%E5%AE%9A%E4%B9%89">（1）定义</a></li>
<li><a href="#2%E5%88%9B%E5%BB%BA">（2）创建</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89-%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86">三、图的遍历</a><ul>
<li><a href="#1%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86">1.深度优先遍历</a></li>
<li><a href="#2%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86">2.广度优先遍历</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<p>[TOC]</p>
<h2><span id="一-图的基本操作">一、图的基本操作</span></h2><h3><span id="int-locatevex">int LocateVex();</span></h3><p>&#x2F;&#x2F; 返回顶点u在图中的位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int LocateVex(MGraph G, VertexType u) &#123;</span><br><span class="line">	int i;</span><br><span class="line">	for (i = 0; i &lt; G.vexnum &amp;&amp; G.vexs[i] != u; i++);</span><br><span class="line">	return i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="int-firstadjvex">int FirstAdjVex();</span></h3><p>&#x2F;&#x2F; 返回图G中u的第一个邻接节点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int FirstAdjVex(MGraph G, VertexType u) &#123;</span><br><span class="line">	int index = LocateVex(G, u);</span><br><span class="line">	int i;</span><br><span class="line">	for (i = 0; i &lt; G.vexnum; i++) &#123;</span><br><span class="line">		if (G.arcs[index][i].adj != -1) break;</span><br><span class="line">	&#125;</span><br><span class="line">	if (i == G.vexnum) return -1;  // 没有临界点</span><br><span class="line">	else return i;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3><span id="int-nextadjvex">int NextAdjVex();</span></h3><p>&#x2F;&#x2F; 返回G中顶点v相对于u的下一邻接点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int NextAdjVex(MGraph G, VertexType v, VertexType u) &#123;</span><br><span class="line">	int indexV = LocateVex(G, v);</span><br><span class="line">	int indexU = LocateVex(G, u);</span><br><span class="line">	int index;</span><br><span class="line">	for (index = indexU + 1; index &lt; G.vexnum &amp;&amp; G.arcs[indexV][index].adj == -1; index++);</span><br><span class="line">	if (index == G.vexnum) return -1;</span><br><span class="line">	else return index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="void-showmatrix">void showMatrix();</span></h3><p>&#x2F;&#x2F; 打印图的邻接矩阵</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void showMatrix(MGraph G) &#123;</span><br><span class="line">	for (int i = 0; i &lt; G.vexnum; i++) &#123;</span><br><span class="line">		for (int j = 0; j &lt; G.vexnum; j++) cout &lt;&lt; G.arcs[i][j].adj &lt;&lt; &quot; &quot;;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="二-图的存储结构">二、图的存储结构</span></h2><h2><span id="1邻接矩阵">1.邻接矩阵</span></h2><p>图没有顺序存储结构，但可以利用二维数组来表示元素之间的关系，即邻接矩阵表示法。</p>
<p>邻接矩阵是表示顶点之间相邻关系的矩阵。</p>
<p><strong>无向图</strong></p>
<p><img src="/2024/06/01/%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E6%93%8D%E4%BD%9C/fd2a45a63a414cfdb6800122ecd6bb82.jpg" alt="fd2a45a63a414cfdb6800122ecd6bb82"></p>
<p><strong>有向网</strong></p>
<p><img src="/2024/06/01/%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E6%93%8D%E4%BD%9C/af06656474c14cfb839a5cb7e8cae998.jpg" alt="af06656474c14cfb839a5cb7e8cae998"></p>
<h3><span id="1无向网的定义">（1）无向网的定义</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define MAXINT 32767 //表示极大值，即∞</span><br><span class="line">#define MVnum 100 //最大顶点数</span><br><span class="line"></span><br><span class="line">typedef char VerTexType;//假设顶点为字符型</span><br><span class="line">typedef int ArcType; //假设边的权值为整型</span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line">	VerTexType vexs[MVnum]; //顶点表</span><br><span class="line">	ArcType arcs[MVnum][MVnum]; //邻接矩阵</span><br><span class="line">	int vexnum,arcnum; //图的当前点数和边数 </span><br><span class="line">&#125;AMGraph;</span><br></pre></td></tr></table></figure>

<h3><span id="2无向网的创建">（2）无向网的创建</span></h3><ul>
<li>输入总顶点数和总边数；</li>
<li>依次输入点的信息；</li>
<li>初始化邻接矩阵；</li>
<li>依次输入每条边（及其权值），<u>确定两个顶点在图中的位置之后</u>，使相应边赋予相应的权值，<u>同时使其对称边赋予相同的权值</u>。</li>
</ul>
<p><strong>创建。</strong></p>
<p>无向图的创建只需要删除w变量的部分，并把无穷改成1就好。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int CreateUDN(AMGraph &amp;G)&#123; </span><br><span class="line">	cin&gt;&gt;G.vexnum&gt;&gt;G.arcnum; //输入总点数和总边数</span><br><span class="line">	for(int i=0;i&lt;G.vexnum;i++)&#123;</span><br><span class="line"> 		cin&gt;&gt;G.vexs[i]; //输入点的信息</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=0;i&lt;G.arcnum;i++)</span><br><span class="line">	  for(int j=0;i&lt;G.arcnum;j++)</span><br><span class="line">	    G.arcs[i][j]=MAXINT; //初始化邻接矩阵，边的权值均置为∞ </span><br><span class="line">	for(int k=0;k&lt;G.arcnum;k++) &#123;  // 输入弧v1-v2的信息</span><br><span class="line">		VerTexType v1,v2;int w;</span><br><span class="line">		cin&gt;&gt;v1&gt;&gt;v2&gt;&gt;w; </span><br><span class="line">		int index1 = LocateVex(G, v1);</span><br><span class="line">		int index2 = LocateVex(G, v2);</span><br><span class="line">		G.arcs[index1][index2]= w; // w表示邻接的权值 </span><br><span class="line">		G.arcs[index2][index1] = G.arcs[index1][index2];  // 无向图对称构造</span><br><span class="line">	&#125;</span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>打印。</strong></p>
<pre><code>for(i = 0 ; i &lt; G.vexnum ; ++i)&#123;
    for(j = 0; j &lt; G.vexnum; ++j)&#123;
        if(j != G.vexnum - 1)&#123;
            if(G.arcs[i][j] != MaxInt)
                cout &lt;&lt; G.arcs[i][j] &lt;&lt; &quot;\t&quot;;
            else
                cout &lt;&lt; &quot;∞&quot; &lt;&lt; &quot;\t&quot;;
        &#125;
        else&#123;
            if(G.arcs[i][j] != MaxInt)
                cout &lt;&lt; G.arcs[i][j] &lt;&lt;endl;
            else
                cout &lt;&lt; &quot;∞&quot; &lt;&lt;endl;
        &#125;
    &#125;
&#125;//for
</code></pre>
<h2><span id="2邻接表链式存储">2.邻接表（链式存储）</span></h2><p><img src="/2024/06/01/%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E6%93%8D%E4%BD%9C/v2-917733c568ffe18d48b5493b1b327f05_r.jpg" alt="v2-917733c568ffe18d48b5493b1b327f05_r"></p>
<h3><span id="1定义">（1）定义</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#typedef MVNum 100 //最大顶点数 </span><br><span class="line">typedef struct ArcNode&#123; //边结点 </span><br><span class="line">	int adjvex; //该边所指向的顶点的位置</span><br><span class="line">	struct ArcNode *nextarc; //指向下一条边的指针</span><br><span class="line">	//InfoType info         //网的边权值 </span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line">typedef struct VNode&#123; //顶点表 </span><br><span class="line">	VertexType data; //顶点信息</span><br><span class="line">	ArcNode *firstarc; //指向第一天依附该结点的弧的指针 </span><br><span class="line">&#125;VNode,AdjList[MVNum];</span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line">	AdjList vertices;</span><br><span class="line">	int vexnum,arcnum; //图的当前顶点数和边数 </span><br><span class="line">&#125;ALGraph; </span><br></pre></td></tr></table></figure>

<h3><span id="2创建">（2）创建</span></h3><ul>
<li><p>输入总顶点数和总边数；</p>
</li>
<li><p>依次输入点的信息存在顶点表中，每个表头结点的指针域初始化为NULL；</p>
</li>
<li><p>创建邻接表，依次输入每条边依附的两个顶点，确定这两个顶点的序号i和j之后，将此边结点分别插入vi和vj</p>
</li>
<li><p>对应的两个边链表的头部。如果是有向图，只需生成一个序号为j的边结点，插入到vj的边链表头。</p>
<p>  int CreateUDG(ALGraph &amp;G){<br>  &#x2F;&#x2F;采用邻接表表示法，创建无向图G<br>  cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum;				&#x2F;&#x2F;输入总顶点数，总边数<br>  for(int i &#x3D; 0; i &lt; G.vexnum; ++i){          	&#x2F;&#x2F;输入各点，构造表头结点表<br>  cin &gt;&gt; G.vertices[i].data;           	&#x2F;&#x2F;输入顶点值<br>  G.vertices[i].firstarc&#x3D;NULL;			&#x2F;&#x2F;初始化表头结点的指针域为NULL<br>  }&#x2F;&#x2F;for<br>  for(int k &#x3D; 0; k &lt; G.arcnum;++k){        		&#x2F;&#x2F;输入各边，构造邻接表<br>  VerTexType v1 , v2;<br>  int i , j;<br>  cin &gt;&gt; v1 &gt;&gt; v2;                 		&#x2F;&#x2F;输入一条边依附的两个顶点<br>  i &#x3D; LocateVex(G, v1);  j &#x3D; LocateVex(G, v2);<br>  &#x2F;&#x2F;确定v1和v2在G中位置，即顶点在G.vertices中的序号<br><br>  ArcNode <em>p1&#x3D;new ArcNode;               	&#x2F;&#x2F;生成一个新的边结点</em>p1<br>  p1-&gt;adjvex&#x3D;j;                   		&#x2F;&#x2F;邻接点序号为j<br>  p1-&gt;nextarc&#x3D; G.vertices[i].firstarc;  G.vertices[i].firstarc&#x3D;p1;<br>  &#x2F;&#x2F;将新结点<em>p1插入顶点vi的边表头部<br><br>  ArcNode <em>p2&#x3D;new ArcNode;                &#x2F;&#x2F;生成另一个对称的新的边结点</em>p2<br>  p2-&gt;adjvex&#x3D;i;                   		&#x2F;&#x2F;邻接点序号为i<br>  p2-&gt;nextarc&#x3D; G.vertices[j].firstarc;  G.vertices[j].firstarc&#x3D;p2;<br>  &#x2F;&#x2F;将新结点</em>p2插入顶点vj的边表头部<br>  }&#x2F;&#x2F;for<br>  return 1;<br>  }</p>
</li>
</ul>
<h2><span id="三-图的遍历">三、图的遍历</span></h2><h3><span id="1深度优先遍历">1.深度优先遍历</span></h3><p>设置变量。</p>
<p>图的遍历和树的遍历类似，即从图中某一顶点出发遍历图中其余顶点，且使每一个顶点仅被访问一次。<br>为了避免同一顶点被访问多次，在遍历图的过程中，必须记下每个已被访问过的顶点。为此，我们可以设一个辅助数组Visited[N]来标记某一顶点是否被访问过了，初始化为False。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool visited[MVNum];           					//访问标志数组，其初值为&quot;false&quot; </span><br><span class="line">int FirstAdjVex(Graph G , int v);				//返回v的第一个邻接点</span><br><span class="line">int NextAdjVex(Graph G , int v , int w);		//返回v相对于w的下一个邻接点</span><br></pre></td></tr></table></figure>

<p>类似于树的先序遍历。</p>
<ul>
<li>从图中某个顶点v出发，访问v，并置visited[v]的值为1；</li>
<li>依次检查v的所有邻接点w，如果visited[w]的值为0，再从w出发进行遍历，直到图中所有顶点都被遍历过。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 图的深度优先遍历</span><br><span class="line">void DFSTraverse(MGraph G) &#123;</span><br><span class="line">	int* visited = new int[G.vexnum]; // 访问标志数组</span><br><span class="line">	for (int i = 0; i &lt; G.vexnum; i++) visited[i] = 0; // 初始化未被访问</span><br><span class="line">	for (int i = 0; i &lt; G.vexnum; i++) &#123;</span><br><span class="line">		if (!visited[i]) DFS(G, i, visited); // 对尚未访问的顶点i调用DFS，</span><br><span class="line">											 // 因为图G可能不是连通图</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 从图中第v个顶点开始进行深度优先遍历</span><br><span class="line">void DFS(MGraph G, int v, int* visited) &#123;</span><br><span class="line">	visited[v] = 1; //先访问顶点v</span><br><span class="line">	cout &lt;&lt; G.vexs[v] &lt;&lt; &quot; &quot;;</span><br><span class="line">	for (int w = FirstAdjVex(G, G.vexs[v]); w &gt;= 0; w = NextAdjVex(G, G.vexs[v], G.vexs[w])) &#123;</span><br><span class="line">		if (!visited[w]) DFS(G, w, visited); // 对v的尚未访问的邻接顶点w递归调用DFS</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="2广度优先遍历">2.广度优先遍历</span></h3><p><strong>广度优先搜索（Broadth First Search）</strong> 类似于树层次遍历的过程，即以v为初始点，由近即远，一次访问和v有路径相通且路径长度为1，2，…的顶点。此过程可借助于<code>队列</code>实现。</p>
<ul>
<li>从图中某个顶点出发，访问v，并置visited[v]的值为1，然后v进队；</li>
<li>只要队列不空，则：</li>
<li>队头顶点u出队；</li>
<li>依次检查u的所有邻接点w，如果visited[w]为0，访问w，并置其值为1，w进队。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void BFSTraverse(MGraph G) &#123;</span><br><span class="line">// 按照广度优先非递归遍历图G，使用辅助队列Q和访问标志数组visited。</span><br><span class="line">	int* visited = new int[G.vexnum];</span><br><span class="line">	queue&lt;int&gt; Q;</span><br><span class="line">	int i;</span><br><span class="line">	for (i = 0; i &lt; G.vexnum; i++) visited[i] = 0;</span><br><span class="line">	for (i = 0; i &lt; G.vexnum; i++) &#123;</span><br><span class="line">		if (!visited[i]) &#123; //访问顶点i</span><br><span class="line">			visited[i] = 1;</span><br><span class="line">			cout &lt;&lt; G.vexs[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">			Q.push(i);</span><br><span class="line">			while (!Q.empty()) &#123;</span><br><span class="line">				int u = Q.front();</span><br><span class="line">				Q.pop(); //取出对头顶点</span><br><span class="line">				for (int w = FirstAdjVex(G, G.vexs[u]); w &gt;= 0; w = NextAdjVex(G, G.vexs[u], G.vexs[w])) &#123;</span><br><span class="line">					if (!visited[w]) &#123;  // w为u的尚未访问的邻接顶点</span><br><span class="line">						visited[w] = 1;</span><br><span class="line">						cout &lt;&lt; G.vexs[w] &lt;&lt; &quot; &quot;;</span><br><span class="line">						Q.push(w);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>数据结构笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>【离散数学】集合、关系</title>
    <url>/2024/05/26/%E3%80%90%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E3%80%91%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#%E4%B8%80-%E9%9B%86%E5%90%88%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E8%A1%A8%E7%A4%BA">一、集合的概念和表示</a><ul>
<li><a href="#%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A">名词解释</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C-%E9%9B%86%E5%90%88%E8%BF%90%E7%AE%97">二、集合运算</a><ul>
<li><a href="#1%E8%BF%90%E7%AE%97">1.运算</a></li>
<li><a href="#2%E6%80%A7%E8%B4%A8">2.性质</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89-%E5%8C%85%E5%90%AB%E6%8E%92%E6%96%A5%E5%8E%9F%E7%90%86">三、包含排斥原理</a><ul>
<li><a href="#1%E6%A6%82%E5%BF%B5">1.概念</a></li>
<li><a href="#2%E4%BE%8B%E9%A2%98">2.例题</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9B-%E5%BA%8F%E5%81%B6%E4%B8%8E%E7%AC%9B%E5%8D%A1%E5%B0%94%E7%A7%AF">四、序偶与笛卡尔积</a><ul>
<li><a href="#1%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A%E5%92%8C%E5%8E%9F%E7%90%86">1.名词解释和原理</a></li>
<li><a href="#2%E4%BE%8B%E9%A2%98-1">2.例题</a></li>
</ul>
</li>
<li><a href="#%E4%BA%94-%E5%85%B3%E7%B3%BB%E5%8F%8A%E5%85%B6%E8%A1%A8%E7%A4%BA">五、关系及其表示</a><ul>
<li><a href="#1%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A%E5%92%8C%E5%8E%9F%E7%90%86-1">1.名词解释和原理</a></li>
<li><a href="#2%E4%BE%8B%E9%A2%98-2">2.例题</a></li>
</ul>
</li>
<li><a href="#%E5%85%AD-%E5%85%B3%E7%B3%BB%E7%9A%84%E6%80%A7%E8%B4%A8">六、关系的性质</a><ul>
<li><a href="#%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A-1">名词解释</a></li>
<li><a href="#%E4%BE%8B%E9%A2%98">例题</a></li>
</ul>
</li>
<li><a href="#%E4%B8%83-%E5%A4%8D%E5%90%88%E5%85%B3%E7%B3%BB%E5%92%8C%E9%80%86%E5%85%B3%E7%B3%BB">七、复合关系和逆关系</a><ul>
<li><a href="#1%E5%90%8D%E8%AF%8D%E5%92%8C%E5%AE%9A%E7%90%86">1.名词和定理</a></li>
<li><a href="#2%E4%BE%8B%E9%A2%98-3">2.例题</a></li>
</ul>
</li>
<li><a href="#%E5%85%AB-%E9%97%AD%E5%8C%85%E8%BF%90%E7%AE%97">八、闭包运算</a></li>
</ul>
<!-- tocstop -->

<p>[TOC]</p>
<h2><span id="一-集合的概念和表示">一、集合的概念和表示</span></h2><h3><span id="名词解释">名词解释</span></h3><h4><span id="集合">集合</span></h4><p>把具有共同性质的一些东西汇集成一个整体，就形成一个集合。</p>
<h4><span id="元素">元素</span></h4><p>汇集成集合的事物叫元素。</p>
<p>描述：元素x属于集合A</p>
<p>记作：x∈A</p>
<h4><span id="子集">子集</span></h4><p>描述：A集合是B集合的子集</p>
<p>记作：A ⊆ B</p>
<h4><span id="真子集">真子集</span></h4><p>描述 : A集合是B集合的子集 , 并且 A &#x3D;̸ B，则称A集合是B集合的真子集</p>
<p>记作 : A ⊂ B</p>
<p><u>真包含关系的性质：</u></p>
<ul>
<li><strong>反自反性</strong>: A ⊄ A</li>
<li><strong>反对称性</strong>: 如果 A ⊂ B，那么 B ⊄ A</li>
<li><strong>传递性</strong>: 如果 A ⊂ B, 并且 B ⊂ C, 那么 A ⊂ C</li>
</ul>
<h4><span id="非真子集">非真子集</span></h4><p>描述 : 存在元素x是集合A的元素，不是集合B的元素，并且A、B不相等，则称A集合不是B集合的真子集</p>
<p>记作 : A ⊄ B</p>
<h4><span id="空集">空集</span></h4><p>描述 : 没有任何元素的集合 , 称为空集合 , 简称为空集 </p>
<p>记作 : ∅</p>
<ul>
<li>x无解→空集</li>
<li>空集是一切集合的子集</li>
<li>空集是唯一的</li>
<li>{∅} ≠ ∅</li>
<li>对任何一个集合A，∅ ⊆ A</li>
</ul>
<h4><span id="全集">全集</span></h4><p>限定所讨论的集合 , 都是某个集合的子集 , 则称该集合为全集 , 记作 E</p>
<h4><span id="幂集">幂集</span></h4><p>描述 : A集合的全体子集组成的集合称为 A的幂集 ;</p>
<p>记作 : P ( A )</p>
<p>幂集个数定理 : 集合 A中的元素个数∣ A ∣ &#x3D; n ，则 A的 幂集个数 ∣ P ( A ) ∣ &#x3D; 2ⁿ</p>
<h4><span id="外延性原理">外延性原理</span></h4><p>两个集合是相等的，当且仅当它们有相同的成员。（两个集合A和B相等，记作A &#x3D; B）</p>
<p>集合A和集合B相等的充分必要条件是这两个集合互为子集。</p>
<h2><span id="二-集合运算">二、集合运算</span></h2><h3><span id="1运算">1.运算</span></h3><p><img src="/2024/05/26/%E3%80%90%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E3%80%91%E9%9B%86%E5%90%88/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240526213445.png" alt="微信图片_20240526213445"></p>
<h3><span id="2性质">2.性质</span></h3><p><img src="/2024/05/26/%E3%80%90%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E3%80%91%E9%9B%86%E5%90%88/e2067441ba7746f0b650c1e43d9e64ef.png" alt="在这里插入图片描述"></p>
<p><img src="/2024/05/26/%E3%80%90%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E3%80%91%E9%9B%86%E5%90%88/87c29f238b2a41818fd3187d7829d652.png" alt="在这里插入图片描述"></p>
<p><img src="/2024/05/26/%E3%80%90%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E3%80%91%E9%9B%86%E5%90%88/dd8be408e0b24359b25f7ddefbf425eb.png" alt="在这里插入图片描述"></p>
<p><img src="/2024/05/26/%E3%80%90%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E3%80%91%E9%9B%86%E5%90%88/5dda146382eb4276a8a6ec029c2d4b42.png" alt="在这里插入图片描述"></p>
<p><img src="/2024/05/26/%E3%80%90%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E3%80%91%E9%9B%86%E5%90%88/8fdd73e243d841179f607fba34a9e141.png" alt="在这里插入图片描述"></p>
<p><img src="/2024/05/26/%E3%80%90%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E3%80%91%E9%9B%86%E5%90%88/255afd2714574225b2e84a5f04b48c5e.png" alt="在这里插入图片描述"></p>
<p><img src="/2024/05/26/%E3%80%90%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E3%80%91%E9%9B%86%E5%90%88/80456386fbfb4c72b4f4144838eea10d.png" alt="在这里插入图片描述"></p>
<p><img src="/2024/05/26/%E3%80%90%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E3%80%91%E9%9B%86%E5%90%88/0da7a50fde1f474d8f18293ee9f488ef.png" alt="在这里插入图片描述"></p>
<h2><span id="三-包含排斥原理">三、包含排斥原理</span></h2><h3><span id="1概念">1.概念</span></h3><p><img src="/2024/05/26/%E3%80%90%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E3%80%91%E9%9B%86%E5%90%88/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240526213441.png" alt="微信图片_20240526213441"></p>
<p><img src="/2024/05/26/%E3%80%90%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E3%80%91%E9%9B%86%E5%90%88/7d8cec1b0d80461b967e6d29f39c7288.png" alt="在这里插入图片描述"></p>
<p><img src="/2024/05/26/%E3%80%90%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E3%80%91%E9%9B%86%E5%90%88/97dfee6601d240678de51b656d2e2269.png" alt="在这里插入图片描述"></p>
<p><img src="/2024/05/26/%E3%80%90%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E3%80%91%E9%9B%86%E5%90%88/d260fc358e8a4abfbec140f60d714566.png" alt="在这里插入图片描述"></p>
<h3><span id="2例题">2.例题</span></h3><p><img src="/2024/05/26/%E3%80%90%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E3%80%91%E9%9B%86%E5%90%88/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240526212553.png" alt="微信截图_20240526212553"></p>
<h2><span id="四-序偶与笛卡尔积">四、序偶与笛卡尔积</span></h2><h3><span id="1名词解释和原理">1.名词解释和原理</span></h3><h4><span id="序偶">序偶</span></h4><p>有序二元组的称呼，可以看作一个有顺序的集合，记作&lt;A,B&gt;</p>
<p>序偶不同于集合的是序偶是有顺序的，&lt;A,B&gt; !&#x3D; &lt;B,A&gt;</p>
<h4><span id="n元组">n元组</span></h4><p><img src="/2024/05/26/%E3%80%90%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E3%80%91%E9%9B%86%E5%90%88/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240526212700.png" alt="微信截图_20240526212700"></p>
<h4><span id="笛卡尔积">笛卡尔积</span></h4><p>A与B是集合，那么A与B的笛卡尔积相当于A X B，表示&lt;a,b&gt;,其中：a∈A ,b∈B</p>
<p>笛卡尔积一般不满足交换律和结合律（并、交差运算除外）</p>
<p><img src="/2024/05/26/%E3%80%90%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E3%80%91%E9%9B%86%E5%90%88/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240526215607.png" alt="微信截图_20240526215607"></p>
<p><img src="/2024/05/26/%E3%80%90%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E3%80%91%E9%9B%86%E5%90%88/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240526215637.png" alt="微信截图_20240526215637"></p>
<h3><span id="2例题">2.例题</span></h3><p>笛卡尔积的计算</p>
<p><img src="/2024/05/26/%E3%80%90%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E3%80%91%E9%9B%86%E5%90%88/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240526215742.png" alt="微信截图_20240526215742"></p>
<h2><span id="五-关系及其表示">五、关系及其表示</span></h2><h3><span id="1名词解释和原理">1.名词解释和原理</span></h3><h4><span id="关系">关系</span></h4><p>对于一个二元关系R，R里面的任意一个序偶&lt;x,y&gt;可以记作**&lt;x,y&gt;∈R **或 <strong>xRy</strong></p>
<p>A X B的子集R称为一个从A到B的二元关系</p>
<h4><span id="前域-值域-域">前域、值域、域</span></h4><p><img src="/2024/05/26/%E3%80%90%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E3%80%91%E9%9B%86%E5%90%88/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240526220618.png" alt="微信截图_20240526220618"></p>
<h4><span id="空关系">空关系</span></h4><p>A X B的平凡子集∅，称为A到B的空关系。</p>
<h4><span id="全域关系">全域关系</span></h4><p>A X B的平凡子集A X B称为A到B的全域关系。</p>
<h4><span id="恒等关系">恒等关系</span></h4><p>设Iₓ是X上的二元关系，且满足Iₓ &#x3D; {&lt;x,x&gt;|x∈X}，则称Iₓ是X上的恒等关系。</p>
<h4><span id="关系矩阵"><strong>关系矩阵</strong></span></h4><p>我们有两个有限集合：X &#x3D; {x₁,x₂,x₃,……,xₘ}，Y&#x3D;{y₁,y₂,y₃,……,yₙ}，R是X到Y上的一个二元关系，那么就有相应的关系矩阵：M &#x3D; [rᵢ ⱼ]ₘₓₙ</p>
<p>rᵢ ⱼ&#x3D;1当且仅当&lt;aᵢ,bⱼ&gt;∈R</p>
<p>rᵢ ⱼ&#x3D;0当且仅当&lt;aᵢ,bⱼ&gt;!∈R</p>
<p><img src="/2024/05/26/%E3%80%90%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E3%80%91%E9%9B%86%E5%90%88/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240526221913.png" alt="微信截图_20240526221913"></p>
<h4><span id="关系图">关系图</span></h4><p><img src="/2024/05/26/%E3%80%90%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E3%80%91%E9%9B%86%E5%90%88/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240526222016.png" alt="微信截图_20240526222016"></p>
<h3><span id="2例题">2.例题</span></h3><h4><span id="关系矩阵的表示">关系矩阵的表示</span></h4><p><img src="/2024/05/26/%E3%80%90%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E3%80%91%E9%9B%86%E5%90%88/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240526221828.png" alt="微信截图_20240526221828"></p>
<h4><span id="笛卡尔积的幂集算法">笛卡尔积的幂集算法</span></h4><p><img src="/2024/05/26/%E3%80%90%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E3%80%91%E9%9B%86%E5%90%88/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240526221238.png" alt="微信图片_20240526221238"></p>
<h4><span id="关系图的表示">关系图的表示</span></h4><p><img src="/2024/05/26/%E3%80%90%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E3%80%91%E9%9B%86%E5%90%88/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240526222107.png" alt="微信截图_20240526222107"></p>
<h2><span id="六-关系的性质">六、关系的性质</span></h2><h3><span id="名词解释">名词解释</span></h3><h4><span id="自反的关系">自反的关系</span></h4><p>R是集合X上面的二元关系，如果对于每一个x ∈A,有xRx，即&lt;x,x&gt;∈R，就称R是自反的。</p>
<p>设集合S非空，S上的关系可以是自反的，是反自反的，也可以两者都不是。</p>
<p>Y是自反的，则：</p>
<ul>
<li>Iₓ ⊆ Y；（集合X上的恒等关系是自反关系，但自反关系却不一定是恒等关系）</li>
<li>Mᵧ主对角线上的元素都是1；</li>
<li>Gᵧ的每个结点均有环。</li>
</ul>
<h4><span id="反自反关系">反自反关系</span></h4><p>R是集合X上面的二元关系，如果对于每一个x ∈A,有xRx，即&lt;x,x&gt;!∈R，就称R是自反的。</p>
<p>Y是反自反的，则：</p>
<ul>
<li>Iₓ ∩ Y &#x3D;∅；</li>
<li>Mᵧ主对角线上的元素都是0；</li>
<li>Gᵧ的每个结点均无环。</li>
</ul>
<h4><span id="对称关系">对称关系</span></h4><p>对于关系里面x,y ∈ X，每当xRy，就有yRx，就X上面关系R是对称的。</p>
<p>Y是对称的，则：</p>
<ul>
<li>Mᵧ是对称的；</li>
<li>Gᵧ中任何两个结点之间若有有向边，必有两条方向相反的有向边。</li>
</ul>
<h4><span id="反对称关系">反对称关系</span></h4><p>对于关系里面x,y ∈ X，每当xRy和yRx，就有x&#x3D;y，就X上面关系R是反对称的。</p>
<ul>
<li>关系矩阵以对角线对称的元素不能同时为1，(但可为对称阵，同时为0)。</li>
<li>关系图中如果两个结点之间有有向弧，则不能成对出现。</li>
</ul>
<h4><span id="传递关系">传递关系</span></h4><p>对于x, y, z ∈ X，每当xRy, yRz时就有xRz,就称R在X上是传递的。</p>
<h4><span id="特殊关系的性质">特殊关系的性质</span></h4><p><strong>空关系</strong>： 反自反性，对称性，反对称性，传递性<br><strong>全域关系</strong>：自反性，对称性，传递性<br><strong>恒等关系</strong>：自反性，对称性，传递性</p>
<h4><span id="总结">总结</span></h4><ul>
<li>自反性：应该含有所有&lt;x, x&gt;<br>对称性：如果有&lt;x, y&gt;就应该有&lt;y, x&gt;<br>传递性：如果有&lt;x, y&gt;和&lt;y, z&gt;就应该有&lt;x, z&gt;</li>
<li>反自反性：不应该含有任何&lt;x, x&gt;<br>反对称性：如果有&lt;x, y&gt;就不应该有&lt;y, x&gt;</li>
</ul>
<h3><span id="例题">例题</span></h3><p><img src="/2024/05/26/%E3%80%90%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E3%80%91%E9%9B%86%E5%90%88/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240526231540.png" alt="微信截图_20240526231540"></p>
<p><img src="/2024/05/26/%E3%80%90%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E3%80%91%E9%9B%86%E5%90%88/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240526233116.png" alt="微信截图_20240526233116"></p>
<h2><span id="七-复合关系和逆关系">七、复合关系和逆关系</span></h2><h3><span id="1名词和定理">1.名词和定理</span></h3><h4><span id="复合关系">复合关系</span></h4><p>R是X到Y的关系，S是Y到Z的关系，则R和S的复合关系R°S称为R和S的复合关系，表示为: </p>
<p>RoS&#x3D;{&lt;x,z&gt;|x∈X且z∈Z(y∈Y ,&lt;x, y&gt;∈R且&lt;y,z&gt; ∈S)}</p>
<p>复合关系相当于一个个元素进行传递，看是否满足传递关系。</p>
<h4><span id="逆关系">逆关系</span></h4><p>R是X到Y的二元关系，把R中每一序偶的元素次序颠倒，得到的关系称为R的逆关系，记作Rᶜ</p>
<ul>
<li>xRy &#x3D;&#x3D; xRᶜy</li>
<li>互换R的关系矩阵的行和列，即得Rᶜ的关系矩阵（转置）</li>
<li>颠倒R的关系图中每条弧线的箭头方向，即得Rᶜ的关系图</li>
<li>空关系的逆是空关系</li>
<li>R&#x3D;Rᶜ，则说明R是对称的</li>
</ul>
<p><img src="/2024/05/26/%E3%80%90%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E3%80%91%E9%9B%86%E5%90%88/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240526235030.png" alt="微信截图_20240526235030"></p>
<p><img src="/2024/05/26/%E3%80%90%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E3%80%91%E9%9B%86%E5%90%88/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240526235224.png" alt="微信截图_20240526235224"></p>
<h4><span id="复合关系的结合律">复合关系的结合律</span></h4><p><img src="/2024/05/26/%E3%80%90%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E3%80%91%E9%9B%86%E5%90%88/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240526233655.png" alt="微信截图_20240526233655"></p>
<h4><span id="复合关系的幂集">复合关系的幂集</span></h4><p><img src="/2024/05/26/%E3%80%90%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E3%80%91%E9%9B%86%E5%90%88/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240526234315.png" alt="微信截图_20240526234315"></p>
<h4><span id="复合关系的矩阵表示">复合关系的矩阵表示</span></h4><p>（1）布尔加法 &#x3D;&#x3D; or</p>
<p>（2）布尔乘法 &#x3D;&#x3D; and</p>
<h3><span id="2例题">2.例题</span></h3><h4><span id="复合关系的矩阵表示">复合关系的矩阵表示</span></h4><p><img src="/2024/05/26/%E3%80%90%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E3%80%91%E9%9B%86%E5%90%88/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240526234530.png" alt="微信截图_20240526234530"></p>
<h2><span id="八-闭包运算">八、闭包运算</span></h2>]]></content>
      <tags>
        <tag>离散数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构 主观题汇总</title>
    <url>/2024/06/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%BB%E8%A7%82%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#1%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E6%9C%AF%E8%AF%AD%E7%9A%84%E9%97%AE%E9%A2%98">1.树的基本概念和术语的问题</a></li>
<li><a href="#2%E7%94%B1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%85%88%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E5%BA%8F%E5%88%97%E5%BB%BA%E6%A0%91">2.由二叉树的先序和中序序列建树</a></li>
<li><a href="#3%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%92%8C%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81">3.哈夫曼树和哈夫曼编码</a></li>
<li><a href="#4%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">4.图的基本概念</a></li>
<li><a href="#5%E7%94%BB%E5%87%BA%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E8%A1%A8%E5%B9%B6%E5%86%99%E5%87%BA%E5%9B%BE%E7%9A%84%E5%B9%BF%E5%BA%A6%E5%92%8C%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97">5.画出无向图的邻接表并写出图的广度和深度优先遍历序列</a></li>
<li><a href="#6%E6%B1%82%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91">6.求最小生成树</a></li>
<li><a href="#7%E6%B1%82%E5%8D%95%E6%BA%90%E7%82%B9%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84">7.求单源点的最短路径</a></li>
<li><a href="#10%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE">10.顺序查找</a></li>
<li><a href="#11%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%88%96%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE">11.二分查找或折半查找</a></li>
<li><a href="#12%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91">12.二叉排序树</a></li>
<li><a href="#13%E6%95%A3%E5%88%97%E8%A1%A8%E6%9F%A5%E6%89%BE%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%E6%B3%95">13.散列表查找——线性探测法</a></li>
<li><a href="#14%E5%93%88%E5%B8%8C%E8%A1%A8%E6%9F%A5%E6%89%BE%E9%93%BE%E5%9C%B0%E5%9D%80%E6%B3%95">14.哈希表查找——链地址法</a></li>
<li><a href="#15%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F">15.各种排序</a></li>
</ul>
<!-- tocstop -->

<p>[TOC]</p>
<h3><span id="1树的基本概念和术语的问题">1.树的基本概念和术语的问题</span></h3><p><strong>设在树中，结点x是结点y的双亲时，用(x,y)来表示树变。已知一棵树边的集合为：{(i,m),(i,n),(b,e),(e,i),(b,d),(a,b),(g,j),(g,k),(c,g),(c,f),(h,l),(c,h),(a,c)}，回答下列问题：</strong><br>（1）用树形表示法（带字母的圆圈和线）画出此树<br>（2） 哪个是根结点<br>（3） 哪些是叶结点？<br>（4） 哪个是g的双亲？<br>（5） 哪些是g的祖先？<br>（6） 哪些是g的孩子？<br>（7） 哪些是e的子孙？<br>（8） 哪些是e的兄弟？哪些是f的兄弟？<br>（9） 结点b和n的层次各是多少？<br>（10） 树的深度是多少？<br>（11） 以结点c为根的子树的深度是多少？<br>（12） 树的度数是多少？</p>
<p><img src="/2024/06/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%BB%E8%A7%82%E9%A2%98%E6%B1%87%E6%80%BB/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240608083207.png" alt="微信截图_20240608083207"></p>
<p>a是根结点；</p>
<p>m、n、d、j、k、f、l是叶子结点；</p>
<p>c是g的双亲；</p>
<p>a是g的祖先；</p>
<p>j、k是g的孩子；</p>
<p>i、m、n是e的子孙；</p>
<p>d是e的兄弟，g、h是f的兄弟；</p>
<p>b的层次是2，n的层次是5；</p>
<p>树的深度是5；</p>
<p>c的深度是3；</p>
<p>树的度数是3。</p>
<h3><span id="2由二叉树的先序和中序序列建树">2.由二叉树的先序和中序序列建树</span></h3><img src="/2024/06/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%BB%E8%A7%82%E9%A2%98%E6%B1%87%E6%80%BB/20180523165909343-1718009007546-1.png" alt="20180523165909343" style="zoom:80%;">

<p><strong>假设一棵二叉树的先序序列为EBADCFHGIKJ和中序序列为ABCDEFGHIJK，要求：</strong></p>
<p>（1）画出这棵二叉树；</p>
<p>（2）请给出其后序序列和层序序列。</p>
<img src="/2024/06/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%BB%E8%A7%82%E9%A2%98%E6%B1%87%E6%80%BB/微信截图_20240608084403-1718009026051-3.png" alt="微信截图_20240608084403" style="zoom:80%;">

<p>后序：ACDBGJKIHFE</p>
<p>层序：EBFADHCGIKJ</p>
<h3><span id="3哈夫曼树和哈夫曼编码">3.哈夫曼树和哈夫曼编码</span></h3><p><strong>求哈夫曼树：</strong></p>
<p>（１）根据n个给定的权值构成n棵二叉树的森林，森林中每一棵树只有一个带权的根结点</p>
<p>（２）在森林中，选取两棵根结点的权值最小的树作为左右子树，构造一棵新的二叉树，且设置新的二叉树的根结点的权值为其左右子树上根结点的权值之和</p>
<p>（３）在森林中删除这两棵树，同时将新得到的二叉树加入到森林中</p>
<p>（４）重复（２）和（３），直到森林中只有一棵树为止，这棵树即为哈夫曼树</p>
<p><strong>求哈夫曼编码：</strong></p>
<p>左分支为0，右分支为1。</p>
<p><strong>假设用于通信的电文仅由8个字母组成，字母在电文中出现的频率分别为0.09，0.16，0.02，0.06，0.32，0.03，0.21，0.11。</strong></p>
<p>（1）画出哈夫曼树；</p>
<p>（2）根据哈夫曼树给这8个字母设计哈夫曼编码，计算WPL值；</p>
<p>（3）设计另一种由二进制表示的等长编码方案；</p>
<p>（4） 对于上述实例，计算两种方案的平均编码长度，分析两种方案的优缺点。</p>
<p><img src="/2024/06/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%BB%E8%A7%82%E9%A2%98%E6%B1%87%E6%80%BB/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240608120058.png" alt="微信截图_20240608120058"></p>
<p><img src="/2024/06/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%BB%E8%A7%82%E9%A2%98%E6%B1%87%E6%80%BB/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240608121225.png" alt="微信截图_20240608121225"></p>
<p>对于上述两种方案，等长编码的构造比哈夫曼编码的构造简单。等长编码的译码简单。但是哈夫曼编码是最优前缀编码。利用哈夫曼编码对文件进行编码，使该文件压缩后对应的二进制文件的长度最短。而等长编码使该二进制文件的长度不短。哈夫曼编码的构造和译码相对等长编码复杂些。</p>
<h3><span id="4图的基本概念">4.图的基本概念</span></h3><p>请根据下图给出：</p>
<p>（1）每个顶点的度</p>
<p>（2）邻接矩阵</p>
<p>（3）邻接表(边结点序号从小到大)</p>
<p><img src="/2024/06/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%BB%E8%A7%82%E9%A2%98%E6%B1%87%E6%80%BB/51c238b5-954b-4348-af1a-f29986300fa6.png" alt="51c238b5-954b-4348-af1a-f29986300fa6"></p>
<p><img src="/2024/06/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%BB%E8%A7%82%E9%A2%98%E6%B1%87%E6%80%BB/0fa7c377-cb8e-4ccb-8c37-96bddd5aa3d2.jpg" alt="0fa7c377-cb8e-4ccb-8c37-96bddd5aa3d2"></p>
<p><img src="/2024/06/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%BB%E8%A7%82%E9%A2%98%E6%B1%87%E6%80%BB/aca2a79d-0232-4de6-96b0-1f5b0d9385a3.jpg" alt="aca2a79d-0232-4de6-96b0-1f5b0d9385a3"></p>
<p><img src="/2024/06/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%BB%E8%A7%82%E9%A2%98%E6%B1%87%E6%80%BB/4b5df1b6-2e31-4120-a0c3-af870755f3fe.png" alt="4b5df1b6-2e31-4120-a0c3-af870755f3fe"></p>
<h3><span id="5画出无向图的邻接表并写出图的广度和深度优先遍历序列">5.画出无向图的邻接表并写出图的广度和深度优先遍历序列</span></h3><p>(1)写出下图的邻接表(边结点序号从小到大)，<br>(2)写出从顶点3出发的广度优先搜索序列和深度优先搜索序列，顶点之间用空格隔开。约定以结点小编号优先次序访问。</p>
<p><img src="/2024/06/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%BB%E8%A7%82%E9%A2%98%E6%B1%87%E6%80%BB/8013d897-f5b6-4f3c-8fc5-39674a21cc16.png" alt="8013d897-f5b6-4f3c-8fc5-39674a21cc16"></p>
<p><img src="/2024/06/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%BB%E8%A7%82%E9%A2%98%E6%B1%87%E6%80%BB/user-uploads_1639164144315953152_2024-5-21_1716235096-488f3a33-1844-4da5-a857-1ac694da7a5f.jpg" alt="user-uploads_1639164144315953152_2024-5-21_1716235096-488f3a33-1844-4da5-a857-1ac694da7a5f"></p>
<p><img src="/2024/06/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%BB%E8%A7%82%E9%A2%98%E6%B1%87%E6%80%BB/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240616114026.jpg" alt="微信图片_20240616114026"></p>
<p>广度：3 1 2 4 6 0 5</p>
<p>深度：3 1 0 2 4 5 6</p>
<h3><span id="6求最小生成树">6.求最小生成树</span></h3><p>已知一个无向图的顶点集V和边集E分别为：V&#x3D;{1,2,3,4,5,6,7};</p>
<p>E&#x3D;{(1,2)3, (1,3)5, (1,4)8, (2,5)10, (2,3)6, (3,4)15, (3,5)12, (3,6)9, (4,6)4, (4,7)20, (5,6)18, (6,7)25}; &#x2F;&#x2F;每条边后面的数代表权值</p>
<p>请用克鲁斯卡尔算法得到最小生成树，试写出在最小生成树中依次得到的各条边。</p>
<p><img src="/2024/06/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%BB%E8%A7%82%E9%A2%98%E6%B1%87%E6%80%BB/user-uploads_1639164144315953152_2024-5-31_1717163110-28a492eb-ccc1-4eab-8f7c-a68b9a0db883.jpg" alt="user-uploads_1639164144315953152_2024-5-31_1717163110-28a492eb-ccc1-4eab-8f7c-a68b9a0db883"></p>
<h3><span id="7求单源点的最短路径">7.求单源点的最短路径</span></h3><p>下图所示的带权有向图G，给出从顶点V1到其余各个顶点的最短路径及其路径长度。</p>
<p><img src="/2024/06/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%BB%E8%A7%82%E9%A2%98%E6%B1%87%E6%80%BB/2364c788-a821-4c59-993f-2540331d84ae.jpg" alt="2364c788-a821-4c59-993f-2540331d84ae"></p>
<p><img src="/2024/06/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%BB%E8%A7%82%E9%A2%98%E6%B1%87%E6%80%BB/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240616114650.png" alt="微信图片_20240616114650"></p>
<h3><span id="10顺序查找">10.顺序查找</span></h3><p>根据教材中设置监视哨的顺序查找算法，回答如下问题：</p>
<p>（1）简述设置监视哨的顺序查找算法中监视哨的作用，（2）查找表中哪个数据元素是哨兵？（3）查找方向是顺序方向查找还是逆序方向查找？（4）n个元素的查找表进行设置监视哨的顺序查找，需要进行多少次比较后查找失败？</p>
<p>答案：</p>
<p>（1）设置监视哨，可以免去查找过程中每一步都要检测整个表是否查找完毕，可以使进行一次查找所需的平均时间几乎减少一半，提高了查找效率。</p>
<p>（2）顺序表ST的0单元</p>
<p>（3）逆序</p>
<p>（4）n+1次</p>
<h3><span id="11二分查找或折半查找">11.二分查找或折半查找</span></h3><p>已知如下11个元素的有序表（8,16,19,23,39,52,63,77,81,88,90）,要求：<br>（1）画出其二分查找的判定树；<br>（2）给出查找元素88和17的折半查找过程；<br>（3）设有序表表长为n，查找成功或不成功时和给定值进行比较的关键字个数至多分别为多少？<br>（4）给出二分查找的时间复杂度。</p>
<p><img src="/2024/06/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%BB%E8%A7%82%E9%A2%98%E6%B1%87%E6%80%BB/a41dc4ba-73ad-49b5-8d00-17554aed31f9.jpg" alt="a41dc4ba-73ad-49b5-8d00-17554aed31f9"></p>
<p><img src="/2024/06/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%BB%E8%A7%82%E9%A2%98%E6%B1%87%E6%80%BB/user-uploads_1639164144315953152_2024-6-6_1717688367-4365e094-635d-4768-ba6b-086bee11148c.jpg" alt="user-uploads_1639164144315953152_2024-6-6_1717688367-4365e094-635d-4768-ba6b-086bee11148c"></p>
<p>（3）查找成功和给定值进行比较的关键字个数至多都是（log₂n）的向下取整再加一</p>
<p>查找不成功和给定值进行比较的关键字个数等于该路径上内部结点个数，至多不超过（log₂n）的向下取整再加一</p>
<p>（4）O（log₂n）</p>
<h3><span id="12二叉排序树">12.二叉排序树</span></h3><p>在一个空的二叉排序树中依次插入关键字序列为12,7,17,11,16,2,13,9,21,4，要求：<br>（1）画出所得到的二叉排序树；<br>（2）查找关键字9和22各自跟哪些关键字进行了比较？<br>（3）二叉排序树的平均查找长度(ASL)与其形态有关，对n个元素构建的二叉排序树进行查找，最好和最坏的ASL分别是多少？</p>
<p>保证左子树小于根节点，右子树大于根节点</p>
<p><img src="/2024/06/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%BB%E8%A7%82%E9%A2%98%E6%B1%87%E6%80%BB/user-uploads_1639164144315953152_2024-6-7_1717690536-b9f28c4c-9993-4ef4-8706-c642776c854b.jpg" alt="user-uploads_1639164144315953152_2024-6-7_1717690536-b9f28c4c-9993-4ef4-8706-c642776c854b"></p>
<p>(2)9：12、7、11、9</p>
<p>22：12、17、21</p>
<p>（3）最好：log₂n</p>
<p>最坏：（n+1)&#x2F;2</p>
<h3><span id="13散列表查找线性探测法">13.散列表查找——线性探测法</span></h3><p>设哈希表的地址范围为0～17，哈希函数为：H（key）&#x3D;key%16。用线性探测法处理冲突，输入关键字序列：（10，24，32，17，31，30，46，47，40，63，49），构造哈希表，试回答下列问题：<br>① 画出哈希表的示意图；<br>② 若查找关键字63，需要依次与哪些关键字进行比较？<br>③ 若查找关键字60，需要依次与哪些关键字比较？<br>④ 假定每个关键字的查找概率相等，求查找成功时的平均查找长度。<br><img src="/2024/06/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%BB%E8%A7%82%E9%A2%98%E6%B1%87%E6%80%BB/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240616121417.png" alt="微信截图_20240616121417"></p>
<h3><span id="14哈希表查找链地址法">14.哈希表查找——链地址法</span></h3><p><img src="/2024/06/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%BB%E8%A7%82%E9%A2%98%E6%B1%87%E6%80%BB/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240616121606.png" alt="微信截图_20240616121606"></p>
<h3><span id="15各种排序">15.各种排序</span></h3><p>（1）设待排序的关键字序列为{12，2，16，30，28，10，16*，20，6，18}，试分别写出使用以下排序方法，每趟排序结束后关键字序列的状态。<br>① 直接插入排序<br>④ 冒泡排序<br>⑤ 快速排序<br>⑥ 简单选择排序<br>⑦ 堆排序<br>⑧ 二路归并排序</p>
<p>①直接插入排序</p>
<p><img src="/2024/06/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%BB%E8%A7%82%E9%A2%98%E6%B1%87%E6%80%BB/20191229110240491.png" alt="20191229110240491"></p>
<p>④ 冒泡排序</p>
<p><img src="/2024/06/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%BB%E8%A7%82%E9%A2%98%E6%B1%87%E6%80%BB/20191229155437320.png" alt="20191229155437320"></p>
<p>⑤ 快速排序</p>
<p><img src="/2024/06/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%BB%E8%A7%82%E9%A2%98%E6%B1%87%E6%80%BB/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240616121942.png" alt="微信截图_20240616121942"></p>
<p>⑥ 简单选择排序<br>将最小的选出来放在前面<br>2 [12 16 30 28 10 16* 20 6 18]<br>2 6 [16 30 28 10 16* 20 12 18]<br>2 6 10 [30 28 16 16* 20 12 18]<br>2 6 10 12 [28 16 16* 20 30 18]<br>2 6 10 12 16 [28 16* 20 30 18]<br>2 6 10 12 16 16* [28 20 30 18]<br>2 6 10 12 16 16* 18 [20 30 28]<br>2 6 10 12 16 16* 18 20 [28 30]<br>2 6 10 12 16 16* 18 20 28 [30]</p>
<p>⑧ 二路归并排序<br>[2 12] [16 30] [10 28] [16 * 20] [6 18]<br>[2 12 16 30] [10 16* 20 28] [ 6 18 ]<br>[2 10 12 16 16* 20 28 30] [6 18]<br>2 6 10 12 16 16* 18 20 28 30</p>
]]></content>
      <tags>
        <tag>数据结构笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构课设报告——用栈和队列做表达式求值</title>
    <url>/2024/05/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E8%AE%BE%E6%8A%A5%E5%91%8A%E2%80%94%E2%80%94%E7%94%A8%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E5%81%9A%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90">【案例分析】</a></li>
<li><a href="#%E5%AE%9E%E9%AA%8C%E8%BF%87%E7%A8%8B">【实验过程】</a><ul>
<li><a href="#1%E5%AE%9A%E4%B9%89">1.定义</a></li>
<li><a href="#2%E7%94%A8map%E5%88%A4%E6%96%AD%E4%BC%98%E5%85%88%E7%BA%A7">2.用map判断优先级</a></li>
<li><a href="#3%E5%A4%84%E7%90%86%E5%A4%9A%E4%BD%8D%E6%95%B0%E9%97%AE%E9%A2%98">3.处理多位数问题</a></li>
<li><a href="#4%E5%A4%84%E7%90%86%E6%8B%AC%E5%8F%B7%E9%97%AE%E9%A2%98">4.处理括号问题</a></li>
<li><a href="#5%E8%BE%93%E5%85%A5%E5%8E%BB%E6%8E%89%E7%A9%BA%E6%A0%BC">5.输入：去掉空格</a></li>
</ul>
</li>
<li><a href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81">【完整代码】</a></li>
</ul>
<!-- tocstop -->

<p>[TOC]</p>
<h2><span id="案例分析">【案例分析】</span></h2><p>已知表达式&#x3D;操作数+操作符，其中操作数是123这样的数字，操作符是运算符和界限符（如括号）。</p>
<p>做实验前先理清：</p>
<p>1.<strong>四则运算的优先性</strong>：先乘除后加减，括号优先，从左到右。</p>
<p>2.<strong>中缀表达式转换成后缀表达式</strong>：</p>
<ul>
<li>遇到数字就直接输出到后缀表达式中，遇到操作符就判断其优先级，并将其压入栈中。</li>
<li>如果栈顶元素的优先级大于等于当前操作符，则先将栈顶元素弹出并输出到后缀表达式中，再将当前操作符压入栈中。</li>
<li>如果遇到了左括号，则直接将其压入栈中，如果遇到了右括号，则弹出栈中的元素，直到遇到了左括号为止，并将这些元素输出到后缀表达式中。</li>
<li>最后，将栈中剩余的元素依次弹出，并输出到后缀表达式中。</li>
</ul>
<p>3.<strong>后缀表达式计算</strong>：遍历后缀表达式，如果遇到数字则直接入栈，如果遇到操作符，则弹出栈顶的两个元素，进行计算后将结果入栈。最后留在栈里的就是最终结果。</p>
<h2><span id="实验过程">【实验过程】</span></h2><h3><span id="1定义">1.定义</span></h3><p>该段定义了结构体element，存放操作数num和操作符op，供stack和queue容器随时进出。</p>
<p>并在里面定义了布尔变量flag，用于识别中缀表达式当前字符是操作数还是操作符。</p>
<p>最后调用了map用于判断运算符的优先级。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct element&#123;</span><br><span class="line">double num; //存放操作数</span><br><span class="line">char op; //存放操作符</span><br><span class="line">bool flag; //true 表示操作数，false 表示操作符 </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">string str; //输入的中缀表达式</span><br><span class="line">stack&lt;element&gt;s; //操作符栈</span><br><span class="line">queue&lt;element&gt;q; //后缀表达式队列</span><br><span class="line">map&lt;char,int&gt;op; //判断优先级,字符到整型的映射 </span><br></pre></td></tr></table></figure>

<h3><span id="2用map判断优先级">2.用map判断优先级</span></h3><p>1&lt;2，先乘除后加减（括号另外考虑）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">map&lt;char,int&gt;op; //判断优先级,字符到整型的映射 </span><br><span class="line"></span><br><span class="line">op[&#x27;+&#x27;] = op[&#x27;-&#x27;] = 1;</span><br><span class="line">op[&#x27;*&#x27;] = op[&#x27;/&#x27;] = 2;</span><br></pre></td></tr></table></figure>

<p>temp.op定义为操作符栈的当前操作符</p>
<p>s.top().op是操作符栈的栈顶操作符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while(!s.empty() &amp;&amp; op[temp.op]&lt;=op[s.top().op])&#123; //当前操作符栈的优先级低于栈顶，并且栈不为空 </span><br><span class="line">  q.push(s.top());</span><br><span class="line">  s.pop();</span><br><span class="line"> &#125;</span><br><span class="line"> s.push(temp);</span><br><span class="line"> index++;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3><span id="3处理多位数问题">3.处理多位数问题</span></h3><p>一位数的方法：检测到当前读取的字符是“数字”，temp转为1，表示操作数，把字符转化成阿拉伯数并进队列。</p>
<p>多位数的方法：读取到第一个数字后进行循环判断，<strong>一直到读取完毕或者遇到不是数字的操作符</strong>，若进入循环，那么此次读入的数为 前一个 * 10 + 现在的数字</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(str[index]&gt;=&#x27;0&#x27; &amp;&amp; str[index]&lt;=&#x27;9&#x27;)&#123; //当前读取的是数字</span><br><span class="line"> temp.flag = true;</span><br><span class="line"> temp.num = str[index++]-&#x27;0&#x27; ; //转化成数字</span><br><span class="line">   while(index&gt;str.size() &amp;&amp; str[index]&gt;=&#x27;0&#x27; &amp;&amp; str[index]&lt;&#x27;9&#x27;)&#123; //处理多位数 </span><br><span class="line">   temp.num = temp.num*10 + str[index]-&#x27;0&#x27;;</span><br><span class="line">   index++; //下一位 </span><br><span class="line"> &#125;</span><br><span class="line"> q.push(temp);//进后缀表达式队列 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="4处理括号问题">4.处理括号问题</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(str[index] ==&#x27;(&#x27;) &#123;</span><br><span class="line"> s.push(temp);//对左括号，直接进操作符栈</span><br><span class="line">  index++; //下一位</span><br><span class="line">  continue;</span><br><span class="line">&#125;else if(str[index]==&#x27;)&#x27;)&#123;</span><br><span class="line">	while(s.top().op!=&#x27;(&#x27;)&#123; //为右括号匹配左括号 </span><br><span class="line">		q.push(s.top()); </span><br><span class="line">	s.pop(); //出栈元素加入到队列</span><br><span class="line">   &#125;</span><br><span class="line"> s.pop();//将左括号出栈 </span><br><span class="line"> index++;</span><br><span class="line"> continue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">temp.flag=false;</span><br><span class="line">temp.op=str[index];</span><br></pre></td></tr></table></figure>

<h3><span id="5输入去掉空格">5.输入：去掉空格</span></h3><p>基于map</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for(int i = 0; i &lt; str.size(); i++) &#123;		//去掉空格 </span><br><span class="line">	if(str[i] == &#x27; &#x27;) &#123;</span><br><span class="line">	str.erase(str.begin() + i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br></pre></td></tr></table></figure>



<h2><span id="完整代码">【完整代码】</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;map&gt; </span><br><span class="line"></span><br><span class="line">struct element&#123;</span><br><span class="line">double num; //存放操作数</span><br><span class="line">char op; //存放操作符</span><br><span class="line">bool flag; //true 表示操作数，false 表示操作符 </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">string str; //输入的中缀表达式</span><br><span class="line">stack&lt;element&gt;s; //操作符栈</span><br><span class="line">queue&lt;element&gt;q; //后缀表达式队列</span><br><span class="line">map&lt;char,int&gt;op; //判断优先级,字符到整型的映射 </span><br><span class="line"></span><br><span class="line">int suffix()&#123;</span><br><span class="line">//将中缀表达式str转换成后缀表达式 </span><br><span class="line">element temp;</span><br><span class="line">int index = 0; //当前位置 </span><br><span class="line">while(index &lt; str.size()) &#123;</span><br><span class="line">	</span><br><span class="line">if(str[index]&gt;=&#x27;0&#x27; &amp;&amp; str[index]&lt;=&#x27;9&#x27;)&#123; //当前读取的是数字</span><br><span class="line"> temp.flag = true;</span><br><span class="line"> temp.num = str[index++]-&#x27;0&#x27; ; //转化成数字</span><br><span class="line">  while(index&lt;str.size() &amp;&amp; str[index]&gt;=&#x27;0&#x27; &amp;&amp; str[index]&lt;&#x27;9&#x27;)&#123; //处理多位数 </span><br><span class="line">   temp.num = temp.num*10 + str[index]-&#x27;0&#x27;;</span><br><span class="line">   index++; //下一位 </span><br><span class="line"> &#125;</span><br><span class="line"> q.push(temp);//进后缀表达式队列 </span><br><span class="line">&#125;else&#123;</span><br><span class="line"> temp.flag = false; //当前读取的是符号</span><br><span class="line"> temp.op = str[index];</span><br><span class="line"></span><br><span class="line"> if(str[index] ==&#x27;(&#x27;) &#123;</span><br><span class="line">  s.push(temp);//对左括号，直接进操作符栈</span><br><span class="line">   index++; //下一位</span><br><span class="line">   continue;</span><br><span class="line"> &#125;else if(str[index]==&#x27;)&#x27;)&#123;</span><br><span class="line"> 	while(s.top().op!=&#x27;(&#x27;)&#123; //为右括号匹配左括号 </span><br><span class="line"> 		q.push(s.top()); </span><br><span class="line">		s.pop(); //出栈元素加入到队列</span><br><span class="line">    &#125;</span><br><span class="line">  s.pop();//将左括号出栈 </span><br><span class="line">  index++;</span><br><span class="line">  continue;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> temp.flag=false;</span><br><span class="line"> temp.op=str[index];</span><br><span class="line"></span><br><span class="line"> while(!s.empty() &amp;&amp; op[temp.op]&lt;=op[s.top().op])&#123; //当前操作符栈的优先级低于栈顶，并且栈不为空 </span><br><span class="line">  q.push(s.top());</span><br><span class="line">  s.pop();</span><br><span class="line"> &#125;</span><br><span class="line"> s.push(temp);</span><br><span class="line"> index++;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">while(!s.empty())&#123;</span><br><span class="line"> q.push(s.top());</span><br><span class="line"> s.pop();</span><br><span class="line">&#125;</span><br><span class="line">return 1;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">double cal()&#123;</span><br><span class="line">double top1,top2;</span><br><span class="line">element cur,temp;</span><br><span class="line">while(!q.empty())&#123; //后缀表达式队列从头依次读取</span><br><span class="line"> cur = q.front(); //cur记录队首</span><br><span class="line"> q.pop(); //出队列 </span><br><span class="line"> if(cur.flag==true)&#123;</span><br><span class="line">   s.push(cur); //对操作数入栈 </span><br><span class="line"> &#125;else&#123;//遇到操作符，对栈里的操作数出栈 </span><br><span class="line">   top1 = s.top().num;</span><br><span class="line">   s.pop();</span><br><span class="line">   top2 = s.top().num;</span><br><span class="line">   s.pop();</span><br><span class="line">   temp.flag=true; //记录运算结果 </span><br><span class="line">   if(cur.op == &#x27;+&#x27;) temp.num = top2+top1;</span><br><span class="line">   if(cur.op == &#x27;-&#x27;) temp.num = top2-top1;</span><br><span class="line">   if(cur.op == &#x27;*&#x27;) temp.num = top2*top1;</span><br><span class="line">   if(cur.op == &#x27;/&#x27;) temp.num = top2/top1;</span><br><span class="line">   s.push(temp);//计算结果进栈 </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return s.top().num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	op[&#x27;+&#x27;] = op[&#x27;-&#x27;] = 1;</span><br><span class="line">	op[&#x27;*&#x27;] = op[&#x27;/&#x27;] = 2;</span><br><span class="line">	getline(cin,str);</span><br><span class="line">	while(!s.empty())&#123;</span><br><span class="line">		s.pop(); //清空 </span><br><span class="line">	&#125;</span><br><span class="line">	for(int i = 0; i &lt; str.size(); i++) &#123;		//去掉空格 </span><br><span class="line">	if(str[i] == &#x27; &#x27;) &#123;</span><br><span class="line">	str.erase(str.begin() + i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	suffix();</span><br><span class="line">	cout&lt;&lt;&quot;计算结果为：&quot;&lt;&lt;cal()&lt;&lt;endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>数据结构笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构课设报告——用顺序表实现图书信息管理系统</title>
    <url>/2024/03/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E8%AE%BE%E6%8A%A5%E5%91%8A%E2%80%94%E2%80%94%E7%94%A8%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%AE%9E%E7%8E%B0%E5%9B%BE%E4%B9%A6%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90">【案例分析】</a></li>
<li><a href="#%E5%AE%9E%E9%AA%8C%E8%BF%87%E7%A8%8B">【实验过程】</a><ul>
<li><a href="#1%E9%A2%84%E5%85%88%E5%AE%9A%E4%B9%89">1.预先定义</a></li>
<li><a href="#2%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96">2.顺序表的初始化</a></li>
<li><a href="#3%E5%BD%95%E5%85%A5%E5%9B%BE%E4%B9%A6%E4%BF%A1%E6%81%AF">3.录入图书信息</a></li>
<li><a href="#4%E6%9F%A5%E6%89%BE%E5%9B%BE%E4%B9%A6%E4%BF%A1%E6%81%AF">4.查找图书信息</a></li>
</ul>
</li>
<li><a href="#5%E6%B7%BB%E5%8A%A0%E4%B9%A6%E7%B1%8D%E4%BF%A1%E6%81%AF">5.添加书籍信息</a></li>
<li><a href="#6%E5%88%A0%E9%99%A4%E4%B9%A6%E7%B1%8D">6.删除书籍</a></li>
<li><a href="#7%E4%BF%AE%E6%94%B9%E4%B9%A6%E7%B1%8D%E4%BF%A1%E6%81%AF">7.修改书籍信息</a></li>
<li><a href="#8%E6%8E%92%E5%BA%8F">8.排序</a></li>
</ul>
<ul>
<li><a href="#%E4%BB%A3%E7%A0%81">【代码】</a></li>
</ul>
<!-- tocstop -->

<p>[TOC]</p>
<h2><span id="案例分析">【案例分析】</span></h2><p>将图书馆信息管理系统抽象成</p>
<p>线性表，每本书作为线性表的一个元素，其中包括以下功能：</p>
<p>1.查找。通过输入关键词，返回该书的所有信息。</p>
<p>2.插入。添加新的书籍。</p>
<p>3.删除。删除书籍。</p>
<p>4.修改。调用查找功能，找到对应书籍并修改。</p>
<p>5.排序。</p>
<p>6.计数。</p>
<h2><span id="实验过程">【实验过程】</span></h2><h3><span id="1预先定义">1.预先定义</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`#include&lt;new&gt;`</span><br><span class="line">`#include&lt;fstream&gt; //对文件输入输出` </span><br><span class="line">`#include&lt;iostream&gt;  //对屏幕上输入输出`</span><br><span class="line">`using namespace std;`</span><br><span class="line">`#define maxsize 1000`</span><br><span class="line">`typedef struct&#123;`</span><br><span class="line">	`char no[20];  //图书编号` </span><br><span class="line">	`char name[50];  //书名` </span><br><span class="line">	`float price;  //定价` </span><br><span class="line">`&#125;book;`</span><br><span class="line">`typedef struct&#123;`</span><br><span class="line">	`book *elem;   //存储空间的基地址`</span><br><span class="line">	`int len;     //表长`</span><br><span class="line">`&#125;SqList;  //图书表的顺序存储结构为SqList` </span><br></pre></td></tr></table></figure>

<p>之后，在main函数中设置 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`SqList L;` </span><br></pre></td></tr></table></figure>



<h3><span id="2顺序表的初始化">2.顺序表的初始化</span></h3><p>为顺序表分配一个预定义大小的数组空间，并把表长设定为0。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`int initlist(SqList &amp;L)`</span><br><span class="line">`//构造空表` </span><br><span class="line">`&#123;`</span><br><span class="line">	`L.elem = new book[maxsize];`</span><br><span class="line">	`if(!L.elem)  exit(0);  //存储分配失败，不知为何，在这个地方用return -1会导致后续程序出错`</span><br><span class="line">	`L.len=0;`</span><br><span class="line">	`return 1;` </span><br><span class="line">`&#125;`</span><br></pre></td></tr></table></figure>

<p>new int的作用是分配内存，找到一个连续的内存块，然后返回一个指向该内存的指针。</p>
<p>如：<code>int* a = new int;</code></p>
<p>这样，我们为a分配了一个4字节的内存。</p>
<p>如果想分配一个数组，就在数组名后面加[]，里面输入数字。</p>
<h3><span id="3录入图书信息">3.录入图书信息</span></h3><p>在开启图书馆管理功能前，有必要先录入书籍信息，在这里，我用文件读取数组信息的方法实现批量录入。</p>
<p><em>001 NineteenEightyFour 25.00</em><br><em>002 HarryPotter 400.00</em><br><em>003 GonewiththeWind 40.00</em><br><em>004 AnimalFarm 10.00</em><br><em>005 LePetitPrince 22.00</em><br><em>006 ToKillaMockingBird 32.00</em><br><em>007 Siddhartha 32.00</em><br><em>008 DifferentSeasons 29.90</em><br><em>009 FlowersforAlgernon 36.00</em><br><em>010 RiverTown 36.00</em></p>
<p>关于文件读写的笔记，我写在另一篇文章。</p>
<h3><span id="4查找图书信息">4.查找图书信息</span></h3><p>由于图书一共录入三种信息，所以我们可以分别用三种信息（编号，名字，价格）进行查找。编号和名字是char[]字符数组，借助函数**strcmp(新字符，待比较旧字符)**，如果函数值为0，说明两个字符相同，完成查找；这时我们借助一个初始值为0的计数器joke，如果查找成功，joke++，如果遍历结束还是找不到，joke值则始终为0。</p>
<p>如果不要求键入信息十分精准，通过关键字即可返回，则可以使用函数<strong>strstr（母字符串，子字符串）</strong>，注意定义指针。它的写法是：</p>
<p><code>#include&lt;cstring&gt;//头文件</code></p>
<p><code>char new[20];</code></p>
<p><code>char old[20];</code></p>
<p><code>char* a=strstr(old,new);</code></p>
<p><code>if(a==NULL)  cout&lt;&lt;&quot;not found&quot;&lt;&lt;endl; //此时说明两个字符完全不相同</code></p>
<p><u>注意：strstr函数区分大小写。</u></p>
<h4><span id="1根据图书编号查找">（1）根据图书编号查找</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`void Findno(SqList L)`</span><br><span class="line">`//查找书号` </span><br><span class="line">`&#123;`</span><br><span class="line">	`char findno[20];`</span><br><span class="line">	`cin&gt;&gt;findno;`</span><br><span class="line">	`int joke=0;`</span><br><span class="line">	`cout&lt;&lt;&quot;图书编号&quot;&lt;&lt;setw(20)&lt;&lt;&quot;书名&quot;&lt;&lt;setw(30)&lt;&lt;&quot;价格&quot;&lt;&lt;endl;`</span><br><span class="line">	`for(int i=0;i&lt;L.len;i++)&#123;`</span><br><span class="line">		`if(strcmp(findno,L.elem[i].no)==0)&#123;`</span><br><span class="line">			`joke++;`</span><br><span class="line">			`cout&lt;&lt;fixed&lt;&lt;setprecision(2);`</span><br><span class="line">			`cout&lt;&lt;L.elem[i].no&lt;&lt;setw(30)&lt;&lt;L.elem[i].name&lt;&lt;setw(30)&lt;&lt;L.elem[i].price&lt;&lt;endl;`</span><br><span class="line">		`&#125;`</span><br><span class="line">	`&#125;`</span><br><span class="line">	`if(joke==0) cout&lt;&lt;&quot;404 NOT FOUND&quot;&lt;&lt;endl;`</span><br><span class="line">`&#125;`</span><br></pre></td></tr></table></figure>



<h4><span id="2根据书名查找">（2）根据书名查找</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`void Findname(SqList L)`</span><br><span class="line">`//查找书名`</span><br><span class="line">`&#123;`</span><br><span class="line">	`char findname[50];`</span><br><span class="line">	`cin&gt;&gt;findname;`</span><br><span class="line">	`int joke=0;`</span><br><span class="line">	`cout&lt;&lt;&quot;图书编号&quot;&lt;&lt;setw(20)&lt;&lt;&quot;书名&quot;&lt;&lt;setw(30)&lt;&lt;&quot;价格&quot;&lt;&lt;endl;`</span><br><span class="line">	`for(int i=0;i&lt;L.len;i++)&#123;`</span><br><span class="line">	`char *b=strstr(L.elem[i].name,findname);`</span><br><span class="line">		`if(b!=NULL)&#123;`</span><br><span class="line">			`joke++;`</span><br><span class="line">			`cout&lt;&lt;L.elem[i].no&lt;&lt;setw(30)&lt;&lt;L.elem[i].name&lt;&lt;setw(30)&lt;&lt;L.elem[i].price&lt;&lt;endl;`</span><br><span class="line">		`&#125;`</span><br><span class="line">	`&#125;`</span><br><span class="line">	`if(joke==0) cout&lt;&lt;&quot;404 NOT FOUND&quot;&lt;&lt;endl;`</span><br><span class="line">	 ``</span><br><span class="line">`&#125;`</span><br></pre></td></tr></table></figure>



<h4><span id="3根据价格查找">（3）根据价格查找</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`void Findprice(SqList L)`</span><br><span class="line">`//查找价格` </span><br><span class="line">`&#123;`</span><br><span class="line">	`float findprice;`</span><br><span class="line">	`cin&gt;&gt;findprice;`</span><br><span class="line">	`int joke=0;`</span><br><span class="line">	`cout&lt;&lt;&quot;图书编号&quot;&lt;&lt;setw(20)&lt;&lt;&quot;书名&quot;&lt;&lt;setw(30)&lt;&lt;&quot;价格&quot;&lt;&lt;endl;`</span><br><span class="line">	`for(int i=0;i&lt;L.len;i++)&#123;`</span><br><span class="line">		`if(findprice==L.elem[i].price)&#123;`</span><br><span class="line">			`joke++;`</span><br><span class="line">			`cout&lt;&lt;L.elem[i].no&lt;&lt;setw(30)&lt;&lt;L.elem[i].name&lt;&lt;setw(30)&lt;&lt;L.elem[i].price&lt;&lt;endl;`</span><br><span class="line">		`&#125;`</span><br><span class="line">	`&#125;`</span><br><span class="line">	`if(joke==0) cout&lt;&lt;&quot;404 NOT FOUND&quot;&lt;&lt;endl;`</span><br><span class="line">	 ``</span><br><span class="line">`&#125;`</span><br></pre></td></tr></table></figure>



<h2><span id="5添加书籍信息">5.添加书籍信息</span></h2><p>这个功能很简单，先准备好待插入的顺序表位置newnumber，对于newnumber之后的元素，统一后移一个单位，<u>表长加一</u>。记得<u>检查表是否溢出（表长&#x3D;&#x3D;maxsize），和newnumber的合法范围</u>（还记得数组从0开始，而顺序表是从1开始吗？所以，newnumber最小可以是1；另外，插入顺序表允许末尾追加，所以newnumber最大可以是表长+1。实际范围是**<u>[1,表长+1]</u>**。)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">``int listinsert(SqList &amp;L,int newnumber)`</span><br><span class="line">`//添加新图书`</span><br><span class="line">`&#123;`</span><br><span class="line">	`if( (newnumber&gt;L.len+1) || (newnumber&lt;1) ) exit(0);`</span><br><span class="line">	`if(L.len==maxsize) exit(0);`</span><br><span class="line">	`for(int i=L.len-1;i&gt;=newnumber-1;i--)&#123;`</span><br><span class="line">		`L.elem[i+1]=L.elem[i]; //插入位置以后的元素后移一个单位`</span><br><span class="line">	`&#125;L.elem[newnumber-1]=L.elem[maxsize-1];`</span><br><span class="line">	`L.len++;`</span><br><span class="line">	`return 1;`</span><br><span class="line"> &#125;` </span><br><span class="line"></span><br><span class="line">这里，</span><br></pre></td></tr></table></figure>

<p>我把要添加进去的数组信息放在了顺序表的最后一个位置maxsize，等插入位置以后的元素完成后移后，再将这组信息填进待插入的位置。</p>
<p>为了能直观地查看添加后的效果，设置一个输出函数，后续可以重复利用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">``void readlist(SqList L)&#123;`</span><br><span class="line">	`cout&lt;&lt;&quot;图书编号&quot;&lt;&lt;setw(20)&lt;&lt;&quot;书名&quot;&lt;&lt;setw(30)&lt;&lt;&quot;价格&quot;&lt;&lt;endl;`</span><br><span class="line">	`for(int i=0;i&lt;L.len;i++)&#123;`</span><br><span class="line">		`cout&lt;&lt;fixed&lt;&lt;setprecision(2);`</span><br><span class="line">		`cout&lt;&lt;L.elem[i].no&lt;&lt;setw(30)&lt;&lt;L.elem[i].name&lt;&lt;setw(30)&lt;&lt;L.elem[i].price&lt;&lt;endl;`</span><br><span class="line"> `&#125;`</span><br><span class="line">&#125;`</span><br></pre></td></tr></table></figure>



<h2><span id="6删除书籍">6.删除书籍</span></h2><p>这个功能需要借助查找功能。首先，我们查找一本书，定位到它在顺序表中的位置后（自然，我们知道了<u>这个位置的合法范围是**[1,表长]**</u>），使<u>该位置之后的元素统一往前移动一个单位，该书自然就被覆盖掉了。记得<u>表长减一</u>。</u></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`void listdelete(SqList &amp;L)`</span><br><span class="line">`//删除一本书`</span><br><span class="line">`&#123;`</span><br><span class="line">   `int deletedata;`</span><br><span class="line">	`char findnoname[50];`</span><br><span class="line">`cin&gt;&gt;findnoname;`</span><br><span class="line">`int joke=0;`</span><br><span class="line">`char* a;`</span><br><span class="line">`cout&lt;&lt;&quot;图书编号&quot;&lt;&lt;setw(20)&lt;&lt;&quot;书名&quot;&lt;&lt;setw(30)&lt;&lt;&quot;价格&quot;&lt;&lt;endl;`</span><br><span class="line">`for(int i=0;i&lt;L.len;i++)&#123;`</span><br><span class="line">	`a=strstr(L.elem[i].name,findnoname);`</span><br><span class="line">	`if(strcmp(findnoname,L.elem[i].no)==0)&#123;`</span><br><span class="line">		`joke++;`</span><br><span class="line">		`cout&lt;&lt;L.elem[i].no&lt;&lt;setw(30)&lt;&lt;L.elem[i].name&lt;&lt;setw(30)&lt;&lt;L.elem[i].price&lt;&lt;endl;`</span><br><span class="line">		`deletedata=i+1;`</span><br><span class="line">	`&#125;`</span><br><span class="line">	`if(a!=NULL)&#123;`</span><br><span class="line">		`joke++;`</span><br><span class="line">		`cout&lt;&lt;L.elem[i].no&lt;&lt;setw(30)&lt;&lt;L.elem[i].name&lt;&lt;setw(30)&lt;&lt;L.elem[i].price&lt;&lt;endl;`</span><br><span class="line">		`deletedata=i+1;`</span><br><span class="line">	`&#125;`</span><br><span class="line">`&#125;`</span><br><span class="line">`if(joke==0) cout&lt;&lt;&quot;404 NOT FOUND&quot;&lt;&lt;endl;`</span><br><span class="line">	``if((deletedata&lt;1) || (deletedata&gt;L.len)) exit(0);`</span><br><span class="line">	`for(int i=deletedata;i&lt;L.len;i++)&#123;`</span><br><span class="line">		`L.elem[i-1]=L.elem[i]; //对i所在的位置删除数据后，进行前移，前一个元素等于后一个元素` </span><br><span class="line"> `&#125;L.len--;`</span><br><span class="line">&#125;`</span><br></pre></td></tr></table></figure>

<h2><span id="7修改书籍信息">7.修改书籍信息</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int doinglist(SqList &amp;L)</span><br><span class="line">//修改顺序表信息 </span><br><span class="line">&#123;</span><br><span class="line">	cout&lt;&lt;&quot;请输入书籍编号&quot;&lt;&lt;endl;</span><br><span class="line">char findno[20];</span><br><span class="line">cin&gt;&gt;findno;</span><br><span class="line">int joke=0;</span><br><span class="line">int doing;</span><br><span class="line">for(int i=0;i&lt;L.len;i++)&#123;</span><br><span class="line">	if(strcmp(findno,L.elem[i].no)==0)&#123;</span><br><span class="line">		joke++;</span><br><span class="line">		cout&lt;&lt;&quot;获取书籍信息成功！&quot;&lt;&lt;endl;</span><br><span class="line">		cout&lt;&lt;&quot;图书编号&quot;&lt;&lt;setw(20)&lt;&lt;&quot;书名&quot;&lt;&lt;setw(30)&lt;&lt;&quot;价格&quot;&lt;&lt;endl;</span><br><span class="line">		cout&lt;&lt;fixed&lt;&lt;setprecision(2);</span><br><span class="line">		cout&lt;&lt;L.elem[i].no&lt;&lt;setw(30)&lt;&lt;L.elem[i].name&lt;&lt;setw(30)&lt;&lt;L.elem[i].price&lt;&lt;endl;</span><br><span class="line">		while(1)&#123;</span><br><span class="line">			cout&lt;&lt;&quot;请输入（0-3）：1.修改书籍编号 2.修改书名 3.修改书的价格 0.退出修改&quot;&lt;&lt;endl;</span><br><span class="line">			cin&gt;&gt;doing;</span><br><span class="line">			switch(doing)&#123;</span><br><span class="line">				case 1:&#123;</span><br><span class="line">					cout&lt;&lt;&quot;请输入新书籍编号：&quot;&lt;&lt;endl;</span><br><span class="line">					char newno[20];</span><br><span class="line">					cin&gt;&gt;newno;</span><br><span class="line">					strcpy(L.elem[i].no,newno); </span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">				case 2:&#123;</span><br><span class="line">					cout&lt;&lt;&quot;请输入新书名：&quot;&lt;&lt;endl;</span><br><span class="line">					char newname[50];</span><br><span class="line">					cin&gt;&gt;newname;</span><br><span class="line">					strcpy(L.elem[i].name,newname); </span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">				case 3:&#123;</span><br><span class="line">					cout&lt;&lt;&quot;请输入新价格：&quot;&lt;&lt;endl;</span><br><span class="line">					float newprice;</span><br><span class="line">					cin&gt;&gt;newprice;</span><br><span class="line">					L.elem[i].price=newprice;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">				case 0:&#123;</span><br><span class="line">				system(&quot;pause&quot;);</span><br><span class="line">			    system(&quot;cls&quot;);//实现清屏</span><br><span class="line">			    return 0;</span><br><span class="line">				&#125;break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="8排序">8.排序</span></h2><p>依照价格高低，对书籍进行排序。采用选择排序法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void talllist(SqList &amp;L)</span><br><span class="line"> //选择排序法 </span><br><span class="line"> &#123;</span><br><span class="line"> 	int max;  </span><br><span class="line">    for(int i=0;i&lt;L.len-1;i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        max=i;  </span><br><span class="line">        for(int j=i;j&lt;L.len;j++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            if(L.elem[max].price &gt; L.elem[j].price)  //本质是索引为i和i+1 的结构体成员在做比较，这种写法可以保证不漏掉每一组比较 </span><br><span class="line">                max=j;  </span><br><span class="line">        &#125;  </span><br><span class="line">        L.elem[L.len+1] = L.elem[i];  //用一个在顺序表外面的位置储存旧值，暂时没想到其他好的办法 </span><br><span class="line">        L.elem[i] = L.elem[max];  </span><br><span class="line">        L.elem[max] = L.elem[L.len+1] ;</span><br><span class="line">	 &#125;</span><br></pre></td></tr></table></figure>

<p>9.这个很简单，统计数目只需要输出表长就可以了</p>
<p>我用文件读取的时候多读了一行0，所以实操的时候用了表长-1</p>
<h1><span id="代码">【代码】</span></h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;new&gt;</span><br><span class="line">#include&lt;fstream&gt; //对文件输入输出 </span><br><span class="line">#include&lt;iostream&gt;  //对屏幕上输入输出</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define maxsize 1000</span><br><span class="line">typedef struct&#123;</span><br><span class="line">	char no[20];  //图书编号 </span><br><span class="line">	char name[50];  //书名 </span><br><span class="line">	float price;  //定价 </span><br><span class="line">&#125;book;</span><br><span class="line">typedef struct&#123;</span><br><span class="line">	book *elem;   //存储空间的基地址</span><br><span class="line">	int len;     //表长</span><br><span class="line">&#125;SqList;  //图书表的顺序存储结构为SqList </span><br><span class="line"></span><br><span class="line">int initlist(SqList &amp;L)</span><br><span class="line">//构造空表 </span><br><span class="line">&#123;</span><br><span class="line">	L.elem = new book[maxsize];</span><br><span class="line">	if(!L.elem)  exit(0);  //存储分配失败，不知为何，在这个地方用return -1会导致后续程序出错</span><br><span class="line">	L.len=0;</span><br><span class="line">	return 1; </span><br><span class="line">&#125; </span><br><span class="line">void menu()&#123;</span><br><span class="line">//菜单 </span><br><span class="line">	cout&lt;&lt;&quot;————&quot;&lt;&lt;&#x27;\n&#x27;&lt;&lt;&quot;menu&quot;&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;&quot;1.查找某本书&quot;&lt;&lt;&#x27;\n&#x27;&lt;&lt;&quot;2.添加新书&quot;&lt;&lt;&#x27;\n&#x27;&lt;&lt;&quot;3.删除某本书&quot;&lt;&lt;&#x27;\n&#x27;&lt;&lt;&quot;4.修改某本书的信息&quot;&lt;&lt;&#x27;\n&#x27;&lt;&lt; &quot;5.排序&quot;&lt;&lt;&#x27;\n&#x27;&lt;&lt;&quot;6.统计&quot;&lt;&lt;&#x27;\n&#x27;; </span><br><span class="line">	cout&lt;&lt;&quot;————&quot;&lt;&lt;endl; </span><br><span class="line">&#125;</span><br><span class="line">void Findno(SqList L)</span><br><span class="line">//查找书号 </span><br><span class="line">&#123;</span><br><span class="line">	char findno[20];</span><br><span class="line">	cin&gt;&gt;findno;</span><br><span class="line">	int joke=0;</span><br><span class="line">	cout&lt;&lt;&quot;图书编号&quot;&lt;&lt;setw(20)&lt;&lt;&quot;书名&quot;&lt;&lt;setw(30)&lt;&lt;&quot;价格&quot;&lt;&lt;endl;</span><br><span class="line">	for(int i=0;i&lt;L.len;i++)&#123;</span><br><span class="line">		if(strcmp(findno,L.elem[i].no)==0)&#123;</span><br><span class="line">			joke++;</span><br><span class="line">			cout&lt;&lt;L.elem[i].no&lt;&lt;setw(30)&lt;&lt;L.elem[i].name&lt;&lt;setw(30)&lt;&lt;L.elem[i].price&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if(joke==0) cout&lt;&lt;&quot;404 NOT FOUND&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">void Findname(SqList L)</span><br><span class="line">//查找书名</span><br><span class="line">&#123;</span><br><span class="line">	char findname[50];</span><br><span class="line">	cin&gt;&gt;findname;</span><br><span class="line">	int joke=0;</span><br><span class="line">	cout&lt;&lt;&quot;图书编号&quot;&lt;&lt;setw(20)&lt;&lt;&quot;书名&quot;&lt;&lt;setw(30)&lt;&lt;&quot;价格&quot;&lt;&lt;endl;</span><br><span class="line">	for(int i=0;i&lt;L.len;i++)&#123;</span><br><span class="line">	char *b=strstr(L.elem[i].name,findname);</span><br><span class="line">		if(b!=NULL)&#123;</span><br><span class="line">			joke++;</span><br><span class="line">			cout&lt;&lt;L.elem[i].no&lt;&lt;setw(30)&lt;&lt;L.elem[i].name&lt;&lt;setw(30)&lt;&lt;L.elem[i].price&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if(joke==0) cout&lt;&lt;&quot;404 NOT FOUND&quot;&lt;&lt;endl;</span><br><span class="line">	 </span><br><span class="line">&#125;</span><br><span class="line">void Findprice(SqList L)</span><br><span class="line">//查找价格 </span><br><span class="line">&#123;</span><br><span class="line">	float findprice;</span><br><span class="line">	cin&gt;&gt;findprice;</span><br><span class="line">	int joke=0;</span><br><span class="line">	cout&lt;&lt;&quot;图书编号&quot;&lt;&lt;setw(20)&lt;&lt;&quot;书名&quot;&lt;&lt;setw(30)&lt;&lt;&quot;价格&quot;&lt;&lt;endl;</span><br><span class="line">	for(int i=0;i&lt;L.len;i++)&#123;</span><br><span class="line">		if(findprice==L.elem[i].price)&#123;</span><br><span class="line">			joke++;</span><br><span class="line">			cout&lt;&lt;fixed&lt;&lt;setprecision(2);</span><br><span class="line">			cout&lt;&lt;L.elem[i].no&lt;&lt;setw(30)&lt;&lt;L.elem[i].name&lt;&lt;setw(30)&lt;&lt;L.elem[i].price&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if(joke==0) cout&lt;&lt;&quot;404 NOT FOUND&quot;&lt;&lt;endl;</span><br><span class="line">	 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int listinsert(SqList &amp;L,int newnumber)</span><br><span class="line">//添加新图书</span><br><span class="line">&#123;</span><br><span class="line">	if( (newnumber&gt;L.len+1) || (newnumber&lt;1) ) exit(0);</span><br><span class="line">	if(L.len==maxsize) exit(0);</span><br><span class="line">	for(int i=L.len-1;i&gt;=newnumber-1;i--)&#123;</span><br><span class="line">		L.elem[i+1]=L.elem[i]; //插入位置以后的元素后移一个单位</span><br><span class="line">	&#125;L.elem[newnumber-1]=L.elem[maxsize-1];</span><br><span class="line">	L.len++;</span><br><span class="line">	return 1;</span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> void listdelete(SqList &amp;L)</span><br><span class="line"> //删除一本书</span><br><span class="line"> &#123;</span><br><span class="line">    int deletedata;</span><br><span class="line"> 	char findnoname[50];</span><br><span class="line">	cin&gt;&gt;findnoname;</span><br><span class="line">	int joke=0;</span><br><span class="line">	char* a;</span><br><span class="line">	cout&lt;&lt;&quot;图书编号&quot;&lt;&lt;setw(20)&lt;&lt;&quot;书名&quot;&lt;&lt;setw(30)&lt;&lt;&quot;价格&quot;&lt;&lt;endl;</span><br><span class="line">	for(int i=0;i&lt;L.len;i++)&#123;</span><br><span class="line">		a=strstr(L.elem[i].name,findnoname);</span><br><span class="line">		if(strcmp(findnoname,L.elem[i].no)==0)&#123;</span><br><span class="line">			joke++;</span><br><span class="line">			cout&lt;&lt;L.elem[i].no&lt;&lt;setw(30)&lt;&lt;L.elem[i].name&lt;&lt;setw(30)&lt;&lt;L.elem[i].price&lt;&lt;endl;</span><br><span class="line">			deletedata=i+1;</span><br><span class="line">		&#125;</span><br><span class="line">		if(a!=NULL)&#123;</span><br><span class="line">			joke++;</span><br><span class="line">			cout&lt;&lt;L.elem[i].no&lt;&lt;setw(30)&lt;&lt;L.elem[i].name&lt;&lt;setw(30)&lt;&lt;L.elem[i].price&lt;&lt;endl;</span><br><span class="line">			deletedata=i+1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if(joke==0) cout&lt;&lt;&quot;404 NOT FOUND&quot;&lt;&lt;endl;</span><br><span class="line"> 	</span><br><span class="line"></span><br><span class="line"> 	if((deletedata&lt;1) || (deletedata&gt;L.len)) exit(0);</span><br><span class="line"> 	for(int i=deletedata;i&lt;L.len;i++)&#123;</span><br><span class="line"> 		L.elem[i-1]=L.elem[i]; //对i所在的位置删除数据后，进行前移，前一个元素等于后一个元素 </span><br><span class="line"> 	 &#125;L.len--;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> int doinglist(SqList &amp;L)</span><br><span class="line"> //修改顺序表信息 </span><br><span class="line"> &#123;</span><br><span class="line"> 	cout&lt;&lt;&quot;请输入书籍编号&quot;&lt;&lt;endl;</span><br><span class="line">	char findno[20];</span><br><span class="line">	cin&gt;&gt;findno;</span><br><span class="line">	int joke=0;</span><br><span class="line">	int doing;</span><br><span class="line">	for(int i=0;i&lt;L.len;i++)&#123;</span><br><span class="line">		if(strcmp(findno,L.elem[i].no)==0)&#123;</span><br><span class="line">			joke++;</span><br><span class="line">			cout&lt;&lt;&quot;获取书籍信息成功！&quot;&lt;&lt;endl;</span><br><span class="line">			cout&lt;&lt;&quot;图书编号&quot;&lt;&lt;setw(20)&lt;&lt;&quot;书名&quot;&lt;&lt;setw(30)&lt;&lt;&quot;价格&quot;&lt;&lt;endl;</span><br><span class="line">			cout&lt;&lt;fixed&lt;&lt;setprecision(2);</span><br><span class="line">			cout&lt;&lt;L.elem[i].no&lt;&lt;setw(30)&lt;&lt;L.elem[i].name&lt;&lt;setw(30)&lt;&lt;L.elem[i].price&lt;&lt;endl;</span><br><span class="line">			while(1)&#123;</span><br><span class="line">				cout&lt;&lt;&quot;请输入（0-3）：1.修改书籍编号 2.修改书名 3.修改书的价格 0.退出修改&quot;&lt;&lt;endl;</span><br><span class="line">				cin&gt;&gt;doing;</span><br><span class="line">				switch(doing)&#123;</span><br><span class="line">					case 1:&#123;</span><br><span class="line">						cout&lt;&lt;&quot;请输入新书籍编号：&quot;&lt;&lt;endl;</span><br><span class="line">						char newno[20];</span><br><span class="line">						cin&gt;&gt;newno;</span><br><span class="line">						strcpy(L.elem[i].no,newno); </span><br><span class="line">						break;</span><br><span class="line">					&#125;</span><br><span class="line">					case 2:&#123;</span><br><span class="line">						cout&lt;&lt;&quot;请输入新书名：&quot;&lt;&lt;endl;</span><br><span class="line">						char newname[50];</span><br><span class="line">						cin&gt;&gt;newname;</span><br><span class="line">						strcpy(L.elem[i].name,newname); </span><br><span class="line">						break;</span><br><span class="line">					&#125;</span><br><span class="line">					case 3:&#123;</span><br><span class="line">						cout&lt;&lt;&quot;请输入新价格：&quot;&lt;&lt;endl;</span><br><span class="line">						float newprice;</span><br><span class="line">						cin&gt;&gt;newprice;</span><br><span class="line">						L.elem[i].price=newprice;</span><br><span class="line">						break;</span><br><span class="line">					&#125;</span><br><span class="line">					case 0:&#123;</span><br><span class="line">					system(&quot;pause&quot;);</span><br><span class="line">				    system(&quot;cls&quot;);</span><br><span class="line">				    return 0;</span><br><span class="line">					&#125;break;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> &#125;</span><br><span class="line"> void talllist(SqList &amp;L)</span><br><span class="line"> //选择排序法 </span><br><span class="line"> &#123;</span><br><span class="line"> 	int max;  </span><br><span class="line">    for(int i=0;i&lt;L.len-1;i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        max=i;  </span><br><span class="line">        for(int j=i;j&lt;L.len;j++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            if(L.elem[max].price &gt; L.elem[j].price)  //本质是索引为i和i+1 的结构体成员在做比较，这种写法可以保证不漏掉每一组比较 </span><br><span class="line">                max=j;  </span><br><span class="line">        &#125;  </span><br><span class="line">        L.elem[L.len+1] = L.elem[i];  //用一个在顺序表外面的位置储存旧值，暂时没想到其他好的办法 </span><br><span class="line">        L.elem[i] = L.elem[max];  </span><br><span class="line">        L.elem[max] = L.elem[L.len+1] ;</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br><span class="line"> void readlist(SqList L)&#123;</span><br><span class="line"> 	cout&lt;&lt;&quot;图书编号&quot;&lt;&lt;setw(20)&lt;&lt;&quot;书名&quot;&lt;&lt;setw(30)&lt;&lt;&quot;价格&quot;&lt;&lt;endl;</span><br><span class="line"> 	for(int i=0;i&lt;L.len;i++)&#123;</span><br><span class="line"> 		cout&lt;&lt;fixed&lt;&lt;setprecision(2);</span><br><span class="line"> 		cout&lt;&lt;L.elem[i].no&lt;&lt;setw(30)&lt;&lt;L.elem[i].name&lt;&lt;setw(30)&lt;&lt;L.elem[i].price&lt;&lt;endl;</span><br><span class="line">	 &#125;</span><br><span class="line"> &#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	SqList L;</span><br><span class="line">	initlist(L); //顺序表的初始化 </span><br><span class="line">	FILE *fp=NULL;</span><br><span class="line">	FILE *fp1=NULL;</span><br><span class="line">	fp=fopen(&quot;information.txt&quot;,&quot;r&quot;);//r打开只读文件 </span><br><span class="line">	if(fp==NULL)&#123;</span><br><span class="line">	cout&lt;&lt;&quot;文件读取无效&quot;&lt;&lt;endl;</span><br><span class="line">	exit(0); </span><br><span class="line">	&#125;</span><br><span class="line">	int i=0;</span><br><span class="line">	while(!feof(fp))&#123;</span><br><span class="line">        fscanf(fp, &quot;%s %s %f\n&quot;, L.elem[i].no,L.elem[i].name,&amp;L.elem[i].price);//字符变量不需要加&amp;指向地址，%s忽略字符串前一个空格 </span><br><span class="line">		i++;</span><br><span class="line">	&#125; </span><br><span class="line">	L.len=i+1; </span><br><span class="line">	fclose(fp);//关闭文件 </span><br></pre></td></tr></table></figure>

<p>​	</p>
<pre><code>while(1)&#123;
    menu(); 
    int choose;
    int find;
    string yes;
    cin&gt;&gt;choose; 
    switch(choose)&#123;
        case 1:&#123;
            cout&lt;&lt;&quot;请选择（0-3）：1.按图书编号查找 2.按书名查找 3.按价格查找 0.退出&quot;&lt;&lt;endl;
            cin&gt;&gt;find;
            if(find==1) Findno(L);
            if(find==2) Findname(L);
            if(find==3) Findprice(L);
            break;
        &#125;
        case 2:&#123;
            int newnumber;
            cout&lt;&lt;&quot;请输入：添加新图书至第__位(按0退出)&quot;&lt;&lt;endl;
            cin&gt;&gt;newnumber;
            if(newnumber!=0)&#123;
                cin&gt;&gt;L.elem[maxsize-1].no&gt;&gt;L.elem[maxsize-1].name&gt;&gt;L.elem[maxsize-1].price;
                listinsert(L,newnumber);
                cout&lt;&lt;&quot;添加成功！是否查看？Y/N&quot;&lt;&lt;endl;
                cin&gt;&gt;yes;
                if(yes==&quot;Y&quot;) readlist(L);
                if(yes==&quot;N&quot;) break;
            &#125;
            break;
        &#125;
        case 3:&#123;
            cout&lt;&lt;&quot;请选择（0-2）：1.输入图书编号并删除该书 2.输入书名并删除该书 0.退出&quot;&lt;&lt;endl;
            cin&gt;&gt;find;
            if(find==1) &#123;
            cout&lt;&lt;&quot;正在查询你想删除的书...&quot;&lt;&lt;endl; 
            listdelete(L); 
            cout&lt;&lt;&quot;删除完成！请查看：&quot;&lt;&lt;endl; 
            readlist(L);
            &#125;
            if(find==2)&#123;
            cout&lt;&lt;&quot;查找到你想删除的书是：&quot;&lt;&lt;endl; 	
            listdelete(L);
            cout&lt;&lt;&quot;删除完成！请查看：&quot;&lt;&lt;endl; 
            readlist(L);
         	&#125;
            break;
        &#125;
        case 4:&#123;
            cout&lt;&lt;&quot;请选择（0-1）：1.输入图书编号并修改该书信息  0.退出&quot;&lt;&lt;endl;
            cin&gt;&gt;find;
            if(find==1) doinglist(L);
            break;
        &#125;
        case 5:&#123;
            cout&lt;&lt;&quot;请选择（0-1）：1.按价格升序排序  0.退出&quot;&lt;&lt;endl;
            cin&gt;&gt;find;
            if(find==1)&#123;
                talllist(L);
                readlist(L);
            &#125;
            break;
        &#125;
        case 6:&#123;
            cout&lt;&lt;&quot;本系统目前共收录&quot;&lt;&lt;L.len-1&lt;&lt;&quot;本书&quot;&lt;&lt;endl; 
            float sum=0;
            for(int i=0;i&lt;L.len;i++)&#123;
                sum+=L.elem[i].price;
            &#125;
            cout&lt;&lt;fixed&lt;&lt;setprecision(2);
            cout&lt;&lt;&quot;价值约&quot;&lt;&lt; sum&lt;&lt;&quot;元&quot;&lt;&lt;endl; 
            break;
        &#125;
    &#125;
fp1=fopen(&quot;information2.txt&quot;,&quot;w+&quot;);//w+打开可读写文件，若不存在则建立，若存在则清空并覆盖 
if(fp==NULL)&#123;
cout&lt;&lt;&quot;文件写入无效&quot;&lt;&lt;endl;
exit(0); 
&#125;
for(i=0;i&lt;L.len;i++)&#123;
    fprintf(fp1,&quot;%s %s %.2f\n&quot;,L.elem[i].no,L.elem[i].name,L.elem[i].price);
&#125;
fclose(fp1);//关闭文件 

system(&quot;pause&quot;);
system(&quot;cls&quot;);

&#125;
return 0;
&#125;
</code></pre>
]]></content>
      <tags>
        <tag>数据结构笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>数字逻辑电路基础</title>
    <url>/2024/06/01/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#%E4%B8%80-%E6%95%B0%E5%88%B6-%E7%BC%96%E7%A0%81%E4%B8%8E%E9%80%BB%E8%BE%91%E4%BB%A3%E6%95%B0">一、数制、编码与逻辑代数</a><ul>
<li><a href="#1%E6%95%B0%E5%88%B6%E7%9A%84%E8%BD%AC%E5%8C%96">1.数制的转化</a></li>
<li><a href="#2%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E7%9A%84%E7%BC%96%E7%A0%81">2.二进制数的编码</a></li>
<li><a href="#3%E9%80%BB%E8%BE%91%E4%BB%A3%E6%95%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%80%BB%E8%BE%91">3.逻辑代数的基本逻辑</a></li>
<li><a href="#4%E9%80%BB%E8%BE%91%E5%87%BD%E6%95%B0">4.逻辑函数</a></li>
<li><a href="#5%E5%8D%A1%E8%AF%BA%E5%9B%BE">&#x3D;&#x3D;5.卡诺图&#x3D;&#x3D;</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C-%E9%9B%86%E6%88%90%E9%80%BB%E8%BE%91%E9%97%A8%E7%94%B5%E8%B7%AF">二、集成逻辑门电路</a><ul>
<li><a href="#1%E6%99%B6%E4%BD%93%E4%BA%8C%E6%9E%81%E7%AE%A1%E7%9A%84%E5%BC%80%E5%85%B3%E7%89%B9%E6%80%A7">1.晶体二极管的开关特性</a></li>
<li><a href="#2%E6%99%B6%E4%BD%93%E7%AE%A1%E7%9A%84%E5%BC%80%E5%85%B3%E7%89%B9%E6%80%A7">2.晶体管的开关特性</a></li>
<li><a href="#3%E7%94%B1%E4%BA%8C%E6%9E%81%E7%AE%A1%E5%92%8C%E6%99%B6%E4%BD%93%E7%AE%A1%E7%BB%84%E6%88%90%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%80%BB%E8%BE%91%E9%97%A8%E7%94%B5%E8%B7%AF">3.由二极管和晶体管组成的基本逻辑门电路</a></li>
<li><a href="#1%E4%B8%8E%E9%97%A8">（1）与门</a></li>
<li><a href="#2%E9%9D%9E%E9%97%A8">（2）非门</a></li>
<li><a href="#3ttl%E4%B8%8E%E9%9D%9E%E9%97%A8%E7%94%B5%E8%B7%AF">(3)TTL“与非”门电路</a></li>
<li><a href="#4%E9%9B%86%E7%94%B5%E6%9E%81%E5%BC%80%E8%B7%AFttl%E7%94%B5%E8%B7%AFoc%E9%97%A8">(4)集电极开路TTL电路（OC门）</a></li>
<li><a href="#5%E4%B8%89%E6%80%81ttl%E9%97%A8tsl%E9%97%A8">(5)三态TTL门（TSL门）</a></li>
<li><a href="#4%E6%AD%A3%E9%80%BB%E8%BE%91%E5%92%8C%E8%B4%9F%E9%80%BB%E8%BE%91">4.&#x3D;&#x3D;正逻辑和负逻辑&#x3D;&#x3D;</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<p>[TOC]</p>
<h2><span id="一-数制-编码与逻辑代数">一、数制、编码与逻辑代数</span></h2><h3><span id="1数制的转化">1.数制的转化</span></h3><p>B二进制，O八进制，D十进制，H十六进制</p>
<h3><span id="2二进制数的编码">2.二进制数的编码</span></h3><h4><span id="代码"><strong>代码</strong></span></h4><p>数值和文字符号可以用多位二进制表示，前一类表示数值的大小，后一类表示不同的符号，这种多位二进制叫做代码。</p>
<h4><span id="编码">编码</span></h4><p>按照一定的规则组合的代码，并赋予一定的含义。</p>
<h4><span id="bcd码">BCD码</span></h4><p>把十进制的每一位用多位二进制来表示，将此称为二进制编码的十进制数码，简称BCD码。</p>
<h4><span id="18421码">（1）8421码</span></h4><ul>
<li>有权：(N)ᴰ &#x3D; 8a₃ +4a₂ +2a₁ + 1a₀</li>
<li>有奇偶性：奇数的最低位为1.偶数的最低位为0</li>
<li>例子：(92.35)ᴰ &#x3D; (1001 0010 . 0011 0101)8421</li>
</ul>
<h4><span id="22421码">（2）2421码</span></h4><ul>
<li>各位的权值是2、4、2、1</li>
<li>例子：(652.37)ᴰ &#x3D; (1100 1011 0010 . 0011 1101)2421</li>
</ul>
<h4><span id="3余3码">（3）余3码</span></h4><ul>
<li>是由8421码加3（0011）得来的</li>
<li>无权</li>
</ul>
<h4><span id="4字符编码">（4）字符编码</span></h4><p>字符编码就是对可显示、不可显示的字符或控制字符的编码，以便信息的交换、处理、存储和数据传输的格式控制。</p>
<h3><span id="3逻辑代数的基本逻辑">3.逻辑代数的基本逻辑</span></h3><h4><span id="1与">（1）与</span></h4><ul>
<li>符号</li>
</ul>
<p><img src="/2024/06/01/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/20190524142450218.png" alt="20190524142450218"></p>
<ul>
<li>表达式</li>
</ul>
<p><img src="/2024/06/01/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/20190524142516260.png" alt="20190524142516260"></p>
<h4><span id="2或">（2）或<img src="/2024/06/01/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/20190524142634125.png" alt="20190524142634125"></span></h4><p><img src="/2024/06/01/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/20190524142538549.png" alt="20190524142538549"></p>
<ul>
<li>表达式：F&#x3D;A+B</li>
</ul>
<h4><span id="3非">（3）非</span></h4><img src="/2024/06/01/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/20190524142615458.png" alt="20190524142615458" style="zoom: 80%;">

<img src="/2024/06/01/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/20190524142634125-1717175618792-6.png" alt="20190524142634125" style="zoom:50%;">

<h4><span id="4异或正负逻辑">（4）异或（正负逻辑）</span></h4><p><img src="/2024/06/01/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/20190524142702131.png" alt="20190524142702131"></p>
<h4><span id="5同或正负逻辑">（5）同或（正负逻辑）</span></h4><p><img src="/2024/06/01/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/20190524142715410.png" alt="20190524142715410"></p>
<h3><span id="4逻辑函数">4.逻辑函数</span></h3><p>函数表达式一般化简成 <strong>与-或式</strong> ，其最简应满足的两个条件：<br>1）表达式中“与”项的个数最少；<br>2）在满足1）的前提下，每个“与”项中的变量个数最少。</p>
<h4><span id="1与或表达式积之和-或与表达式和之积">（1）与或表达式（积之和）、或与表达式（和之积）</span></h4><p><img src="/2024/06/01/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240601012350.png" alt="微信截图_20240601012350"></p>
<h4><span id="x3dx3d2常用公式x3dx3d">&#x3D;&#x3D;（2）常用公式&#x3D;&#x3D;</span></h4><p><img src="/2024/06/01/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240601012515.png" alt="微信截图_20240601012515"></p>
<h4><span id="3逻辑代数中的一些特殊规律">（3）逻辑代数中的一些特殊规律</span></h4><p><img src="/2024/06/01/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240601012954.png" alt="微信截图_20240601012954"></p>
<h3><span id="x3dx3d5卡诺图x3dx3d">&#x3D;&#x3D;5.卡诺图&#x3D;&#x3D;</span></h3><ul>
<li>圈的个数必须是2的幂次</li>
<li>“1”相邻对称</li>
<li>至少有一个“1”是新的</li>
<li>每个“1”至少圈一次</li>
</ul>
<p><img src="/2024/06/01/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/20200329101822678.png" alt="20200329101822678"></p>
<h2><span id="二-集成逻辑门电路">二、集成逻辑门电路</span></h2><p>一个理想的开关元件应该具备：</p>
<ul>
<li><strong>在接通状态时，其接通电阻为0；</strong></li>
<li><strong>在断开状态下，阻抗为无穷大，流过开关的电流为0；</strong></li>
<li><strong>断开和接通之间的转换能在瞬间完成，即开关时间为0。</strong></li>
</ul>
<h3><span id="1晶体二极管的开关特性">1.晶体二极管的开关特性</span></h3><p>晶体二极管由PN结构成，具备<strong>单向导电特性</strong>。</p>
<h3><span id="2晶体管的开关特性">2.晶体管的开关特性</span></h3><p><img src="/2024/06/01/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240601014239.png" alt="微信图片_20240601014239"></p>
<p><img src="/2024/06/01/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240604114230.png" alt="微信截图_20240604114230"></p>
<h3><span id="3由二极管和晶体管组成的基本逻辑门电路">3.由二极管和晶体管组成的基本逻辑门电路</span></h3><h3><span id="1与门">（1）与门</span></h3><p><img src="/2024/06/01/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240604114959.png" alt="微信截图_20240604114959"></p>
<p>对于ABC中的每个输入端而言，都只能有两种状态：<strong>高电位或低电位</strong>。</p>
<p>约定：5V左右为高电平，用1表示，0V左右为低电平，用0表示。</p>
<h3><span id="2非门">（2）非门</span></h3><p><img src="/2024/06/01/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240604115219.png" alt="微信截图_20240604115219"></p>
<h3><span id="3ttl与非门电路">(3)TTL“与非”门电路</span></h3><p><img src="/2024/06/01/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/R-C-1717473463127-4.png" alt="R-C"></p>
<p><img src="/2024/06/01/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/201801171516196998292490.png" alt="201801171516196998292490"></p>
<p><img src="/2024/06/01/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240604120300.jpg" alt="微信图片_20240604120300"></p>
<p><img src="/2024/06/01/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240604120416.jpg" alt="微信图片_20240604120416"></p>
<h3><span id="4集电极开路ttl电路oc门">(4)集电极开路TTL电路（OC门）</span></h3><p><img src="/2024/06/01/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/6380731668632576204449708.png_280.jpg" alt="6380731668632576204449708.png_280"></p>
<p><img src="/2024/06/01/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240604121025.png" alt="微信截图_20240604121025"></p>
<h3><span id="5三态ttl门tsl门">(5)三态TTL门（TSL门）</span></h3><p><strong>当E&#x3D;1时，构成三态“与非”门状态</strong></p>
<p>当E&#x3D;0时，构成禁止态</p>
<p><img src="/2024/06/01/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240604121534.png" alt="微信截图_20240604121534"></p>
<h3><span id="4x3dx3d正逻辑和负逻辑x3dx3d">4.&#x3D;&#x3D;正逻辑和负逻辑&#x3D;&#x3D;</span></h3><p><strong>正逻辑：用高电平H表示逻辑1，用低电平L表示逻辑0</strong></p>
<p>P &#x3D; ABC</p>
<p><strong>负逻辑：用高电平H表示逻辑0，用低电平L表示逻辑1</strong></p>
<p>P&#x3D;A+B+C</p>
<p><strong>正负逻辑之间存在简单的对偶关系。</strong></p>
<p><img src="/2024/06/01/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/01d5ab979a554ea8a58784a647507fd0.png" alt="01d5ab979a554ea8a58784a647507fd0"></p>
]]></content>
      <tags>
        <tag>电子电路基础</tag>
      </tags>
  </entry>
  <entry>
    <title>正弦稳态电路分析</title>
    <url>/2024/04/01/%E6%AD%A3%E5%BC%A6%E7%A8%B3%E6%80%81%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#%E6%AD%A3%E5%BC%A6%E4%BF%A1%E5%8F%B7">正弦信号</a><ul>
<li><a href="#1%E6%AD%A3%E5%BC%A6%E4%BF%A1%E5%8F%B7%E7%9A%84%E4%B8%89%E8%A6%81%E7%B4%A0">1.正弦信号的三要素</a></li>
<li><a href="#2%E6%AD%A3%E5%BC%A6%E4%BF%A1%E5%8F%B7%E7%9A%84%E7%9B%B8%E4%BD%8D%E5%B7%AE">2.正弦信号的相位差</a></li>
<li><a href="#3%E6%AD%A3%E5%BC%A6%E4%BF%A1%E5%8F%B7%E7%9A%84%E6%9C%89%E6%95%88%E5%80%BC">3.正弦信号的有效值</a></li>
</ul>
</li>
<li><a href="#%E6%AD%A3%E5%BC%A6%E4%BF%A1%E5%8F%B7%E7%9A%84%E7%9B%B8%E9%87%8F%E8%A1%A8%E7%A4%BA">正弦信号的相量表示</a><ul>
<li><a href="#1%E5%A4%8D%E6%95%B0a%E7%9A%84%E8%A1%A8%E7%A4%BA">1.复数A的表示</a></li>
<li><a href="#2%E7%94%A8%E7%9B%B8%E9%87%8F%E8%A1%A8%E7%A4%BA%E6%AD%A3%E5%BC%A6%E4%BF%A1%E5%8F%B7">2.用相量表示正弦信号</a></li>
</ul>
</li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E5%85%83%E4%BB%B6%E4%BC%8F%E5%AE%89%E7%89%B9%E6%80%A7%E7%9A%84%E7%9B%B8%E9%87%8F%E5%BD%A2%E5%BC%8F">基本元件伏安特性的相量形式</a><ul>
<li><a href="#1%E7%94%B5%E9%98%BB%E5%85%83%E4%BB%B6">1.电阻元件</a></li>
<li><a href="#2%E7%94%B5%E6%84%9F%E5%85%83%E4%BB%B6">2.电感元件</a></li>
<li><a href="#3%E7%94%B5%E5%AE%B9%E5%85%83%E4%BB%B6">3.电容元件</a></li>
<li><a href="#4%E6%AD%A3%E5%BC%A6%E7%94%B5%E6%BA%90%E7%9A%84%E7%9B%B8%E9%87%8F%E6%A8%A1%E5%9E%8B">4.正弦电源的相量模型</a></li>
</ul>
</li>
<li><a href="#%E7%9B%B8%E9%87%8F%E6%A8%A1%E5%9E%8B">相量模型</a><ul>
<li><a href="#1%E9%98%BB%E6%8A%97%E5%92%8C%E5%AF%BC%E7%BA%B3">1.阻抗和导纳</a></li>
<li><a href="#2%E7%9B%B8%E9%87%8F%E5%9B%BE">2.相量图</a></li>
<li><a href="#3%E9%98%BB%E6%8A%97%E5%92%8C%E5%AF%BC%E7%BA%B3%E7%9A%84%E4%B8%B2-%E5%B9%B6%E8%81%94">3.阻抗和导纳的串、并联</a></li>
</ul>
</li>
<li><a href="#%E4%B8%B2%E8%81%94%E8%B0%90%E6%8C%AF">串联谐振</a><ul>
<li><a href="#1%E6%9D%A1%E4%BB%B6">1.条件</a></li>
<li><a href="#2%E7%89%B9%E5%BE%81">2.特征</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<p>[TOC]</p>
<h2><span id="正弦信号">正弦信号</span></h2><p>正弦稳态电路：在正弦电源作用下，电路达到稳定工作状态时的正弦稳态电路。</p>
<p>正弦交流信号可以用sin函数表示，也可以用cos函数表示，本书采用sin函数。</p>
<h3><span id="1正弦信号的三要素">1.正弦信号的三要素</span></h3><h4><span id="一个正弦信号由3个参数确定最大值-频率角频率和初相">一个正弦信号由3个参数确定：<strong>最大值、频率（角频率）和初相</strong></span></h4><p>（1）<strong>正弦交流信号的一般表达式</strong>：<strong>u(t) &#x3D; Uₘ sin(ωt + θ)</strong></p>
<p>（2）<strong>Uₘ</strong>：<strong>幅值</strong>，表示正弦量所能达到的最大值；又叫峰值或振幅</p>
<p>（3）**(ωt + θ)<strong>：</strong>相位**；θ称为相位角</p>
<p>（4）<strong>ω</strong>：<strong>角频率</strong>，是正弦量在单位时间内变化的弧度数，单位<strong>rad&#x2F;s</strong></p>
<p>（5）<strong>周期</strong>：周期T表示正弦量变化一周需要的时间，单位<strong>s</strong></p>
<p>（6）<strong>公式</strong>：①<strong>T&#x3D;2π&#x2F;ω</strong></p>
<p>​                      ②<strong>f&#x3D;1&#x2F;T</strong></p>
<h3><span id="2正弦信号的相位差">2.正弦信号的相位差</span></h3><p>（1）<strong>定义</strong>：两个同频率正弦信号在任一时刻的相位之差称为相位差，实际上是初相之差。</p>
<p>（2）<strong>符号表示</strong>：θ&#x3D;θᵢ - θᵤ</p>
<p>（3）θ&gt;0，表示i(t)超前于u(t)，电流比电压先到达最大值或最小值；</p>
<p>​          θ&lt;0，表示i(t)滞后于u(t)；</p>
<p>​          θ&#x3D;0，则称i(t)与u(t)同相，二者同时到达最值；</p>
<p>​          θ&#x3D;+-π，则称i(t)与u(t)反相，当i(t)达到最大值时，u(t)达到最小值，反之亦然。</p>
<h3><span id="3正弦信号的有效值">3.正弦信号的有效值</span></h3><p>（1）<strong>定义</strong>：设两个阻值相同的电阻，分别通过周期电流和直流电流，在一个周期内，两个电阻消耗相同的能量，就称该直流电流值为周期电流的有效值。</p>
<p>（2）<strong>总结</strong>：<u>正弦信号的振幅值等于有效值的√2倍。</u></p>
<p>​                     Uₘ &#x3D; √2 U       ，        Iₘ &#x3D; √2 I</p>
<p>（3）<strong>公式表示</strong>：i(t)&#x3D;√2 I sin(ωt + θᵢ)</p>
<p>​                             u(t)&#x3D;√2 U sin(ωt + θᵤ)</p>
<h2><span id="正弦信号的相量表示">正弦信号的相量表示</span></h2><h3><span id="1复数a的表示">1.复数A的表示</span></h3><h4><span id="1代数型-指数型和极型">（1）代数型、指数型和极型</span></h4><ul>
<li><input disabled type="checkbox"> <strong>代数型</strong>：A&#x3D;a1 + ja2</li>
<li><input disabled type="checkbox"> <strong>指数型</strong>：A&#x3D;aeʲᶿ</li>
<li><input disabled type="checkbox"> <strong>极型</strong>：a∠θ</li>
</ul>
<h4><span id="2指数型转换为代数型">（2）指数型转换为代数型</span></h4><ul>
<li><input disabled type="checkbox"> <strong>欧拉公式</strong>：eʲᶿ &#x3D; cosθ + jsinθ</li>
<li><input disabled type="checkbox"> 特别的，e^jπ&#x2F;2 &#x3D; cos(π&#x2F;2) + jsin(π&#x2F;2) &#x3D;j</li>
</ul>
<h4><span id="3代数型转换为指数型和极型">（3）代数型转换为指数型和极型</span></h4><ul>
<li><p><input disabled type="checkbox"> 
<strong>a &#x3D; (a₁² + a₂²)^1&#x2F;2</strong></p>
</li>
<li><p><input disabled type="checkbox"> 
<strong>θ &#x3D; arctan (a₂&#x2F;a₁)</strong></p>
</li>
<li><p><input disabled type="checkbox"> 
常用值：arctan1 &#x3D; π&#x2F;4</p>
<p>​                arctan√3 &#x3D; π&#x2F;3</p>
<p>​                arctan1&#x2F;√3 &#x3D; π&#x2F;6</p>
</li>
</ul>
<img src="/2024/04/01/%E6%AD%A3%E5%BC%A6%E7%A8%B3%E6%80%81%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/微信截图_20240402012354.png" alt="微信截图_20240402012354" style="zoom:80%;">

<h4><span id="4计算">（4）计算</span></h4><img src="/2024/04/01/%E6%AD%A3%E5%BC%A6%E7%A8%B3%E6%80%81%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/微信截图_20240402012812.png" alt="微信截图_20240402012812" style="zoom:80%;">

<h3><span id="2用相量表示正弦信号">2.用相量表示正弦信号</span></h3><h4><span id="1正弦电流-电压的表示">（1）正弦电流、电压的表示</span></h4><p><img src="/2024/04/01/%E6%AD%A3%E5%BC%A6%E7%A8%B3%E6%80%81%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240405124242.png" alt="微信截图_20240405124242"></p>
<p><img src="/2024/04/01/%E6%AD%A3%E5%BC%A6%E7%A8%B3%E6%80%81%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240405123709.png" alt="微信图片_20240405123709"></p>
<h4><span id="2正弦信号与相量的对应规则">（2）正弦信号与相量的对应规则</span></h4><p><img src="/2024/04/01/%E6%AD%A3%E5%BC%A6%E7%A8%B3%E6%80%81%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240405125143.png" alt="微信截图_20240405125143"></p>
<h4><span id="3电流相量适用基尔霍夫定律见例题p87-p91">（3）电流相量适用基尔霍夫定律（见例题P87、P91）</span></h4><p>由i(t)&#x3D;i₁(t) + i₂(t)，有I˙ &#x3D;I˙₁ + I˙₂</p>
<p>由u(t)&#x3D;u₁(t) + u₂(t)，有U˙ &#x3D;U˙₁ + U˙₂</p>
<p>结论对于有效值相量和振幅相量都适用。</p>
<h2><span id="基本元件伏安特性的相量形式">基本元件伏安特性的相量形式</span></h2><h3><span id="1电阻元件">1.电阻元件</span></h3><p><img src="/2024/04/01/%E6%AD%A3%E5%BC%A6%E7%A8%B3%E6%80%81%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240405130717.png" alt="微信图片_20240405130717"></p>
<h3><span id="2电感元件">2.电感元件</span></h3><p><img src="/2024/04/01/%E6%AD%A3%E5%BC%A6%E7%A8%B3%E6%80%81%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240405131106.png" alt="微信截图_20240405131106"></p>
<h3><span id="3电容元件">3.电容元件</span></h3><p><img src="/2024/04/01/%E6%AD%A3%E5%BC%A6%E7%A8%B3%E6%80%81%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240405132101.png" alt="微信截图_20240405132101"></p>
<h3><span id="4正弦电源的相量模型">4.正弦电源的相量模型</span></h3><p>①<strong>正弦电压源</strong>：如果一个独立电压源uₛ(t)的输出电压为正弦电压，即uₛ(t) &#x3D; √2 Uₛ sin(ωt + θᵤ)，就称其为正弦电压源。</p>
<p>参数：Uₛ→有效值；ω→角频率；θᵤ→初相。</p>
<p>②<strong>正弦电流源</strong>：Iₛ(t) &#x3D; √2 Iₛ sin(ωt + θᵤ)</p>
<p>③正弦受控源：VCVC,CCVS,VCCS,CCCS</p>
<h2><span id="相量模型">相量模型</span></h2><h3><span id="1阻抗和导纳">1.阻抗和导纳</span></h3><h4><span id="1阻抗z">（1）阻抗Z</span></h4><h5><span id="1概念">①概念</span></h5><p><img src="/2024/04/01/%E6%AD%A3%E5%BC%A6%E7%A8%B3%E6%80%81%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/4c636121dd444a1e847b36ec124dfc34.png" alt="4c636121dd444a1e847b36ec124dfc34"></p>
<p>X&#x3D;0时，阻抗Z成电阻性。</p>
<p>把X替换成φᶻ也成立（z是下标）。</p>
<h5><span id="2转换关系">②转换关系</span></h5><p>R &#x3D; |Z|cosφᶻ（z是下标）</p>
<p>X &#x3D; |Z|sinφᶻ</p>
<p>其中，</p>
<p>|Z| &#x3D; √（R² + X²） &#x3D; U&#x2F;I</p>
<p>φᶻ &#x3D; arctan（X&#x2F;R）&#x3D; θᵤ - θᵢ</p>
<h5><span id="3基本元件的阻抗">③基本元件的阻抗</span></h5><p><img src="/2024/04/01/%E6%AD%A3%E5%BC%A6%E7%A8%B3%E6%80%81%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/35e4c5e6308d447aadb1585fcfa64836.png" alt="35e4c5e6308d447aadb1585fcfa64836"></p>
<p>其中，X˪ &#x3D; ωL，Xᶜ &#x3D; -1&#x2F;ωC  （c是下标）</p>
<h4><span id="2导纳y">（2）导纳Y</span></h4><p><img src="/2024/04/01/%E6%AD%A3%E5%BC%A6%E7%A8%B3%E6%80%81%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/aba8b119efdc4c78845b70dc846c1eaa.png" alt="aba8b119efdc4c78845b70dc846c1eaa"></p>
<p>导纳的量纲是西门子（S）。</p>
<h3><span id="2相量图">2.相量图</span></h3><p>确定相量的角度需要两个步骤:</p>
<p>①第1步:确定参考相量，即角度为零的相量</p>
<p><strong>串联电路</strong>选<strong>电流</strong>作为参考相量</p>
<p><strong>并联电路</strong>选<strong>电压</strong>作为参考相量</p>
<p>②第2步:根据支路的VCR确定支路电压或电流相量的角度</p>
<p><strong>滞后</strong>：顺时针，后面（以U˪的相量形式作为参照）</p>
<p><strong>超前</strong>：逆时针，前面</p>
<p><img src="/2024/04/01/%E6%AD%A3%E5%BC%A6%E7%A8%B3%E6%80%81%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/fb1a95a4fab44f2aac3ed1a013f8078d.png" alt="fb1a95a4fab44f2aac3ed1a013f8078d"></p>
<p><img src="/2024/04/01/%E6%AD%A3%E5%BC%A6%E7%A8%B3%E6%80%81%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/db461cce59f34b9b9df7b855b362fb60.png" alt="db461cce59f34b9b9df7b855b362fb60"></p>
<p><img src="/2024/04/01/%E6%AD%A3%E5%BC%A6%E7%A8%B3%E6%80%81%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/f6acd5e9b5bb46fb92aa919e11f436a0.png" alt="f6acd5e9b5bb46fb92aa919e11f436a0"></p>
<h3><span id="3阻抗和导纳的串-并联">3.阻抗和导纳的串、并联</span></h3><p><img src="/2024/04/01/%E6%AD%A3%E5%BC%A6%E7%A8%B3%E6%80%81%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240415222834.png" alt="微信图片_20240415222834"></p>
<h2><span id="串联谐振">串联谐振</span></h2><h3><span id="1条件">1.条件</span></h3><p>①电路的总阻抗是：Z &#x3D; R + j(ωL - 1&#x2F;ωC)</p>
<p>②发生谐振时，端口电压U&#96;和端口电流I·同相，只有当阻抗的虚部为0才能满足此条件。</p>
<p>③公式：ω &#x3D; ω₀ &#x3D; 1 &#x2F; √（ωC）</p>
<h3><span id="2特征">2.特征</span></h3><p>①谐振时的阻抗最小，电流最大。</p>
<p>②谐振时的电压与电流同相。并且达到最大值。</p>
<p>③谐振时电感电压和电容电压大小相等，方向相反，电阻电压等于电源电压。</p>
]]></content>
      <tags>
        <tag>电子电路基础</tag>
      </tags>
  </entry>
  <entry>
    <title>栈的表示和操作实现</title>
    <url>/2024/04/05/%E6%A0%88%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E6%93%8D%E4%BD%9C%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#%E4%B8%80-%E9%A1%BA%E5%BA%8F%E6%A0%88">一、顺序栈</a></li>
<li><a href="#%E4%BA%8C-%E9%93%BE%E6%A0%88">二、链栈</a></li>
<li><a href="#%E4%B8%89-%E7%94%A8%E5%A0%86%E6%A0%88%E6%B1%82%E8%A7%A3%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F">三、用堆栈求解后缀表达式</a></li>
</ul>
<!-- tocstop -->

<p>[TOC]</p>
<h3><span id="一-顺序栈">一、顺序栈</span></h3><ul>
<li>存储结构：顺序存储</li>
<li>后进后出，插入和删除只在栈顶进行</li>
<li>递归</li>
<li>附设指针top指示栈顶元素在顺序栈的位置</li>
</ul>
<h4><span id="1定义">1.定义</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define MAXSIZE 100 //存储空间的初始分配量</span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line"></span><br><span class="line">int *base; //栈底指针，在构造前和销毁后，base的值为NULL</span><br><span class="line"></span><br><span class="line">int *top; //栈顶指针,指向栈顶元素的下一个位置</span><br><span class="line"></span><br><span class="line">int stacksize; //栈可用的最大容量</span><br><span class="line"></span><br><span class="line">&#125;SqStack;</span><br><span class="line">SqStack S;</span><br></pre></td></tr></table></figure>

<p>①看栈空</p>
<p>S.top &#x3D; -1; &#x2F;&#x2F;指针指向元素</p>
<p>S.top &#x3D; NULL; </p>
<p>S.top &#x3D; 0; &#x2F;&#x2F;指针指向栈顶元素的下一个位置</p>
<p>s.top &#x3D; S.base; </p>
<p>②看栈长</p>
<p>length &#x3D; S.top - S.base; &#x2F;&#x2F;指针指向栈顶元素的下一个位置</p>
<p>③看栈满</p>
<p>top - base &#x3D; stacksize;  &#x2F;&#x2F;指针指向栈顶元素的下一个位置</p>
<h4><span id="2初始化">2.初始化</span></h4><ul>
<li>分配存储空间，new int[]</li>
<li>如果分配失败，!base，返回-1</li>
<li>否则使空栈，栈顶&#x3D;栈底</li>
<li>使定义中的stacksize获得最大容量</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int InitStack(SqStack &amp;S)&#123;</span><br><span class="line">//构造一个空栈</span><br><span class="line"></span><br><span class="line">S.base = new int[MAXSIZE]; //为顺序栈分配一个指定最大容量的存储空间</span><br><span class="line"></span><br><span class="line">if(S.base==NULL) return -1; //存储分配失败</span><br><span class="line"></span><br><span class="line">S.top = S.base; //空栈</span><br><span class="line"></span><br><span class="line">S.stacksize = MAXSIZE; //stacksize置为最大容量</span><br><span class="line"></span><br><span class="line">return 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="3入栈">3.入栈</span></h4><ul>
<li>判断栈满</li>
<li>否则对e取值</li>
<li>移动指针</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int Push(SqStack &amp;S,int e)&#123;</span><br><span class="line">//插入元素e为新的栈顶</span><br><span class="line"></span><br><span class="line">if(S.top-S.base = stacksize) return -1; //栈满</span><br><span class="line"></span><br><span class="line">*S.top++ = e;  //元素e压入栈顶后，指针+1</span><br><span class="line"></span><br><span class="line">//等价于*S.top = e; S.top++;</span><br><span class="line"></span><br><span class="line">return 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="4出栈">4.出栈</span></h4><ul>
<li>判断栈空</li>
<li>否则栈顶-1</li>
<li>出栈元素赋给元素e</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int Pop(SqStack &amp;S,int &amp;e)&#123;</span><br><span class="line">//删除S的栈顶元素，用e返回其值</span><br><span class="line"></span><br><span class="line">if(S.top == S.base) return -1; //栈空</span><br><span class="line"></span><br><span class="line">e = *--S.top; //栈顶指针-1，将栈顶元素赋给e</span><br><span class="line"></span><br><span class="line">//等价于--S.top; e=*S.top;</span><br><span class="line"></span><br><span class="line">return 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="5取栈顶元素">5.取栈顶元素</span></h4><ul>
<li>判断栈非空</li>
<li>返回当前栈顶元素的值，不修改指针</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int GetTop(SqStack S)&#123;</span><br><span class="line">//返回S的栈顶元素，不修改栈顶指针</span><br><span class="line"></span><br><span class="line">if(S.top! = S.base) //栈非空</span><br><span class="line"></span><br><span class="line">return *(S.top-1); //这是因为栈顶指针指向的不是真实元素，而是元素的下一个</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="二-链栈">二、链栈</span></h3><h4><span id="1定义">1.定义</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct StackNode &#123;</span><br><span class="line"></span><br><span class="line">int data;    </span><br><span class="line"></span><br><span class="line">struct StackNode* next; </span><br><span class="line"></span><br><span class="line">&#125;StackLink, *Linkstack;</span><br><span class="line"></span><br><span class="line">LinkStack S;</span><br></pre></td></tr></table></figure>

<p>链栈是操作受限的单链表，只能在链表的头部进行操作，故没有必要附加头结点。</p>
<ul>
<li>栈顶指针就是链表的头结点。</li>
<li>链栈插入与删除仅在栈顶处执行(头插法&#x2F;头删法)。</li>
<li>栈无栈满问题，空间可扩充适合于多栈操作。</li>
</ul>
<h4><span id="2初始化">2.初始化</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int InitStack(LinkStack &amp;S)&#123;</span><br><span class="line">//构造一个空栈S，栈顶指针置空</span><br><span class="line"></span><br><span class="line">S= NULL;</span><br><span class="line"></span><br><span class="line">return 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="3入栈">3.入栈</span></h4><ul>
<li>为入栈元素e分配空间，用指针p指向 p&#x3D; new LinkStack</li>
<li>对新结点赋值e</li>
<li>把新结点插入到栈顶</li>
<li>修改栈顶指针为p</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int Push(LinkStack &amp;S,int e)&#123;</span><br><span class="line">//在栈顶插入元素e</span><br><span class="line"></span><br><span class="line">p = new LinkStack; //生成新结点</span><br><span class="line">if(!p) return -1;</span><br><span class="line"></span><br><span class="line">p-&gt;data = e; //赋值</span><br><span class="line"></span><br><span class="line">p-&gt;next = S; //将新栈顶插入</span><br><span class="line"></span><br><span class="line">S = p; //使p成为栈顶指针</span><br><span class="line"></span><br><span class="line">return 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="4出栈">4.出栈</span></h4><ul>
<li>判断栈空</li>
<li>否则将栈顶元素赋值给e</li>
<li>用结点p临时保存栈顶元素的空间</li>
<li>下移栈顶指针</li>
<li>释放p结点</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int Pop(LinkStack &amp;S，int &amp;e)&#123;</span><br><span class="line">//删除S的栈顶元素，用e返回其值</span><br><span class="line"></span><br><span class="line">if(S=NULL) return -1; //栈空</span><br><span class="line"></span><br><span class="line">e = S-&gt;data; //赋值</span><br><span class="line"></span><br><span class="line">LinkStack* p;</span><br><span class="line"></span><br><span class="line">p = S; //用p临时保存栈顶元素空间</span><br><span class="line"></span><br><span class="line">S = S-&gt;next; //下移栈顶指针</span><br><span class="line"></span><br><span class="line">free(p); //释放</span><br><span class="line"></span><br><span class="line">return 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="5读栈顶元素">5.读栈顶元素</span></h4><ul>
<li>当栈非空，返回S的值，栈顶S保持不变</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int GetTop(LinkStack S)&#123;</span><br><span class="line">//返回S的栈顶元素，不修改栈顶指针</span><br><span class="line"></span><br><span class="line">if(S!=NULL) </span><br><span class="line"></span><br><span class="line">return S-&gt;data;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="三-用堆栈求解后缀表达式">三、用堆栈求解后缀表达式</span></h3><h4><span id="1定义">1.定义</span></h4><p>后缀表达式是一种不需要括号的表达式，其本身是对栈的一种应用。</p>
<p>与之对应的是中缀表达式，即我们现在使用的四则运算。</p>
<h4><span id="2运算规则">2.运算规则</span></h4><p>顺序：从左到右入栈。</p>
<p>对于数字直接入栈，对于运算符号，就把栈最上面的两个数出栈，进行运算后再重新入栈。式子最后的结果出栈。</p>
<p>栈顶元素永远在运算符的右边。</p>
<h4><span id="3例子">3.例子</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）令P代表入栈，O代表出栈。当利用堆栈求解后缀表达式1 2 3 + * 4 –时，堆栈操作序列是：</span><br><span class="line"></span><br><span class="line">A.PPPOOPOO</span><br><span class="line"></span><br><span class="line">B.PPOOPPOOPPOO</span><br><span class="line"></span><br><span class="line">C.PPPOOPOOPPOO</span><br><span class="line"></span><br><span class="line">D.PPPOOPOOPPOOPO</span><br></pre></td></tr></table></figure>

<p>1、2、3：进栈，PPP</p>
<p>+：对最顶上的3、2出栈，计算2+3&#x3D;5，把结果进栈，OOP</p>
<p>*：对5、1出栈，计算5x1&#x3D;5，把结果进栈，OOP</p>
<p>4：进栈，P</p>
<p>-：对4、5出栈，计算4-5&#x3D;-1，把结果进栈，OOP</p>
<p>最后输出结果：O</p>
<p>答案为D。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（2）表达式`a*(b+c)-d`的后缀表达式是：</span><br><span class="line"></span><br><span class="line">A.`a b c + * d -`</span><br><span class="line"></span><br><span class="line">B.`a b c d * + -`</span><br><span class="line"></span><br><span class="line">C.`a b c * + d -`</span><br><span class="line"></span><br><span class="line">D.`- + * a b c d`</span><br></pre></td></tr></table></figure>

<p>数字优先进栈，所以abc</p>
<p>括号内的式子优先计算，所以首先遇到+，为abc+</p>
<p>算完加法算乘法，所以abc+*</p>
<p>继续将d进栈，然后算减法，所以是abc+*d-</p>
<p>答案为A。</p>
]]></content>
      <tags>
        <tag>数据结构笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>用链表实现交集和并集</title>
    <url>/2024/03/24/%E7%94%A8%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E4%BA%A4%E9%9B%86%E5%92%8C%E5%B9%B6%E9%9B%86/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#7-1-%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%BA%8F%E5%88%97%E7%9A%84%E4%BA%A4%E9%9B%86"><strong>7-1 两个有序链表序列的交集</strong></a><ul>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F">输入格式:</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F">输出格式:</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B">输入样例:</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B">输出样例:</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">代码实现：</a></li>
</ul>
</li>
<li><a href="#7-2-%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%BA%8F%E5%88%97%E7%9A%84%E5%90%88%E5%B9%B6"><strong>7-2 两个有序链表序列的合并</strong></a><ul>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-1">输入格式:</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-1">输出格式:</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B-1">输入样例:</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B-1">输出样例:</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1">代码实现：</a></li>
</ul>
</li>
<li><a href="#7-3-%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%90%88%E5%B9%B6%E6%96%B0%E8%A1%A8%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0"><strong>7-3 两个有序链表合并（新表不含重复元素）</strong></a><ul>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-2">输入格式:</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-2">输出格式:</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B-2">输入样例:</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B-2">输出样例:</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2">代码实现：</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<p>[TOC]</p>
<h2><span id="7-1-两个有序链表序列的交集"><strong>7-1 两个有序链表序列的交集</strong></span></h2><p>已知两个非降序链表序列S1与S2，设计函数构造出S1与S2的交集新链表S3。</p>
<h3><span id="输入格式">输入格式:</span></h3><p>输入分两行，分别在每行给出由若干个正整数构成的非降序序列，用−1表示序列的结尾（−1不属于这个序列）。数字用空格间隔。</p>
<h3><span id="输出格式">输出格式:</span></h3><p>在一行中输出两个输入序列的交集序列，数字间用空格分开，结尾不能有多余空格；若新链表为空，输出<code>NULL</code>。</p>
<h3><span id="输入样例">输入样例:</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 5 -1</span><br><span class="line">2 4 5 8 10 -1</span><br></pre></td></tr></table></figure>

<h3><span id="输出样例">输出样例:</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 5</span><br></pre></td></tr></table></figure>

<h3><span id="代码实现">代码实现：</span></h3><p>这段程序的通过难点主要在于关心交集为空的情况，分为两种：</p>
<p>①集合1和集合2之间最少有一个为空</p>
<p>②集合1和集合2不是空集，但是相同元素的个数为0</p>
<p>针对第二种情况，只需要设置一个计数器i&#x3D;0，当集合1的元素&#x3D;&#x3D;集合2的元素时，i++，若运行到循环结束，i仍然为0，说明得到的交集为空</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef struct LNode&#123;</span><br><span class="line">    int data;</span><br><span class="line">    struct LNode *next;</span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"></span><br><span class="line">int creatlist(LinkList &amp;S1,LinkList &amp;S2)&#123;</span><br><span class="line">    LNode *p1,*p2,*r;</span><br><span class="line">    p1=S1,p2=S2;</span><br><span class="line">    r=S1;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        p1=new LNode;</span><br><span class="line">        cin&gt;&gt;p1-&gt;data;</span><br><span class="line">        if(p1-&gt;data==-1) break;//在链表录入-1前结束循环</span><br><span class="line">        p1-&gt;next=NULL;</span><br><span class="line">        r-&gt;next=p1;</span><br><span class="line">        r=p1;</span><br><span class="line">    &#125;//尾插法</span><br><span class="line">    r=S2;//循环利用变量r</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        p2=new LNode;</span><br><span class="line">        cin&gt;&gt;p2-&gt;data;</span><br><span class="line">        if(p2-&gt;data==-1) break;</span><br><span class="line">        p2-&gt;next=NULL;</span><br><span class="line">        r-&gt;next=p2;</span><br><span class="line">        r=p2;</span><br><span class="line">    &#125;//尾插法</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int jiaoji(LinkList &amp;S1,LinkList &amp;S2)&#123;</span><br><span class="line">    LNode *S3,*p3,*r;</span><br><span class="line">    LNode *p1,*p2;</span><br><span class="line">    p1=S1-&gt;next,p2=S2-&gt;next;</span><br><span class="line">    S3=new LNode;</span><br><span class="line">    S3-&gt;next=NULL;</span><br><span class="line">    r=S3;</span><br><span class="line">    int i=0;//统计S3的长度</span><br><span class="line">    if(S1==NULL || S2==NULL)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;NULL&quot;;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    while(p1&amp;&amp;p2)&#123;</span><br><span class="line">        if(p1-&gt;data==p2-&gt;data)&#123;</span><br><span class="line">            i++;</span><br><span class="line">            p3=new LNode;</span><br><span class="line">            p3-&gt;data=p1-&gt;data;</span><br><span class="line">            p3-&gt;next=NULL;</span><br><span class="line">            r-&gt;next=p3;</span><br><span class="line">            r=p3;</span><br><span class="line">            p1=p1-&gt;next;</span><br><span class="line">            p2=p2-&gt;next;</span><br><span class="line">        &#125;else if(p1-&gt;data&gt;p2-&gt;data) p2=p2-&gt;next;</span><br><span class="line">        else if(p1-&gt;data&lt;p2-&gt;data) p1=p1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    if(i==0) &#123;</span><br><span class="line">        cout&lt;&lt;&quot;NULL&quot;;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    p3=S3-&gt;next;//p3重新退回头结点指向的位置</span><br><span class="line">    while(p3-&gt;next)&#123;</span><br><span class="line">        cout&lt;&lt;p3-&gt;data&lt;&lt;&quot; &quot;;</span><br><span class="line">        p3=p3-&gt;next;</span><br><span class="line">    &#125;cout&lt;&lt;p3-&gt;data;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    LNode *S1,*S2;</span><br><span class="line">    S1=new LNode;</span><br><span class="line">    S1-&gt;next=NULL;</span><br><span class="line">    S2=new LNode;</span><br><span class="line">    S2-&gt;next=NULL;</span><br><span class="line">    creatlist(S1,S2);</span><br><span class="line">    jiaoji(S1,S2);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>测试点</td>
<td>提示</td>
<td>内存(KB)</td>
<td>用时(ms)</td>
<td>结果</td>
<td>得分</td>
<td></td>
</tr>
<tr>
<td>0</td>
<td>样例等价</td>
<td>300</td>
<td>2</td>
<td>答案正确</td>
<td>2 &#x2F; 2</td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>交集为空</td>
<td>488</td>
<td>3</td>
<td>答案正确</td>
<td>2 &#x2F; 2</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>完全相交</td>
<td>276</td>
<td>3</td>
<td>答案正确</td>
<td>2 &#x2F; 2</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>其中一个序列完全属于交集</td>
<td>492</td>
<td>2</td>
<td>答案正确</td>
<td>2 &#x2F; 2</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>其中一个序列为空</td>
<td>492</td>
<td>3</td>
<td>答案正确</td>
<td>2 &#x2F; 2</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>大规模数据</td>
<td>31864</td>
<td>291</td>
<td>答案正确</td>
<td>2 &#x2F; 2</td>
<td></td>
</tr>
</tbody></table>
<h2><span id="7-2-两个有序链表序列的合并"><strong>7-2 两个有序链表序列的合并</strong></span></h2><p>已知两个非降序链表序列S1与S2，设计函数构造出S1与S2合并后的新的非降序链表S3。</p>
<h3><span id="输入格式">输入格式:</span></h3><p>输入分两行，分别在每行给出由若干个正整数构成的非降序序列，用−1表示序列的结尾（−1不属于这个序列）。数字用空格间隔。</p>
<h3><span id="输出格式">输出格式:</span></h3><p>在一行中输出合并后新的非降序链表，数字间用空格分开，结尾不能有多余空格；若新链表为空，输出<code>NULL</code>。</p>
<h3><span id="输入样例">输入样例:</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 3 5 -1</span><br><span class="line">2 4 6 8 10 -1</span><br></pre></td></tr></table></figure>

<h3><span id="输出样例">输出样例:</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3 4 5 6 8 10</span><br></pre></td></tr></table></figure>

<h3><span id="代码实现">代码实现：</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef struct LNode&#123;</span><br><span class="line">    int data;</span><br><span class="line">    struct LNode *next;</span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"></span><br><span class="line">int creatlist(LinkList &amp;S1,LinkList &amp;S2)&#123;</span><br><span class="line">    LNode *p1,*p2,*r;</span><br><span class="line">    r=S1;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        p1=new LNode;</span><br><span class="line">        cin&gt;&gt;p1-&gt;data;</span><br><span class="line">        if(p1-&gt;data==-1) break;</span><br><span class="line">        p1-&gt;next=NULL;</span><br><span class="line">        r-&gt;next=p1;</span><br><span class="line">        r=p1;</span><br><span class="line">    &#125;</span><br><span class="line">    r=S2;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        p2=new LNode;</span><br><span class="line">        cin&gt;&gt;p2-&gt;data;</span><br><span class="line">        if(p2-&gt;data==-1) break;</span><br><span class="line">        p2-&gt;next=NULL;</span><br><span class="line">        r-&gt;next=p2;</span><br><span class="line">        r=p2;</span><br><span class="line">    &#125;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line">int bingji(LinkList &amp;S1,LinkList &amp;S2)&#123;</span><br><span class="line">    LNode *p1,*p2;</span><br><span class="line">    p1=S1-&gt;next,p2=S2-&gt;next;</span><br><span class="line">    LNode *S3,*p3;</span><br><span class="line">    S3=S1;</span><br><span class="line">    p3=S3;</span><br><span class="line">    while(p1&amp;&amp;p2)&#123;</span><br><span class="line">        if(p1-&gt;data&lt;=p2-&gt;data)&#123;</span><br><span class="line">            p3-&gt;next=p1;</span><br><span class="line">            p3=p1;</span><br><span class="line">            p1=p1-&gt;next;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            p3-&gt;next=p2;</span><br><span class="line">            p3=p2;</span><br><span class="line">            p2=p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    p3-&gt;next=p1?p1:p2;</span><br><span class="line">    //三目运算符，等价于</span><br><span class="line">    //if(p1)p3-&gt;next=p1; </span><br><span class="line">    //else if(p2)p3-a.next=p2;</span><br><span class="line">    </span><br><span class="line">    free(S2);//释放头结点</span><br><span class="line">    p3=S3-&gt;next;</span><br><span class="line">    if(p3==NULL)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;NULL&quot;;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    while(p3-&gt;next)&#123;</span><br><span class="line">        cout&lt;&lt;p3-&gt;data&lt;&lt;&quot; &quot;;</span><br><span class="line">        p3=p3-&gt;next;</span><br><span class="line">    &#125;cout&lt;&lt;p3-&gt;data;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    return 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    LNode *S1,*S2;</span><br><span class="line">    S1=new LNode,S2=new LNode;</span><br><span class="line">    S1-&gt;next=NULL,S2-&gt;next=NULL;</span><br><span class="line">    creatlist(S1,S2);</span><br><span class="line">    bingji(S1,S2);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>测试点</th>
<th>提示</th>
<th>内存(KB)</th>
<th>用时(ms)</th>
<th>结果</th>
<th>得分</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>样例等价</td>
<td>400</td>
<td>2</td>
<td>答案正确</td>
<td>5 &#x2F; 5</td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>有并列</td>
<td>288</td>
<td>2</td>
<td>答案正确</td>
<td>5 &#x2F; 5</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>链表为空</td>
<td>400</td>
<td>2</td>
<td>答案正确</td>
<td>5 &#x2F; 5</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>大规模输入</td>
<td>46228</td>
<td>370</td>
<td>答案正确</td>
<td>5 &#x2F; 5</td>
<td></td>
</tr>
</tbody></table>
<h2><span id="7-3-两个有序链表合并新表不含重复元素"><strong>7-3 两个有序链表合并（新表不含重复元素）</strong></span></h2><p>已知两个非降序链表序列S1与S2，设计函数构造出S1与S2合并后的新的非降序链表S3。<br>要求S3中没有重复元素。</p>
<h3><span id="输入格式">输入格式:</span></h3><p>输入分两行，分别在每行给出由若干个正整数构成的非降序序列，用−1表示序列的结尾（−1不属于这个序列）。数字用空格间隔。</p>
<h3><span id="输出格式">输出格式:</span></h3><p>在一行中输出合并后新的非降序链表，要求链表中没有重复元素。数字间用空格分开，结尾不能有多余空格；若新链表为空，输出NULL。</p>
<h3><span id="输入样例">输入样例:</span></h3><p>在这里给出一组输入。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 3 3 5 8 -1</span><br><span class="line">2 3 4 6 8 10 -1</span><br></pre></td></tr></table></figure>

<h3><span id="输出样例">输出样例:</span></h3><p>在这里给出相应的输出。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3 4 5 6 8 10</span><br></pre></td></tr></table></figure>

<h3><span id="代码实现">代码实现：</span></h3><p>这一段程序相对于上一题的难点在于：</p>
<p>①要求并集中的元素不可重复，因此必须细致的分类讨论集合1大于、小于或等于集合2，以及集合1和集合2的值分别等不等于并集已存在的值</p>
<p>②设置了测试点：一个是空表，一个只有两个相同的元素。如果不加上p3-&gt;next&#x3D;NULL，程序会报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef struct LNode&#123;</span><br><span class="line">    int data;</span><br><span class="line">    struct LNode *next;</span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"></span><br><span class="line">int creatlist(LinkList &amp;S1,LinkList &amp;S2)&#123;</span><br><span class="line">    LNode *p1,*p2,*r;</span><br><span class="line">    r=S1;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        p1=new LNode;</span><br><span class="line">        cin&gt;&gt;p1-&gt;data;</span><br><span class="line">        if(p1-&gt;data==-1) break;</span><br><span class="line">        p1-&gt;next=NULL;</span><br><span class="line">        r-&gt;next=p1;</span><br><span class="line">        r=p1;</span><br><span class="line">    &#125;</span><br><span class="line">    r=S2;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        p2=new LNode;</span><br><span class="line">        cin&gt;&gt;p2-&gt;data;</span><br><span class="line">        if(p2-&gt;data==-1) break;</span><br><span class="line">        p2-&gt;next=NULL;</span><br><span class="line">        r-&gt;next=p2;</span><br><span class="line">        r=p2;</span><br><span class="line">    &#125;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line">int bingji(LinkList &amp;S1,LinkList &amp;S2)&#123;</span><br><span class="line">    LNode *p1,*p2;</span><br><span class="line">    p1=S1-&gt;next,p2=S2-&gt;next;</span><br><span class="line">    LNode *S3,*p3;</span><br><span class="line">    S3=S1;</span><br><span class="line">    p3=S3;</span><br><span class="line">    while(p1&amp;&amp;p2)&#123;</span><br><span class="line">        if(p1-&gt;data&lt;p2-&gt;data &amp;&amp;p1-&gt;data!=p3-&gt;data)&#123;</span><br><span class="line">            p3-&gt;next=p1;</span><br><span class="line">            p3=p1;</span><br><span class="line">            p1=p1-&gt;next;</span><br><span class="line">        &#125;else if(p1-&gt;data&gt;p2-&gt;data&amp;&amp;p2-&gt;data!=p3-&gt;data)&#123;</span><br><span class="line">            p3-&gt;next=p2;</span><br><span class="line">            p3=p2;</span><br><span class="line">            p2=p2-&gt;next;</span><br><span class="line">        &#125;else if(p1-&gt;data==p2-&gt;data&amp;&amp;p1-&gt;data!=p3-&gt;data)&#123;</span><br><span class="line">            p3-&gt;next=p1;</span><br><span class="line">            p3=p1;</span><br><span class="line">            p1=p1-&gt;next;</span><br><span class="line">            p2=p2-&gt;next;</span><br><span class="line">        &#125;else if(p1-&gt;data==p3-&gt;data) p1=p1-&gt;next;</span><br><span class="line">        else if(p2-&gt;data==p3-&gt;data) p2=p2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    while(p1)&#123;</span><br><span class="line">        if(p3-&gt;data!=p1-&gt;data)&#123;</span><br><span class="line">            p3-&gt;next=p1;</span><br><span class="line">            p3=p1;</span><br><span class="line">        &#125;</span><br><span class="line">        p1=p1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    while(p2)&#123;</span><br><span class="line">        if(p3-&gt;data!=p2-&gt;data)&#123;</span><br><span class="line">            p3-&gt;next=p2;</span><br><span class="line">            p3=p2;</span><br><span class="line">        &#125;</span><br><span class="line">        p2=p2-&gt;next;</span><br><span class="line">    &#125;//不能简单地使用三目运算符，因为必须考虑值相等的情况</span><br><span class="line">    p3-&gt;next=NULL;//如果没有这一条，会报错一个测试点</span><br><span class="line">    free(S2);//释放头结点</span><br><span class="line">    p3=S3-&gt;next;</span><br><span class="line">    if(p3==NULL)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;NULL&quot;;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    while(p3-&gt;next)&#123;</span><br><span class="line">        cout&lt;&lt;p3-&gt;data&lt;&lt;&quot; &quot;;</span><br><span class="line">        p3=p3-&gt;next;</span><br><span class="line">    &#125;cout&lt;&lt;p3-&gt;data;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    return 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    LNode *S1,*S2;</span><br><span class="line">    S1=new LNode,S2=new LNode;</span><br><span class="line">    S1-&gt;next=NULL,S2-&gt;next=NULL;</span><br><span class="line">    creatlist(S1,S2);</span><br><span class="line">    bingji(S1,S2);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>测试点</td>
<td>提示</td>
<td>内存(KB)</td>
<td>用时(ms)</td>
<td>结果</td>
<td>得分</td>
<td></td>
</tr>
<tr>
<td>0</td>
<td>样例</td>
<td>316</td>
<td>2</td>
<td>答案正确</td>
<td>5 &#x2F; 5</td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>一个是空表，另一个只有两个相同元素</td>
<td>316</td>
<td>2</td>
<td>答案正确</td>
<td>5 &#x2F; 5</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>两个表都只有一个元素且相同</td>
<td>316</td>
<td>2</td>
<td>答案正确</td>
<td>5 &#x2F; 5</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>两个表有很多相同元素</td>
<td>452</td>
<td>2</td>
<td>答案正确</td>
<td>5 &#x2F; 5</td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>数据结构笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>队列的表示和操作实现</title>
    <url>/2024/05/26/%E9%98%9F%E5%88%97%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E6%93%8D%E4%BD%9C%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#%E4%B8%80-%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E9%98%9F%E5%88%97%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8">一、循环队列（队列的顺序存储）</a></li>
<li><a href="#%E4%BA%8C-%E9%93%BE%E6%A0%88">二、链栈</a></li>
</ul>
<!-- tocstop -->

<p>[TOC]</p>
<h3><span id="一-循环队列队列的顺序存储">一、循环队列（队列的顺序存储）</span></h3><p>如果用户的应用程序中设有循环队列，就必须为它设定一个最大队列长度。</p>
<h4><span id="1定义">1.定义</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define MAXQSIZE 100 //队列可能达到的长度</span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line"></span><br><span class="line">int *base; //存储空间的基地址</span><br><span class="line"></span><br><span class="line">int front; //头指针，若队列不空，指向队列头元素（实位）</span><br><span class="line"></span><br><span class="line">int rear; //尾指针，若队列不空，指向队列尾元素的下一个位置（虚位）</span><br><span class="line"></span><br><span class="line">&#125;SqQueue;</span><br><span class="line"></span><br><span class="line">SqQueue Q;</span><br></pre></td></tr></table></figure>

<h5><span id="顺序队列非循环队列">顺序队列——非循环队列</span></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">初始化队列：Q.front=Q.rear=0;</span><br><span class="line"></span><br><span class="line">入队：新元素按 rear 指示位置加入，再将队尾指针加一，即</span><br><span class="line">Q.base[Q.rear] = e;</span><br><span class="line">Q.rear = Q.rear+1;</span><br><span class="line"></span><br><span class="line">出队：将front指示的元素取出，再将队头指针加一，即 </span><br><span class="line">e=Q.base[O.front];</span><br><span class="line">Q.front= Q.front+ 1;</span><br><span class="line"></span><br><span class="line">队空：Q.front==Q.rear;</span><br><span class="line"></span><br><span class="line">队满：Q.rear-Q.front==MAXQSIZE;</span><br><span class="line"></span><br><span class="line">求队长：Q.rear-Q.front;</span><br></pre></td></tr></table></figure>

<p>存在“假上溢”的现象：<u>因数组越界而导致的程序非法操作错误，并且此时队列的实际可用空间并未占满。</u></p>
<h5><span id="循环队列">循环队列</span></h5><p>防假上溢：少用一个元素空间，即队列空间大小为m时，有m-1个元素就认为是队满。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">队列初始化： Q.front = Q.rear =0;</span><br><span class="line"></span><br><span class="line">队空：Q.front == Q.rear;</span><br><span class="line"></span><br><span class="line">队满：(Q.rear + 1)%MAXQSIZE ==Q.front;</span><br><span class="line"></span><br><span class="line">入队：（1）队列不满，新元素e插入Q.rear所指的位置</span><br><span class="line">      Q.base[Q.rear] = e;</span><br><span class="line">      （2）Q.rear = (Q.rear+1)%MAXQSIZE;</span><br><span class="line">出队：（1）队列不空，删除Q.front所指的元素</span><br><span class="line">      e = Q.base[Q.front];</span><br><span class="line">     （2）Q.front = (Q.front+1)%MAXQSIZE;</span><br><span class="line">求队长：</span><br><span class="line">(Q.rear - Q.front + MAXQSIZE)%MAXQSIZE;</span><br></pre></td></tr></table></figure>

<h4><span id="2初始化">2.初始化</span></h4><ul>
<li>分配一个最大容量为MAXQSIZE的存储空间Q.base &#x3D; new int[]</li>
<li>判断分配失败</li>
<li>否则将头指针和尾指针置为0，表示队列为空</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int InitQueue(SqQueue &amp;Q)&#123;</span><br><span class="line">//构造一个空队列</span><br><span class="line"></span><br><span class="line">Q.base = new int[MAXQSIZE]; //分配存储空间</span><br><span class="line"></span><br><span class="line">if(!Q.base) return -1; //分配失败</span><br><span class="line"></span><br><span class="line">Q.front = Q.rear=0; //头指针、尾指针置为0，表示队列为空</span><br><span class="line"></span><br><span class="line">return 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="3入队">3.入队</span></h4><ul>
<li>判断队满</li>
<li>否则将新元素插入队尾</li>
<li>队尾指针+1</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int EnQueue(SqQueue &amp;Q,int e)&#123;</span><br><span class="line">//插入元素e为Q的新队尾元素</span><br><span class="line"></span><br><span class="line">if((Q.rear+1)%MAXQSIZE==Q.front)</span><br><span class="line">//尾指针在循环意义上+1后等于头指针，表示队满</span><br><span class="line"></span><br><span class="line">return -1;</span><br><span class="line"></span><br><span class="line">Q.base[Q.rear] = e; //新元素插入队尾</span><br><span class="line"></span><br><span class="line">Q.rear = (Q.rear+1)%MAXQSIZE; //队尾指针+1</span><br><span class="line"></span><br><span class="line">return 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="4出队">4.出队</span></h4><ul>
<li>判断队空</li>
<li>否则保存队头元素</li>
<li>队头指针+1</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int DeQueue(SqQueue &amp;Q,int &amp;e)&#123;</span><br><span class="line">//删除Q的队头元素，用e返回其值</span><br><span class="line"></span><br><span class="line">if(Q.front == Q.rear) return -1;//队空</span><br><span class="line"></span><br><span class="line">e = Q.base[Q.front]; //保存队头元素</span><br><span class="line"></span><br><span class="line">Q.front = (Q.front + 1 )%MAXQSIZE； //队头指针+1</span><br><span class="line"></span><br><span class="line">return 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="5取队头元素">5.取队头元素</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int GetHead(SqQueue Q)&#123;</span><br><span class="line">//返回Q的队头元素，不修改队头指针</span><br><span class="line"></span><br><span class="line">if(Q.front!=Q.rear) //非空</span><br><span class="line"></span><br><span class="line">return Q.base[Q.front];//返回队头</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="二-链栈">二、链栈</span></h3><p>采用链式存储结构实现的队列称为<strong>链队列</strong>。</p>
<p>为了使操作更加方便，将队头指针指向链队列的头结点，而队尾指针指向终端结点。 </p>
<p><strong>空队列时，front和rear都指向头结点，即front&#x3D;&#x3D;rear</strong></p>
<h4><span id="1定义">1.定义</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct QNode&#123;</span><br><span class="line">int data;</span><br><span class="line">struct QNode *next;</span><br><span class="line">&#125;QNode,*QueuePtr;</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">QueuePtr front; //队头指针</span><br><span class="line">QueuePtr rear; //队尾指针</span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/05/26/%E9%98%9F%E5%88%97%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E6%93%8D%E4%BD%9C%E5%AE%9E%E7%8E%B0/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240526020235.png" alt="微信截图_20240526020235"></p>
<h4><span id="2初始化">2.初始化</span></h4><p>构造一个只有一个头结点的空队。</p>
<ul>
<li>生成新结点作为头结点，队头和队尾指针指向此结点</li>
<li>头结点的指针域置空</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int InitQueue(LinkQueue &amp;Q)&#123;</span><br><span class="line"></span><br><span class="line">//构造一个空队列Q</span><br><span class="line"></span><br><span class="line">Q.front = Q.rear =new QNode;  //生成新结点作为头结点，队头和队尾指针指向此结点</span><br><span class="line"></span><br><span class="line">Q.front-&gt;next = NULL; //头结点的指针域置空</span><br><span class="line"></span><br><span class="line">return 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="3入队">3.入队</span></h4><p><strong>链队在入队前不需要判断队满，需要为入队元素分配结点空间。</strong></p>
<ul>
<li>为入队元素分配结点空间，用指针p指向</li>
<li>将新结点数据域置为e</li>
<li>将新结点插入到队尾</li>
<li>修改队尾指针为p</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int EnQueue(LinkQueue &amp;Q,int e)&#123;</span><br><span class="line">//插入元素e为Q的新队尾元素</span><br><span class="line"></span><br><span class="line">p = new QNode; //分配新结点</span><br><span class="line"></span><br><span class="line">p-&gt;data = e; //把p的数据域置为e</span><br><span class="line"></span><br><span class="line">p-&gt;next = NULL; Q.rear-&gt;next = p;//把新结点插到队尾</span><br><span class="line"></span><br><span class="line">Q.rear = p; //修改队尾指针</span><br><span class="line"></span><br><span class="line">return 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="4出队">4.出队</span></h4><p><strong>链队在出队前需要判断队列是否为空，不同的是，链队在出队后需要放出队头元素的所占空间。</strong></p>
<ul>
<li>判断队空</li>
<li>否则临时保存队头元素的空间，等待释放</li>
<li>修改头结点的指针域，指向下一个结点</li>
<li>判断出队元素是否为最后一个元素，若是，则将队尾指针重新赋值，指向头结点</li>
<li>释放原队头元素</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int DeQueue(LinkQueue &amp;Q,int &amp;e)&#123;</span><br><span class="line">//删除Q的队头元素，用e返回其值</span><br><span class="line"></span><br><span class="line">if(Q.front==Q.rear) retrun -1; //队空</span><br><span class="line"></span><br><span class="line">p = Q.front-&gt;next; //p指向队头元素</span><br><span class="line"></span><br><span class="line">e = p-&gt;data; //e保存队头元素的值</span><br><span class="line"></span><br><span class="line">Q.front-&gt;next = p-&gt;next;  //修改头结点的指针域</span><br><span class="line"></span><br><span class="line">if(Q.rear == p) Q.rear = Q.front; //最后一个元素被删，队尾指针指向头结点</span><br><span class="line"></span><br><span class="line">free(p); //释放原队头元素</span><br><span class="line"></span><br><span class="line">return 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.求队头元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int GetHead(LinkQueue Q)&#123;</span><br><span class="line">//返回Q的队头元素，不修改队头指针</span><br><span class="line"></span><br><span class="line">if(Q.front!=Q.rear)</span><br><span class="line"></span><br><span class="line">return Q.front-&gt;next-&gt;data;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>数据结构笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>电路的一般分析方法</title>
    <url>/2024/03/14/%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#%E7%94%B5%E8%B7%AF%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%AE%9A%E5%BE%8B">电路的基本概念和基本定律</a><ul>
<li><a href="#1%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8F%98%E9%87%8F">1.电路分析的基本变量</a></li>
<li><a href="#2%E5%9F%BA%E5%B0%94%E9%9C%8D%E5%A4%AB%E5%AE%9A%E5%BE%8B">2.基尔霍夫定律</a></li>
<li><a href="#3%E7%94%B5%E8%B7%AF%E5%85%83%E4%BB%B6">3.电路元件</a></li>
</ul>
</li>
<li><a href="#%E7%94%B5%E9%98%BB%E7%94%B5%E8%B7%AF%E7%9A%84%E4%B8%80%E8%88%AC%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95">电阻电路的一般分析方法</a><ul>
<li><a href="#%E7%AD%89%E6%95%88%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90%E6%B3%95">等效电路分析法</a></li>
<li><a href="#%E7%BD%91%E5%AD%94%E5%88%86%E6%9E%90%E6%B3%95%E4%BE%8B%E9%A2%98p39">网孔分析法（例题p39)</a></li>
<li><a href="#%E8%8A%82%E7%82%B9%E5%88%86%E6%9E%90%E6%B3%95">节点分析法</a></li>
<li><a href="#%E5%BC%A5%E5%B0%94%E6%9B%BC%E5%AE%9A%E7%90%86">弥尔曼定理</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<p>[TOC]</p>
<h2><span id="电路的基本概念和基本定律">电路的基本概念和基本定律</span></h2><h3><span id="1电路分析的基本变量">1.电路分析的基本变量</span></h3><h4><span id="1电流">（1）电流</span></h4><ul>
<li><input disabled type="checkbox"> <strong>电流</strong>：是电路中电荷流动量的度量，它代表单位时间流过电路中某一截面的净电荷量。</li>
<li><input disabled type="checkbox"> 习惯上把正电荷移动的方向规定为电流方向。</li>
<li><input disabled type="checkbox"> 1A &#x3D; 10³mA &#x3D; 10⁶μA</li>
<li><input disabled type="checkbox"> 恒定电流&#x2F;<strong>直流</strong>的大小和方向不随时间变化，用<strong>I</strong>表示；交变电流&#x2F;<strong>交流</strong>用<strong>i</strong>表示。</li>
<li><input disabled type="checkbox"> 如果电流的真实方向和参考方向一致，电流为正值。</li>
</ul>
<h4><span id="2电压">（2）电压</span></h4><ul>
<li><input disabled type="checkbox"> <strong>电压</strong>：电路中两点之间的电位差。(规定电位下降的方向为电压的真实方向)</li>
<li><input disabled type="checkbox"> <strong>电位</strong>：描述电路中电位能分布的物理量。如果正电荷由a点转移到b点时获得能量，则a点为低电位（负极），b点为高电位（正极）。</li>
<li><input disabled type="checkbox"> <strong>电压降</strong>：电压Uab表示单位正电荷从a点移动到b点所失去的电位能。</li>
<li><input disabled type="checkbox"> <strong>参考点</strong>：又叫“零电位点”，此处的电压为0，用<strong>⊥</strong>表示。</li>
<li><input disabled type="checkbox"> 符号：U</li>
<li><input disabled type="checkbox"> 单位：<strong>伏特（V）</strong></li>
</ul>
<p><img src="/2024/03/14/%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E7%AC%94%E8%AE%B0/26b97bbf08071e65df06f449d76d53a.png" alt="26b97bbf08071e65df06f449d76d53a"></p>
<h4><span id="3电功率">（3）电功率</span></h4><ul>
<li><input disabled type="checkbox"> <strong>电功率</strong>：是电路元件消耗电能快慢的度量，它表示单位时间内电路元件消耗的电场能量。</li>
<li><input disabled type="checkbox"> 符号：p或p(t)</li>
<li><input disabled type="checkbox"> 单位：<strong>瓦特（W）</strong></li>
<li><input disabled type="checkbox"> 公式：<strong>p&#x3D; dw&#x2F;dt &#x3D; ui; P&#x3D;UI;</strong>  (非关联参考方向：p&#x3D;-ui或P&#x3D;-UI)</li>
<li><input disabled type="checkbox"> <strong>功率平衡原理</strong>：电路中所有元件的功率之和为0（即能量守恒）。</li>
<li><input disabled type="checkbox"> 当p&gt;0，p是元件的吸收功率；p&lt;0，元件向外部电路提供功率。</li>
</ul>
<h4><span id="4电阻">（4）电阻</span></h4><ul>
<li><p><input disabled type="checkbox"> 
伏安特性：欧姆定律。</p>
</li>
<li><p><input disabled type="checkbox"> 
符号：R</p>
</li>
<li><p><input disabled type="checkbox"> 
单位：<strong>欧姆(Ω)</strong></p>
</li>
<li><p><input disabled type="checkbox"> 
“电阻值”公式：<strong>R &#x3D;U &#x2F; I</strong>（或R&#x3D;-U&#x2F;I）</p>
</li>
<li><p><input disabled type="checkbox"> 
“电阻元件功率”计算公式：<strong>PR &#x3D; U * I &#x3D; R * i2 &#x3D; U2 &#x2F; R</strong></p>
<p><img src="/2024/03/14/%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E7%AC%94%E8%AE%B0/d9bd6db9355927a8f2d38264806ee63.png" alt="d9bd6db9355927a8f2d38264806ee63"></p>
</li>
</ul>
<h4><span id="5电导">（5）电导</span></h4><ul>
<li><input disabled type="checkbox"> 符号：G</li>
<li><input disabled type="checkbox"> 公式：<strong>G&#x3D;1&#x2F;R，U&#x3D;1&#x2F;G，I&#x3D;GU</strong></li>
<li><input disabled type="checkbox"> 单位：<strong>西门子（S）</strong></li>
<li><input disabled type="checkbox"> 电阻元件可以用电导来表征。</li>
<li><input disabled type="checkbox"> G→0，R→∞</li>
</ul>
<h3><span id="2基尔霍夫定律">2.基尔霍夫定律</span></h3><h4><span id="1术语">（1）术语</span></h4><ul>
<li><input disabled type="checkbox"> 节点：两条或两条以上的连接点。</li>
<li><input disabled type="checkbox"> 回路：电路中任一闭合的路径。</li>
<li><input disabled type="checkbox"> 网孔：回路内部中不含支路的回路。</li>
<li><input disabled type="checkbox"> 网络：含元件较多的电路。</li>
</ul>
<h4><span id="2基尔霍夫电流定律kcl">（2）基尔霍夫电流定律（KCL）：</span></h4><p>在任意时刻流进<strong>任意一个结点</strong>的所有支路电流的代数和总是为零。</p>
<p>即：流出&#x3D;流入。</p>
<p>KCL是运用于电路中节点的，也可以将其推广运用到电路的一个封闭面。</p>
<h4><span id="3基尔霍夫电压定律kvl">（3）基尔霍夫电压定律（KVL）：</span></h4><p>在任意时刻绕<strong>任意一个回路</strong>一周所有支路电压的代数和总是为零。</p>
<p><img src="/2024/03/14/%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E7%AC%94%E8%AE%B0/895aa3a1c25920a4277fa7b3db697b3.png" alt="895aa3a1c25920a4277fa7b3db697b3"></p>
<h3><span id="3电路元件">3.电路元件</span></h3><p>电路元件是实际电器元件的理想化模型，是构成电路的基本单元。</p>
<p>从元件对能量的表现划分为：耗能元件（电阻元件），供能元件（独立电源），储能元件，能量控制元件。</p>
<h4><span id="1电阻元件">（1）电阻元件</span></h4><p>分为线性电阻和非线性电阻。</p>
<h4><span id="2供能元件">（2）供能元件</span></h4><p>①<strong>理想电压源</strong></p>
<ul>
<li><p><strong>理想电压源</strong>：二端元件两端电压不随流过它的电流变化，保持固定的数值&#x2F;变化规律。</p>
</li>
<li><p>“理想电压源”的<strong>伏安特性</strong>： 一条平行于电流轴的直线。</p>
</li>
<li><p>流过理想电压源的电流，是由与之相连接的外部电路来决定的。</p>
</li>
</ul>
<p><img src="/2024/03/14/%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E7%AC%94%E8%AE%B0/cc334c63dede1974a4ab95262f2535d.png" alt="cc334c63dede1974a4ab95262f2535d"></p>
<p>②<strong>理想电流源</strong></p>
<ul>
<li><strong>理想电流源</strong>：二端元件两端电源不随流过它的电压变化，保持固定的数值&#x2F;变化规律。</li>
<li>“理想电流源”的<strong>伏安特性</strong>： 一条平行于电压轴的直线。</li>
<li>理想电流源的端电压，是由与之相连接的外部电路决定的。</li>
</ul>
<p><img src="/2024/03/14/%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E7%AC%94%E8%AE%B0/b2940520b48402f779fb7a04f351340.png" alt="b2940520b48402f779fb7a04f351340"></p>
<h4><span id="3电容元件例题p19-p20">（3）电容元件（例题p19、p20）</span></h4><ul>
<li><input disabled type="checkbox"> 电容器是一种能储存电场能量的部件。</li>
<li><input disabled type="checkbox"> <strong>电容元件</strong>：指存储在极板上的“电荷量 q ”与两极板之间的“电压 u ”的代数关系。</li>
<li><input disabled type="checkbox"> 符号：<strong>C（电容量）</strong></li>
<li><input disabled type="checkbox"> 单位：<strong>法拉（F）</strong></li>
<li><input disabled type="checkbox"> 公式：<strong>1F &#x3D; 1C &#x2F; 1V</strong>，**<u>i(t)&#x3D;C<em>du(t)&#x2F;dt</em></u><strong>，</strong>w&#x3D;1&#x2F;2C<em>u²(t)</em></li>
<li><input disabled type="checkbox"> 电容器两端的电压不可能发生跃变（电流→∞）而只能是连续变化的。电容器C在某一时刻的储能只取决于该时刻的电容电压值。</li>
</ul>
<p><img src="/2024/03/14/%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E7%AC%94%E8%AE%B0/2a28d4d268fadbec868ec19c0631fa2.png" alt="2a28d4d268fadbec868ec19c0631fa2"></p>
<ul>
<li><input disabled type="checkbox"> 两电容器的并联：等效电容量&#x3D;两电容量之和。C&#x3D;C1+C2。</li>
</ul>
<p>相当于电容极板面积增大。</p>
<ul>
<li><input disabled type="checkbox"> 两电容器的串联：两电容倒数之和&#x3D;等效电容量的倒数。1&#x2F;C&#x3D;1&#x2F;C1 + 1&#x2F;C2 。</li>
</ul>
<h4><span id="4电感元件例题p23">（4）电感元件（例题p23）</span></h4><ul>
<li><input disabled type="checkbox"> <strong>电感</strong>：流过线圈的“磁通量”与流过线圈的“电流 i ”的代数关系。</li>
<li><input disabled type="checkbox"> 电感元件的原型：空心线圈。</li>
<li><input disabled type="checkbox"> 符号：<strong>L（电感量）</strong></li>
<li><input disabled type="checkbox"> 单位：<strong>亨利（H）</strong></li>
<li><input disabled type="checkbox"> 公式：**<u>u&#x3D;L*di&#x2F;dt</u><strong>（i对t求导），</strong>wL&#x3D;1&#x2F;2Li²(t)**</li>
</ul>
<p><img src="/2024/03/14/%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E7%AC%94%E8%AE%B0/d86662a10020fea5a2b57a231223f5e.png" alt="d86662a10020fea5a2b57a231223f5e"></p>
<ul>
<li><input disabled type="checkbox"> 电感的串联：等效电感量&#x3D;两电感之和。L&#x3D;L1+L2。</li>
</ul>
<p>相当于线圈的匝数增多。</p>
<ul>
<li><input disabled type="checkbox"> 电感的并联：两电感倒数之和&#x3D;等效电感量的倒数。L&#x3D;1&#x2F;L1 + 1&#x2F;L2。</li>
<li><input disabled type="checkbox"> 电感中电流不能发生跃变。</li>
</ul>
<p><img src="/2024/03/14/%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E7%AC%94%E8%AE%B0/69732c59464c97ef9824e0b9011a78f.png" alt="69732c59464c97ef9824e0b9011a78f"></p>
<h4><span id="5控能元件受控电源">（5）控能元件——受控电源</span></h4><p>①VCVS：电压控制电压源</p>
<p>②CCVS：电流控制电压源</p>
<p>③VCCS：电压控制电流源</p>
<p>④CCCS：电流控制电流源</p>
<p><img src="/2024/03/14/%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E7%AC%94%E8%AE%B0/14e0a9a236d237b6ec38351e0eded56.png" alt="14e0a9a236d237b6ec38351e0eded56"></p>
<p>理想：对<strong>受控电压源</strong>来说，其输出电阻为0；对<strong>受控电流源</strong>来说，其输出电阻为无限大。对<strong>电压控制的受控源</strong>来说，其输入电阻为无限大；对<strong>电流控制的受控源</strong>来说，其输入电阻为0。</p>
<p><u>在电路分析时，受控源可看作独立电源，然后进行电源的等效变换。</u></p>
<p><img src="/2024/03/14/%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E7%AC%94%E8%AE%B0/bcc8038ff63ca6cb7d0fee91f5653a7.png" alt="bcc8038ff63ca6cb7d0fee91f5653a7"></p>
<h2><span id="电阻电路的一般分析方法">电阻电路的一般分析方法</span></h2><h3><span id="等效电路分析法">等效电路分析法</span></h3><h4><span id="1电源模型的等效互换">1.电源模型的等效互换</span></h4><p>电源等效互换的依据是电源的外特性相同。</p>
<p><img src="/2024/03/14/%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E7%AC%94%E8%AE%B0/132db370bc2f286ff83b54d52a9a3b2.png" alt="132db370bc2f286ff83b54d52a9a3b2"></p>
<p>（1）<strong>等效电路</strong>：两个电路具有完全相同的“对外连接端”，两者分别和任意其他的电路成分构成完整电路，如果电路的其它部分工作完全一致，则这两个电路互为<strong>等效电路</strong>。</p>
<p>（2）电路外特性：电路外接端上的电压与电流之间的关系。每个元件可视为一个电路部分，它的特性即是<strong>外特性</strong>。</p>
<p>电路中的一部分用其等效电路替换后，电路其它部分的工作情况保持不变；等效只能适合用于外部，对于互相等效的两个电路内部工作一般是不等效的。</p>
<h4><span id="2电阻的串联和并联">2.电阻的串联和并联</span></h4><p>（1）<strong>串联</strong></p>
<ul>
<li><strong>“电阻串联”等效为“单个电阻元件”</strong>；</li>
<li>两个电阻串联的等效条件：<strong>R &#x3D; R1 + R2</strong>；</li>
</ul>
<p><img src="/2024/03/14/%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E7%AC%94%E8%AE%B0/59e11257ee94fbad7830734dc0360eb.png" alt="59e11257ee94fbad7830734dc0360eb"></p>
<p>（2）<strong>并联</strong></p>
<ul>
<li><strong>“电阻并联”也等效为“单个电阻元件”</strong>；</li>
<li>两个电阻并联的等效条件： <strong>G &#x3D; G1 + G2</strong> 或 <strong>R &#x3D; R1 * R2 &#x2F; R1 + R2</strong></li>
</ul>
<p><img src="/2024/03/14/%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E7%AC%94%E8%AE%B0/961340a8100133f28d58f7f3c92b046.png" alt="961340a8100133f28d58f7f3c92b046"></p>
<p>3.电阻的混联及Y-Δ等效变换</p>
<p><img src="/2024/03/14/%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E7%AC%94%E8%AE%B0/4444eafb8d5297a15e32c3fe4f04a1d.png" alt="4444eafb8d5297a15e32c3fe4f04a1d"></p>
<p><img src="/2024/03/14/%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E7%AC%94%E8%AE%B0/7c514345062324cc216b14a44f06b06.png" alt="7c514345062324cc216b14a44f06b06"></p>
<h3><span id="网孔分析法例题p39">网孔分析法（例题p39)</span></h3><ul>
<li>对支路电流法所列的方程中做如下处理，可得到网孔方程：<br>1）对每个网孔按顺时针方向设定一个网孔电流；<br>2）将各支路电流表示成网孔电流的叠加。</li>
<li>将含源支路转化为电压源U与电阻R串联的形式。</li>
<li>自电阻总是正的，而互电阻既可为正也可为负，取决于流过互电阻的两个网孔电流是否一致，一致时取正。</li>
</ul>
<p><img src="/2024/03/14/%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E7%AC%94%E8%AE%B0/e1ca0f90aaf322d807af84bad6afa0f.png" alt="e1ca0f90aaf322d807af84bad6afa0f"></p>
<h3><span id="节点分析法">节点分析法</span></h3><ul>
<li>选取参考节点如4，则节点4的电位为0，其他3个节点分别对参考节点的电位是U1，U2，U3，即为节点电位。</li>
<li>将含源支路转化为电流源I与电导G并联的形式。</li>
</ul>
<p><img src="/2024/03/14/%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E7%AC%94%E8%AE%B0/e11d4d54a9561856fb79a5ce741c6f9.png" alt="e11d4d54a9561856fb79a5ce741c6f9"></p>
<p><strong>总结：</strong>①网络的独立节点数少于网孔数，用节点分析法。</p>
<p>②已知的电源是电流源，用节点分析法；电源是电压源，用网孔分析法。</p>
<p>③网孔分析法只适合平面网络。</p>
<h3><span id="弥尔曼定理">弥尔曼定理</span></h3><p><img src="/2024/03/14/%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E7%AC%94%E8%AE%B0/55339e45bbf28eac69264f6abd4248b.png" alt="55339e45bbf28eac69264f6abd4248b"></p>
]]></content>
      <categories>
        <category>课堂笔记</category>
      </categories>
      <tags>
        <tag>电子电路基础</tag>
      </tags>
  </entry>
  <entry>
    <title>高等数学下笔记</title>
    <url>/2024/03/25/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#8-%E5%90%91%E9%87%8F%E4%BB%A3%E6%95%B0%E4%B8%8E%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95">8 - 向量代数与空间解析几何</a><ul>
<li><a href="#8-1-%E5%90%91%E9%87%8F%E5%8F%8A%E5%85%B6%E7%BA%BF%E6%80%A7%E8%BF%90%E7%AE%97">8-1 向量及其线性运算</a></li>
<li><a href="#8-2-%E7%A9%BA%E9%97%B4%E7%9B%B4%E8%A7%92%E5%9D%90%E6%A0%87%E7%B3%BB">8-2 空间直角坐标系</a></li>
<li><a href="#8-3-%E5%90%91%E9%87%8F%E7%9A%84%E7%BB%BC%E5%90%88%E6%80%A7%E8%B4%A8%E5%92%8C%E8%BF%90%E7%AE%97">8-3 向量的综合性质和运算</a></li>
<li><a href="#8-4-%E6%95%B0%E9%87%8F%E7%A7%AF-%E5%90%91%E9%87%8F%E7%A7%AF">8-4 数量积、向量积</a></li>
<li><a href="#8-5-%E5%B9%B3%E9%9D%A2%E5%8F%8A%E5%85%B6%E6%96%B9%E7%A8%8B">8-5 平面及其方程</a></li>
<li><a href="#8-6-%E7%A9%BA%E9%97%B4%E7%9B%B4%E7%BA%BF%E5%8F%8A%E5%85%B6%E6%96%B9%E7%A8%8B">8-6 空间直线及其方程</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<p>[TOC]</p>
<h2><span id="8-向量代数与空间解析几何">8 - 向量代数与空间解析几何</span></h2><h3><span id="8-1-向量及其线性运算">8-1 向量及其线性运算</span></h3><p>1.由三角形两边之和大于第三边，有：|<strong>a</strong> + <strong>b</strong>|&lt;&#x3D;|<strong>a</strong>|+|<strong>b</strong>|; |<strong>a</strong> - <strong>b</strong>|&lt;&#x3D;|<strong>a</strong>|+|<strong>b</strong>|</p>
<p>2.数乘：|λ<strong>a</strong>| &#x3D; |λ||<strong>a</strong>|</p>
<p>3.单位向量<strong>e</strong>&#x3D;<strong>a</strong>&#x2F;|<strong>a</strong>|</p>
<p>4.<strong>a</strong>&#x2F;&#x2F;<strong>b</strong>等价于<strong>b</strong>&#x3D;λ<strong>a</strong>（<strong>a</strong>!&#x3D;0）</p>
<h3><span id="8-2-空间直角坐标系">8-2 空间直角坐标系</span></h3><img src="/2024/03/25/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8B%E7%AC%94%E8%AE%B0/be8b438d8dab4f26425537c8e52ffa4.png" alt="be8b438d8dab4f26425537c8e52ffa4" style="zoom:80%;">

<img src="/2024/03/25/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8B%E7%AC%94%E8%AE%B0/ed720f4486e49cb4f94f47c876630bf.png" alt="ed720f4486e49cb4f94f47c876630bf" style="zoom:80%;">

<p>向量OF（x，y，z）是点O关于点F的向径，<u>求点F的坐标就是求向量OP的坐标</u></p>
<p>①若点F在yoz面上，x&#x3D;0；</p>
<p>②点F在zox面上，y&#x3D;0；点F在xoy面上，z&#x3D;0；</p>
<p>③点F在x轴上，y&#x3D;z&#x3D;0；</p>
<p>④点F在y轴上，z&#x3D;x&#x3D;0；点F在z轴上，x&#x3D;y&#x3D;0；</p>
<p>⑤点F为原点，x&#x3D;y&#x3D;z&#x3D;0。</p>
<h3><span id="8-3-向量的综合性质和运算">8-3 向量的综合性质和运算</span></h3><img src="/2024/03/25/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8B%E7%AC%94%E8%AE%B0/微信截图_20240326011004.png" alt="微信截图_20240326011004" style="zoom:80%;">

<h4><span id="题型"><strong>题型：</strong></span></h4><h5><span id="1向量模的坐标表达式">1.向量模的坐标表达式</span></h5><h5><span id="2两点距离公式">2.两点距离公式：</span></h5><p>求证三角形的类型（等腰、直角、等边）</p>
<p>求已知向量的定向单位向量</p>
<p>求与某几点等距离的点</p>
<h5><span id="3方向角与方向余弦">3.方向角与方向余弦：</span></h5><p>已知角度求点的坐标</p>
<p>已知向量求方向角、余弦和模</p>
<h5><span id="4投影">4.投影</span></h5><p>已知向量求向量在某轴上的投影</p>
<p>已知投影求向量</p>
<h3><span id="8-4-数量积-向量积">8-4 数量积、向量积</span></h3><img src="/2024/03/25/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8B%E7%AC%94%E8%AE%B0/微信截图_20240326013200.png" alt="微信截图_20240326013200" style="zoom:80%;">

<h4><span id="题型"><strong>题型</strong>：</span></h4><p>1.用数量积公式求夹角、投影</p>
<p>2.用向量积求三角形面积（用到正弦）</p>
<p>3.用数量积、向量积定义证垂直或平行</p>
<p>4.（多用）用向量积求平面方程</p>
<h3><span id="8-5-平面及其方程">8-5 平面及其方程</span></h3><h4><span id="1平面的点法式方程">1.平面的点法式方程</span></h4><p><strong>A（x-x₀）+B（y-y₀）+C（z-z₀）&#x3D;0</strong></p>
<p>其中<strong>n</strong>&#x3D;（A,B,C），M₀&#x3D;（x₀，y₀，z₀）</p>
<h4><span id="2平面的一般方程">2.平面的一般方程</span></h4><p><strong>Ax0 + By0 + Cz0 +D&#x3D;0</strong></p>
<p><strong>n</strong>&#x3D;（A,B,C）</p>
<p>①<strong>D&#x3D;0</strong>时，方程表示一个通过<strong>原点</strong>的平面</p>
<p>②<strong>A&#x3D;0</strong>时，<strong>n</strong>垂直于x轴，方程表示一个平行于（或包含）<strong>x轴</strong>的平面；<strong>B&#x3D;0，C&#x3D;0</strong>同理</p>
<p>③<strong>A&#x3D;B&#x3D;0</strong>，<strong>n</strong>同时垂直x轴和y轴，方程表示一个平行于（或重合）<strong>x0y面</strong>的平面；<strong>A&#x3D;C&#x3D;0,B&#x3D;C&#x3D;0</strong>同理</p>
<h4><span id="3平面的截距式方程">3.平面的截距式方程</span></h4><p><strong>x&#x2F;a + y&#x2F;b + z&#x2F;c &#x3D; 1</strong></p>
<p>a、b、c分别是平面在xyz轴上的截距</p>
<h4><span id="4两平面夹角-点到平面距离">4.两平面夹角、点到平面距离</span></h4><p><strong>两平面互相垂直</strong>相当于<strong>A₁A₂ + B₁B₂ + C₁C₂ &#x3D; 0</strong></p>
<p><strong>两平面互相平行或重合</strong>相当于<strong>A₁&#x2F;A₂ &#x3D; B₁&#x2F;B₂ &#x3D; C₁&#x2F;C₂</strong></p>
<img src="/2024/03/25/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8B%E7%AC%94%E8%AE%B0/微信截图_20240326015143.png" alt="微信截图_20240326015143" style="zoom:80%;">



<h3><span id="8-6-空间直线及其方程">8-6 空间直线及其方程</span></h3><h4><span id="1直线的点向式方程对称式方程">1.直线的点向式方程（对称式方程）</span></h4><p>其中，<strong>s</strong>&#x3D;(m,n,p)，M₀&#x3D;(x₀,y₀,z₀)</p>
<p>要素：①方向向量 ②点</p>
<h4><span id="2直线的参数方程">2.直线的参数方程</span></h4><h4><span id="3直线的一般方程">3.直线的一般方程</span></h4><p>表现为两个平面的交线</p>
<h4><span id="4线面角">4.线面角</span></h4><p>范围是【0，90°】</p>
<img src="/2024/03/25/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8B%E7%AC%94%E8%AE%B0/微信截图_20240326015259.png" alt="微信截图_20240326015259" style="zoom:80%;">

<h4><span id="5线线角">5.线线角</span></h4><p>和面面角公式相同，用cos</p>
<h4><span id="6性质">6.性质</span></h4><p><strong>两直线相互垂直（包括异面、相交）</strong>相当于 <strong>m₁m₂ + n₁n₂ + p₁p₂ &#x3D; 0</strong></p>
<p><strong>两直线互相平行或重合</strong> 相当于 <strong>m₁&#x2F;m₂ &#x3D; n₁&#x2F;n₂ &#x3D; p₁&#x2F;p₂</strong></p>
<p><strong>直线与平面平行或直线在平面上</strong> 相当于 <strong>Am + Bn + Cp &#x3D;0</strong></p>
]]></content>
      <tags>
        <tag>高等数学</tag>
      </tags>
  </entry>
  <entry>
    <title>tag</title>
    <url>/tag/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
