<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2024/03/11/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2><span id="quick-start">Quick Start</span></h2><h3><span id="create-a-new-post">Create a new post</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3><span id="run-server">Run server</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3><span id="generate-static-files">Generate static files</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3><span id="deploy-to-remote-sites">Deploy to remote sites</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>《图解密码技术》 读书笔记</title>
    <url>/2024/04/17/%E3%80%8A%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF%E3%80%8B-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2><span id="基础概念">基础概念</span></h2><h3><span id="1-1-基本名词解释">1-1 基本名词解释</span></h3><p>1.密钥（key）：加密和解密所需的媒介。</p>
<p>2.对称密码：在加密和解密时使用同一密钥的解密方式。</p>
<p>3.公钥密码：在加密和解密时使用不同密钥的解密方式。又叫非对称密码。</p>
<p>4.混合密码系统：结合了对称密码和非对称密码的优势。</p>
<p>5.单向散列函数：是一种保证完整性的密码技术。</p>
<p>为了防止软件被篡改，一些发布者会在发布软件的同时发布该软件的散列值，下载该软件的人自行下载散列值，如果后者与前者的值相等，说明下载的软件是正版的。</p>
<p>6.消息认证码：是一种能够保证完整性和提供认证的密码技术。</p>
<p>为了确认消息是否来自所期望的通信对象，可以使用消息认证码。</p>
<p>7.数字签名：</p>
<p>（1）伪装：第三方伪造发送者的身份传达消息。</p>
<p>（2）篡改：消息在传输的过程中遭到第三方修改。</p>
<p>（3）否认：发送者在事后推翻自己先前的主张。</p>
<p>防止伪装、篡改、否认等威胁的技术，就是数字签名。</p>
<p>8.伪随机数生成器</p>
<p>9.隐写术：密码隐藏的是内容，而隐写术隐藏的是消息本身</p>
<h2><span id="历史密码">历史密码</span></h2><h3><span id="2-1凯撒密码">2-1凯撒密码</span></h3><h4><span id="1概念">1.概念</span></h4><p>通过将明文中所使用的字母表按照一定的字数”平移“来进行加密的密码。</p>
<p>如A→F，B→G</p>
<p>在此例中，密钥为5</p>
<h4><span id="2解密">2.解密</span></h4><p>将所有可能的密钥全部尝试一遍，这种方法称为<strong>暴力破解</strong>。由于这种方法的本质是从所有的密钥中找出正确的密钥，因此又称为<strong>穷举搜索</strong>。</p>
<h3><span id="2-2简单替换密码">2-2简单替换密码</span></h3><h4><span id="1概念">1.概念</span></h4><p>将明文中所使用的字母表替换为另一套字母表的密码。</p>
<h4><span id="2加密">2.加密</span></h4><p>依次将明文中的每一个字母按照替换表替换成另一个字母。</p>
<p>如A→B，B→Z</p>
<h4><span id="3解密">3.解密</span></h4><p>简单替换密码很难通过暴力破解来破译。</p>
<p>一种密码能够使用的所有密钥的集合称为密钥空间。</p>
<p>密钥空间越大，暴力破解越困难。</p>
<p>计算：n!(n是密码所用到的字符的种类)</p>
<p><strong>频率分析法</strong></p>
<p>①明文中的字母的出现频率&#x3D;密文中的字母的出现频率</p>
<p>②除了高频字母以外，低频字母也能够成为线索</p>
<p>③搞清开头和结尾能够成为线索，搞清单词之间的分隔也能成为线索</p>
<p>④密文越长越容易破译</p>
<p>⑤同一个字母连续出现能够成为线索（这是因为在简单替换密码中，某个字母在替换表中所对应的另一个字母是固定的）</p>
]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>unity 控制角色移动</title>
    <url>/2024/03/19/unity-%E6%8E%A7%E5%88%B6%E8%A7%92%E8%89%B2%E7%A7%BB%E5%8A%A8/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line">//控制角色移动、生命、动画等</span><br><span class="line">public class NewBehaviourScript : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    public float speed = 5f;//移动速度</span><br><span class="line">    // Start is called before the first frame update</span><br><span class="line">    void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Update is called once per frame</span><br><span class="line">void Update()</span><br><span class="line">&#123;</span><br><span class="line">    float moveX = Input.GetAxisRaw(&quot;Horizontal&quot;);//控制水平方向移动，A：-1，D：1,0</span><br><span class="line">    float moveY = Input.GetAxisRaw(&quot;Vertical&quot;);//控制垂直方向W1 S-1 0</span><br><span class="line"></span><br><span class="line">    Vector2 position = transform.position;</span><br><span class="line">    position.x +=moveX * speed * Time.deltaTime;</span><br><span class="line">    position.y +=moveY * speed * Time.deltaTime;</span><br><span class="line">    transform.position = position;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>unity2d</tag>
      </tags>
  </entry>
  <entry>
    <title>上标、下标的字符显示</title>
    <url>/2024/04/02/%E4%B8%8A%E6%A0%87%E3%80%81%E4%B8%8B%E6%A0%87%E7%9A%84%E5%AD%97%E7%AC%A6%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<h3><span id></span></h3><h3><span id="一-上标">一、上标</span></h3><h4><span id="1数字">1.数字</span></h4><p>¹²³⁴⁵⁶⁷⁸⁹⁰⁺⁻⁼˂˃⁽⁾˙*′˙ⁿº</p>
<h4><span id="2字母">2.字母</span></h4><p>ᵃᵇᶜᵈᵉᶠᵍʰⁱʲᵏˡᵐⁿᵒᵖʳˢᵗᵘᵛʷˣʸᶻ</p>
<p>ᴬᴮᒼᴰᴱᶠᴳᴴᴵᴶᴷᴸᴹᴺᴼᴾᴼ̴ᴿˢᵀᵁⱽᵂˣᵞᙆ</p>
<h4><span id="3其他">3.其他</span></h4><p>ᵃ ᵇ ᶜ ᵈ ᵉ ᵍ ʰ ⁱ ʲ ᵏ ˡ ᵐ ⁿ ᵒ ᵖ ᵒ⃒ ʳ ˢ ᵗ ᵘ ᵛ ʷ ˣ ʸ ᙆ ᴬ ᴮ ᒼ ᴰ ᴱ ᴳ ᴴ ᴵ ᴶ ᴷ ᴸ ᴹ ᴺ ᴼ ᴾ ᴼ̴ ᴿ ˢ ᵀ ᵁ ᵂ ˣ ᵞ ᙆ ꝰ ˀ ˁ ˤ ꟸ ꭜ ʱ ꭝ ꭞ ʴ ʵ ʶ ꭟ ˠ ꟹ ᴭ ᴯ ᴲ ᴻ ᴽ ᵄ ᵅ ᵆ ᵊ ᵋ ᵌ ᵑ ᵓ ᵚ ᵝ ᵞ ᵟ ᵠ ᵡ ᵎ ᵔ ᵕ ᵙ ᵜ ᶛ ᶜ ᶝ ᶞ ᶟ ᶡ ᶣ ᶤ ᶥ ᶦ ᶧ ᶨ ᶩ ᶪ ᶫ ᶬ ᶭ ᶮ ᶯ ᶰ ᶱ ᶲ ᶳ ᶴ ᶵ ᶶ ᶷ ᶸ ᶹ ᶺ ᶼ ᶽ ᶾ ᶿ ꚜ ꚝ ჼ ᒃ ᕻ ᑦ ᒄ ᕪ ᑋ ᑊ ᔿ ᐢ ᣕ ᐤ ᣖ ᣴ ᣗ ᔆ ᙚ ᐡ ᘁ ᐜ ᕽ ᙆ ᙇ ᒼ ᣳ ᒢ ᒻ ᔿ ᐤ ᣖ ᣵ ᙚ ᐪ ᓑ ᘁ ᐜ ᕽ ᙆ ᙇ </p>
<h3><span id="二-下标">二、下标</span></h3><h4><span id="1数字">1.数字</span></h4><p>₀ ₁ ₂ ₃ ₄ ₅ ₆ ₇ ₈ ₉ ₊ ₋ ₌ ₍ ₎ ₐ ₑ ₒ ₓ ₔ ₕ ₖ ₗ ₘ ₙ ₚ ₛ ₜ</p>
<h4><span id="2字母">2.字母</span></h4><p>ₐ ₔ ₑ ₕ ᵢ ⱼ ₖ ₗ ₘ ₙ ₒ ₚ ᵣ ₛ ₜ ᵤ ᵥ ₓ ᙮ ᵤ ᵩ ᵦ ₗ ˪ ៳ ៷ ₒ ᵨ ₛ ៴ ᵤ ᵪ ᵧ</p>
]]></content>
      <tags>
        <tag>素材</tag>
      </tags>
  </entry>
  <entry>
    <title>半导体器件的基本特性</title>
    <url>/2024/04/23/%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%99%A8%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h2><span id="半导体">半导体</span></h2><p>根据导电性能，物质分为：导体、绝缘体和半导体。</p>
<p>物质的导电特性取决于物质的原子结构。</p>
<p>常见的半导体：硅（Si）、锗（Ge），四价元素。</p>
<h3><span id="1本征半导体">1.<strong>本征半导体</strong></span></h3><ul>
<li>完全纯净的、结构完整的半导体。</li>
<li>在本征半导体中，自由电子和空穴<strong>成对产生，浓度相等</strong>。</li>
</ul>
<h3><span id="2n型半导体">2.N型半导体</span></h3><ul>
<li>在本侦半导体中加入“<strong>五价元素</strong>”。</li>
<li>靠自由电子导电。</li>
<li>对外呈<strong>电中性</strong>。</li>
<li>N型半导体中含有<strong>较高</strong>的自由电子浓度，<strong>自由电子</strong>是<strong>多数载流子（多子）</strong>，空穴浓度较低，是少数载流子（少子）。</li>
<li>多数载流子浓度越高，导电性能越强。</li>
</ul>
<h3><span id="3p型半导体">3.P型半导体</span></h3><ul>
<li>在本征半导体中掺入“<strong>三价元素</strong>”。</li>
<li>对外呈<strong>电中性</strong>。</li>
<li><strong>空穴</strong>为<strong>多数载流子</strong>，而自由电子为少数载流子。</li>
</ul>
<h3><span id="4载流子的运动">4.载流子的运动</span></h3><ul>
<li><strong>漂移运动</strong>： 在<strong>电场</strong>的作用下，载流子的运动称为“漂移运动”，由漂移运动产生的电流为<strong>漂移电流</strong>。</li>
<li><strong>扩散运动</strong>：由于<strong>浓度差</strong>引起的载流子运动称为“扩散运动”，产生的相应电流为<strong>扩散电流</strong>。</li>
<li>漂移运动与扩散运动相反。</li>
<li>漂移运动作用和扩散运动作用相等。</li>
</ul>
<h2><span id="pn结">PN结</span></h2><h3><span id="1形成">1.形成</span></h3><ul>
<li>扩散越多，电场越强，漂移运动越强，对扩散的阻力越大，从而达到<strong>动态平衡</strong>，形成PN结。</li>
<li>PN结的电流为0。</li>
<li>PN区交界处有一个缺少载流子的高阻区，称为<strong>阻挡区</strong>，又叫耗尽区。</li>
</ul>
<p><img src="/2024/04/23/%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%99%A8%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7/20200622205628795.jpg" alt="20200622205628795"></p>
<h3><span id="2单向导电特性">2.单向导电特性</span></h3><h4><span id="1pn结外加正向电压导通">（1）PN结外加正向电压（导通）</span></h4><ul>
<li>**正向偏置：P+N-**。</li>
<li>扩散运动增加，漂流运动减弱，多数载流子向对方区扩散形成<strong>较大的正向电流</strong>。</li>
<li>PN结<strong>导通</strong>。</li>
<li>形成的电阻为正向电阻，阻值很小。</li>
<li><strong>正向电压越大，正向电流越大</strong>。</li>
</ul>
<p><img src="/2024/04/23/%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%99%A8%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7/20200622212041521.jpg" alt="20200622212041521"></p>
<h4><span id="2pn结外加反向电压截止">（2）PN结外加反向电压（截止）</span></h4><ul>
<li>**反向偏置：N+P-**。</li>
<li>漂流作用大于扩散作用，少数载流子做漂移运动，称反向电流。</li>
<li><strong>反向电流很小</strong>。</li>
<li>反向电压再增加，反向电流也不会增加，I&#x3D;-Iₛ。</li>
<li><strong>呈现的电阻为反向电阻，阻值很大</strong>。</li>
</ul>
<p><img src="/2024/04/23/%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%99%A8%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7/20200622211350136.jpg" alt="20200622211350136"></p>
<h4><span id="3伏安特性">（3）伏安特性</span></h4><p>当反向电压超过一定数值（反向击穿电压Uᵦ）后，反向电流会突然<strong>急剧增加</strong>，称为<strong>反向击穿</strong>。</p>
<p><img src="/2024/04/23/%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%99%A8%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7/R-C.png" alt="R-C"></p>
]]></content>
      <tags>
        <tag>电子电路基础</tag>
      </tags>
  </entry>
  <entry>
    <title>stack容器基本知识</title>
    <url>/2024/04/03/stack%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>写作业的时候看到有人用stack容器做题，试了下效率起飞，二话不说记录一下XD</p>
<!-- toc -->

<ul>
<li><a href="#1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">1.基础知识</a><ul>
<li><a href="#%E5%A4%B4%E6%96%87%E4%BB%B6"><strong>头文件</strong></a></li>
<li><a href="#%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><strong>常用操作</strong></a></li>
<li><a href="#stack%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0">stack对象的默认构造</a></li>
<li><a href="#stack%E7%9A%84%E5%87%BA%E6%A0%88%E5%92%8C%E8%BF%9B%E6%A0%88">stack的出栈和进栈</a></li>
<li><a href="#stack%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E4%B8%8E%E8%B5%8B%E5%80%BC">stack的拷贝构造与赋值</a></li>
<li><a href="#stack%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96">stack的数据存取</a></li>
<li><a href="#stack%E7%9A%84%E5%A4%A7%E5%B0%8F">stack的大小</a></li>
</ul>
</li>
<li><a href="#2%E4%BE%8B%E9%A2%98">2.例题</a><ul>
<li><a href="#7-2-%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D"><strong>7-2 括号匹配</strong></a></li>
<li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">代码实现</a></li>
<li><a href="#7-3-%E5%9B%9E%E6%96%87%E5%88%A4%E6%96%AD"><strong>7-3 回文判断</strong></a></li>
<li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1">代码实现</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<p>[TOC]</p>
<h2><span id="1基础知识">1.基础知识</span></h2><h3><span id="头文件"><strong>头文件</strong></span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stack&gt;</span><br></pre></td></tr></table></figure>



<h3><span id="常用操作"><strong>常用操作</strong></span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stack&lt;int&gt; q;	//以int型为例</span><br><span class="line">int x;</span><br><span class="line">q.push(x);		//将x压入栈顶</span><br><span class="line">q.top();		//返回栈顶的元素</span><br><span class="line">q.pop();		//删除栈顶的元素</span><br><span class="line">q.size();		//返回栈中元素的个数</span><br><span class="line">q.empty();		//检查栈是否为空,若为空返回true,否则返回false</span><br></pre></td></tr></table></figure>

<h3><span id="stack对象的默认构造">stack对象的默认构造</span></h3><p>stack对象的默认构造形式： stack <t> stkT;  </t></p>
<p>尖括号里面还可以设置指针或者其他数据类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stack &lt;int&gt; stkInt;            //一个存放int的stack容器。</span><br><span class="line"></span><br><span class="line">stack &lt;float&gt; stkFloat;     //一个存放float的stack容器。</span><br><span class="line"></span><br><span class="line">stack &lt;string&gt; stkString;     //一个存放string的stack容器。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3><span id="stack的出栈和进栈">stack的出栈和进栈</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stack.push(elem);            //往栈头添加元素</span><br><span class="line"></span><br><span class="line">stack.pop();                     //往栈头移除第一个元素</span><br></pre></td></tr></table></figure>

<h3><span id="stack的拷贝构造与赋值">stack的拷贝构造与赋值</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stack(const stack &amp;stk);                  //拷贝构造函数</span><br><span class="line"></span><br><span class="line">stack&amp; operator = (const stack &amp;stk);          //重载等号操作符</span><br><span class="line"></span><br><span class="line">stack&lt;int&gt;stkIntB(stkIntA);            //拷贝构造</span><br><span class="line">stack&lt;int&gt;stkIntC;</span><br><span class="line">stkIntC = stkIntA;                     //赋值</span><br></pre></td></tr></table></figure>

<h3><span id="stack的数据存取">stack的数据存取</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stack.top();     //返回最后一个压入栈元素</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stack&lt;int&gt; stkIntA;</span><br><span class="line"></span><br><span class="line">stkIntA.push(1);</span><br><span class="line"></span><br><span class="line">stkIntA.push(3);</span><br><span class="line"></span><br><span class="line">stkIntA.push(5);</span><br><span class="line"></span><br><span class="line">stkIntA.push(7);</span><br><span class="line"></span><br><span class="line">stkIntA.push(9);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">int iTop = stkIntA.top(); //9</span><br><span class="line"></span><br><span class="line">stkIntA.top() = 19; //19</span><br></pre></td></tr></table></figure>

<h3><span id="stack的大小">stack的大小</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stack.empty();                    //判断堆栈是否为空</span><br><span class="line"></span><br><span class="line">stack.size();                        //返回堆栈的大小</span><br></pre></td></tr></table></figure>



<h2><span id="2例题">2.例题</span></h2><h3><span id="7-2-括号匹配"><strong>7-2 括号匹配</strong></span></h3><p>给定一串字符，不超过100个字符，可能包括括号、数字、字母、标点符号、空格，编程检查这一串字符中的( ) ,[ ],{ }是否匹配。</p>
<p><strong>输入格式:</strong></p>
<p>输入在一行中给出一行字符串，不超过100个字符，可能包括括号、数字、字母、标点符号、空格。</p>
<p><strong>输出格式:</strong></p>
<p>如果括号配对，输出yes，否则输出no。</p>
<p><strong>输入样例1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sin(10+20)</span><br></pre></td></tr></table></figure>

<p><strong>输出样例1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yes</span><br></pre></td></tr></table></figure>

<p><strong>输入样例2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;[&#125;]</span><br></pre></td></tr></table></figure>

<p><strong>输出样例2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">no</span><br></pre></td></tr></table></figure>

<p><strong>输入样例3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(()())</span><br></pre></td></tr></table></figure>

<p><strong>输出样例3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yes</span><br></pre></td></tr></table></figure>

<h3><span id="代码实现">代码实现</span></h3><p>c&#x2F;c++ strlen(str)和str.length()和str.size()都可以求字符串长度。<br>其中**str.length()<strong>和</strong>str.size()**是用于求string类对象的成员函数<br>**strlen(str)*<em>是用于求字符数组的长度，其参数是char</em>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include&lt;stack&gt; //stack头文件</span><br><span class="line">int judge(string s)&#123;</span><br><span class="line">    stack&lt;char&gt;stk;//设置一个存放char的stack容器</span><br><span class="line">    for(int i=0;i&lt;s.length();i++)&#123;</span><br><span class="line">        switch(s[i])&#123;</span><br><span class="line">                case&#x27;(&#x27;:</span><br><span class="line">                   stk.push(s[i]);//左括号，进栈</span><br><span class="line">                break;</span><br><span class="line">                case&#x27;[&#x27;:</span><br><span class="line">                   stk.push(s[i]);</span><br><span class="line">                break;</span><br><span class="line">                case&#x27;&#123;&#x27;:</span><br><span class="line">                   stk.push(s[i]);</span><br><span class="line">                break;</span><br><span class="line">                case&#x27;)&#x27;:</span><br><span class="line">                   if(stk.empty()) return 0;//如果栈空，返回0</span><br><span class="line">                   if (stk.top() == &#x27;(&#x27;) stk.pop();</span><br><span class="line">                   //如果栈顶是左括号，配对成功，将其出栈，进行下一步</span><br><span class="line">                   else return 0;</span><br><span class="line">                break;</span><br><span class="line">                case&#x27;]&#x27;:</span><br><span class="line">                   if(stk.empty()) return 0;</span><br><span class="line">                   if (stk.top() == &#x27;[&#x27;) stk.pop();</span><br><span class="line">                   else return 0;</span><br><span class="line">                break;</span><br><span class="line">                case&#x27;&#125;&#x27;:</span><br><span class="line">                   if(stk.empty()) return 0;</span><br><span class="line">                   if (stk.top() == &#x27;&#123;&#x27;) stk.pop();</span><br><span class="line">                   else return 0;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return stk.empty();//最终若括号一一配对，栈空，返回1值</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    string s;</span><br><span class="line">    getline(cin,s);</span><br><span class="line">    if(judge(s)==1)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;yes&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        cout&lt;&lt;&quot;no&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="7-3-回文判断"><strong>7-3 回文判断</strong></span></h3><p>回文是指正读反读均相同的字符序列，如“abba”和“abdba”均是回文，但“good”不是回文。编写一个程序，使用栈判定给定的字符序列是否为回文。</p>
<p>若用C++，可借助STL的容器实现。</p>
<p><strong>输入格式:</strong></p>
<p>输入待判断的字符序列，按回车键结束，字符序列长度&lt;20。</p>
<p><strong>输出格式:</strong></p>
<p>若字符序列是回文，输出“YES”；否则，输出“NO”。</p>
<p><strong>输入样例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abdba</span><br></pre></td></tr></table></figure>

<p><strong>输出样例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">YES</span><br></pre></td></tr></table></figure>

<h3><span id="代码实现">代码实现</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">    string s;</span><br><span class="line">    int flag;</span><br><span class="line">    getline(cin,s);</span><br><span class="line">    stack&lt;char&gt;stk;</span><br><span class="line">    for(int i=0;i&lt;s.length();i++)&#123;</span><br><span class="line">        stk.push(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    for(int i=0;i&lt;s.length()/2;i++)&#123;</span><br><span class="line">        flag=0;</span><br><span class="line">        if(s[i]==stk.top())&#123;</span><br><span class="line">            stk.pop();</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;</span><br><span class="line">            flag=1;</span><br><span class="line">            break;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(flag==0) cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>数据结构笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>正弦稳态电路分析</title>
    <url>/2024/04/01/%E6%AD%A3%E5%BC%A6%E7%A8%B3%E6%80%81%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#%E6%AD%A3%E5%BC%A6%E4%BF%A1%E5%8F%B7">正弦信号</a><ul>
<li><a href="#1%E6%AD%A3%E5%BC%A6%E4%BF%A1%E5%8F%B7%E7%9A%84%E4%B8%89%E8%A6%81%E7%B4%A0">1.正弦信号的三要素</a></li>
<li><a href="#2%E6%AD%A3%E5%BC%A6%E4%BF%A1%E5%8F%B7%E7%9A%84%E7%9B%B8%E4%BD%8D%E5%B7%AE">2.正弦信号的相位差</a></li>
<li><a href="#3%E6%AD%A3%E5%BC%A6%E4%BF%A1%E5%8F%B7%E7%9A%84%E6%9C%89%E6%95%88%E5%80%BC">3.正弦信号的有效值</a></li>
</ul>
</li>
<li><a href="#%E6%AD%A3%E5%BC%A6%E4%BF%A1%E5%8F%B7%E7%9A%84%E7%9B%B8%E9%87%8F%E8%A1%A8%E7%A4%BA">正弦信号的相量表示</a><ul>
<li><a href="#1%E5%A4%8D%E6%95%B0a%E7%9A%84%E8%A1%A8%E7%A4%BA">1.复数A的表示</a></li>
<li><a href="#2%E7%94%A8%E7%9B%B8%E9%87%8F%E8%A1%A8%E7%A4%BA%E6%AD%A3%E5%BC%A6%E4%BF%A1%E5%8F%B7">2.用相量表示正弦信号</a></li>
</ul>
</li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E5%85%83%E4%BB%B6%E4%BC%8F%E5%AE%89%E7%89%B9%E6%80%A7%E7%9A%84%E7%9B%B8%E9%87%8F%E5%BD%A2%E5%BC%8F">基本元件伏安特性的相量形式</a><ul>
<li><a href="#1%E7%94%B5%E9%98%BB%E5%85%83%E4%BB%B6">1.电阻元件</a></li>
<li><a href="#2%E7%94%B5%E6%84%9F%E5%85%83%E4%BB%B6">2.电感元件</a></li>
<li><a href="#3%E7%94%B5%E5%AE%B9%E5%85%83%E4%BB%B6">3.电容元件</a></li>
<li><a href="#4%E6%AD%A3%E5%BC%A6%E7%94%B5%E6%BA%90%E7%9A%84%E7%9B%B8%E9%87%8F%E6%A8%A1%E5%9E%8B">4.正弦电源的相量模型</a></li>
</ul>
</li>
<li><a href="#%E7%9B%B8%E9%87%8F%E6%A8%A1%E5%9E%8B">相量模型</a><ul>
<li><a href="#1%E9%98%BB%E6%8A%97%E5%92%8C%E5%AF%BC%E7%BA%B3">1.阻抗和导纳</a></li>
<li><a href="#2%E7%9B%B8%E9%87%8F%E5%9B%BE">2.相量图</a></li>
<li><a href="#3%E9%98%BB%E6%8A%97%E5%92%8C%E5%AF%BC%E7%BA%B3%E7%9A%84%E4%B8%B2-%E5%B9%B6%E8%81%94">3.阻抗和导纳的串、并联</a></li>
</ul>
</li>
<li><a href="#%E4%B8%B2%E8%81%94%E8%B0%90%E6%8C%AF">串联谐振</a><ul>
<li><a href="#1%E6%9D%A1%E4%BB%B6">1.条件</a></li>
<li><a href="#2%E7%89%B9%E5%BE%81">2.特征</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<p>[TOC]</p>
<h2><span id="正弦信号">正弦信号</span></h2><p>正弦稳态电路：在正弦电源作用下，电路达到稳定工作状态时的正弦稳态电路。</p>
<p>正弦交流信号可以用sin函数表示，也可以用cos函数表示，本书采用sin函数。</p>
<h3><span id="1正弦信号的三要素">1.正弦信号的三要素</span></h3><h4><span id="一个正弦信号由3个参数确定最大值-频率角频率和初相">一个正弦信号由3个参数确定：<strong>最大值、频率（角频率）和初相</strong></span></h4><p>（1）<strong>正弦交流信号的一般表达式</strong>：<strong>u(t) &#x3D; Uₘ sin(ωt + θ)</strong></p>
<p>（2）<strong>Uₘ</strong>：<strong>幅值</strong>，表示正弦量所能达到的最大值；又叫峰值或振幅</p>
<p>（3）**(ωt + θ)<strong>：</strong>相位**；θ称为相位角</p>
<p>（4）<strong>ω</strong>：<strong>角频率</strong>，是正弦量在单位时间内变化的弧度数，单位<strong>rad&#x2F;s</strong></p>
<p>（5）<strong>周期</strong>：周期T表示正弦量变化一周需要的时间，单位<strong>s</strong></p>
<p>（6）<strong>公式</strong>：①<strong>T&#x3D;2π&#x2F;ω</strong></p>
<p>​                      ②<strong>f&#x3D;1&#x2F;T</strong></p>
<h3><span id="2正弦信号的相位差">2.正弦信号的相位差</span></h3><p>（1）<strong>定义</strong>：两个同频率正弦信号在任一时刻的相位之差称为相位差，实际上是初相之差。</p>
<p>（2）<strong>符号表示</strong>：θ&#x3D;θᵢ - θᵤ</p>
<p>（3）θ&gt;0，表示i(t)超前于u(t)，电流比电压先到达最大值或最小值；</p>
<p>​          θ&lt;0，表示i(t)滞后于u(t)；</p>
<p>​          θ&#x3D;0，则称i(t)与u(t)同相，二者同时到达最值；</p>
<p>​          θ&#x3D;+-π，则称i(t)与u(t)反相，当i(t)达到最大值时，u(t)达到最小值，反之亦然。</p>
<h3><span id="3正弦信号的有效值">3.正弦信号的有效值</span></h3><p>（1）<strong>定义</strong>：设两个阻值相同的电阻，分别通过周期电流和直流电流，在一个周期内，两个电阻消耗相同的能量，就称该直流电流值为周期电流的有效值。</p>
<p>（2）<strong>总结</strong>：<u>正弦信号的振幅值等于有效值的√2倍。</u></p>
<p>​                     Uₘ &#x3D; √2 U               Iₘ &#x3D; √2 I</p>
<p>（3）<strong>公式表示</strong>：i(t)&#x3D;√2 I sin(ωt + θᵢ)</p>
<p>​                             u(t)&#x3D;√2 U sin(ωt + θᵤ)</p>
<h2><span id="正弦信号的相量表示">正弦信号的相量表示</span></h2><h3><span id="1复数a的表示">1.复数A的表示</span></h3><h4><span id="1代数型-指数型和极型">（1）代数型、指数型和极型</span></h4><ul>
<li><input disabled type="checkbox"> <strong>代数型</strong>：A&#x3D;a1 + ja2</li>
<li><input disabled type="checkbox"> <strong>指数型</strong>：A&#x3D;aeʲᶿ</li>
<li><input disabled type="checkbox"> <strong>极型</strong>：a∠θ</li>
</ul>
<h4><span id="2指数型转换为代数型">（2）指数型转换为代数型</span></h4><ul>
<li><input disabled type="checkbox"> <strong>欧拉公式</strong>：eʲᶿ &#x3D; cosθ + jsinθ</li>
<li><input disabled type="checkbox"> 特别的，e^jπ&#x2F;2 &#x3D; cos(π&#x2F;2) + jsin(π&#x2F;2) &#x3D;j</li>
</ul>
<h4><span id="3代数型转换为指数型和极型">（3）代数型转换为指数型和极型</span></h4><ul>
<li><p><input disabled type="checkbox"> 
<strong>a &#x3D; (a₁² + a₂²)^1&#x2F;2</strong></p>
</li>
<li><p><input disabled type="checkbox"> 
<strong>θ &#x3D; arctan (a₂&#x2F;a₁)</strong></p>
</li>
<li><p><input disabled type="checkbox"> 
常用值：arctan1 &#x3D; π&#x2F;4</p>
<p>​                arctan√3 &#x3D; π&#x2F;3</p>
<p>​                arctan1&#x2F;√3 &#x3D; π&#x2F;6</p>
</li>
</ul>
<img src="/2024/04/01/%E6%AD%A3%E5%BC%A6%E7%A8%B3%E6%80%81%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/微信截图_20240402012354.png" alt="微信截图_20240402012354" style="zoom:80%;">

<h4><span id="4计算">（4）计算</span></h4><img src="/2024/04/01/%E6%AD%A3%E5%BC%A6%E7%A8%B3%E6%80%81%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/微信截图_20240402012812.png" alt="微信截图_20240402012812" style="zoom:80%;">

<h3><span id="2用相量表示正弦信号">2.用相量表示正弦信号</span></h3><h4><span id="1正弦电流-电压的表示">（1）正弦电流、电压的表示</span></h4><p><img src="/2024/04/01/%E6%AD%A3%E5%BC%A6%E7%A8%B3%E6%80%81%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240405124242.png" alt="微信截图_20240405124242"></p>
<p><img src="/2024/04/01/%E6%AD%A3%E5%BC%A6%E7%A8%B3%E6%80%81%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240405123709.png" alt="微信图片_20240405123709"></p>
<h4><span id="2正弦信号与相量的对应规则">（2）正弦信号与相量的对应规则</span></h4><p><img src="/2024/04/01/%E6%AD%A3%E5%BC%A6%E7%A8%B3%E6%80%81%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240405125143.png" alt="微信截图_20240405125143"></p>
<h4><span id="3电流相量适用基尔霍夫定律见例题p87-p91">（3）电流相量适用基尔霍夫定律（见例题P87、P91）</span></h4><p>由i(t)&#x3D;i₁(t) + i₂(t)，有I˙ &#x3D;I˙₁ + I˙₂</p>
<p>由u(t)&#x3D;u₁(t) + u₂(t)，有U˙ &#x3D;U˙₁ + U˙₂</p>
<p>结论对于有效值相量和振幅相量都适用。</p>
<h2><span id="基本元件伏安特性的相量形式">基本元件伏安特性的相量形式</span></h2><h3><span id="1电阻元件">1.电阻元件</span></h3><p><img src="/2024/04/01/%E6%AD%A3%E5%BC%A6%E7%A8%B3%E6%80%81%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240405130717.png" alt="微信图片_20240405130717"></p>
<h3><span id="2电感元件">2.电感元件</span></h3><p><img src="/2024/04/01/%E6%AD%A3%E5%BC%A6%E7%A8%B3%E6%80%81%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240405131106.png" alt="微信截图_20240405131106"></p>
<h3><span id="3电容元件">3.电容元件</span></h3><p><img src="/2024/04/01/%E6%AD%A3%E5%BC%A6%E7%A8%B3%E6%80%81%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240405132101.png" alt="微信截图_20240405132101"></p>
<h3><span id="4正弦电源的相量模型">4.正弦电源的相量模型</span></h3><p>①<strong>正弦电压源</strong>：如果一个独立电压源uₛ(t)的输出电压为正弦电压，即uₛ(t) &#x3D; √2 Uₛ sin(ωt + θᵤ)，就称其为正弦电压源。</p>
<p>参数：Uₛ→有效值；ω→角频率；θᵤ→初相。</p>
<p>②<strong>正弦电流源</strong>：Iₛ(t) &#x3D; √2 Iₛ sin(ωt + θᵤ)</p>
<p>③正弦受控源：VCVC,CCVS,VCCS,CCCS</p>
<h2><span id="相量模型">相量模型</span></h2><h3><span id="1阻抗和导纳">1.阻抗和导纳</span></h3><h4><span id="1阻抗z">（1）阻抗Z</span></h4><h5><span id="1概念">①概念</span></h5><p><img src="/2024/04/01/%E6%AD%A3%E5%BC%A6%E7%A8%B3%E6%80%81%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/4c636121dd444a1e847b36ec124dfc34.png" alt="4c636121dd444a1e847b36ec124dfc34"></p>
<p>X&#x3D;0时，阻抗Z成电阻性。</p>
<p>把X替换成φᶻ也成立（z是下标）。</p>
<h5><span id="2转换关系">②转换关系</span></h5><p>R &#x3D; |Z|cosφᶻ（z是下标）</p>
<p>X &#x3D; |Z|sinφᶻ</p>
<p>其中，</p>
<p>|Z| &#x3D; √（R² + X²） &#x3D; U&#x2F;I</p>
<p>φᶻ &#x3D; arctan（X&#x2F;R）&#x3D; θᵤ - θᵢ</p>
<h5><span id="3基本元件的阻抗">③基本元件的阻抗</span></h5><p><img src="/2024/04/01/%E6%AD%A3%E5%BC%A6%E7%A8%B3%E6%80%81%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/35e4c5e6308d447aadb1585fcfa64836.png" alt="35e4c5e6308d447aadb1585fcfa64836"></p>
<p>其中，X˪ &#x3D; ωL，Xᶜ &#x3D; -1&#x2F;ωC  （c是下标）</p>
<h4><span id="2导纳y">（2）导纳Y</span></h4><p><img src="/2024/04/01/%E6%AD%A3%E5%BC%A6%E7%A8%B3%E6%80%81%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/aba8b119efdc4c78845b70dc846c1eaa.png" alt="aba8b119efdc4c78845b70dc846c1eaa"></p>
<p>导纳的量纲是西门子（S）。</p>
<h3><span id="2相量图">2.相量图</span></h3><p>确定相量的角度需要两个步骤:</p>
<p>①第1步:确定参考相量，即角度为零的相量</p>
<p><strong>串联电路</strong>选<strong>电流</strong>作为参考相量</p>
<p><strong>并联电路</strong>选<strong>电压</strong>作为参考相量</p>
<p>②第2步:根据支路的VCR确定支路电压或电流相量的角度</p>
<p><strong>滞后</strong>：顺时针，后面（以U˪的相量形式作为参照）</p>
<p><strong>超前</strong>：逆时针，前面</p>
<p><img src="/2024/04/01/%E6%AD%A3%E5%BC%A6%E7%A8%B3%E6%80%81%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/fb1a95a4fab44f2aac3ed1a013f8078d.png" alt="fb1a95a4fab44f2aac3ed1a013f8078d"></p>
<p><img src="/2024/04/01/%E6%AD%A3%E5%BC%A6%E7%A8%B3%E6%80%81%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/db461cce59f34b9b9df7b855b362fb60.png" alt="db461cce59f34b9b9df7b855b362fb60"></p>
<p><img src="/2024/04/01/%E6%AD%A3%E5%BC%A6%E7%A8%B3%E6%80%81%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/f6acd5e9b5bb46fb92aa919e11f436a0.png" alt="f6acd5e9b5bb46fb92aa919e11f436a0"></p>
<h3><span id="3阻抗和导纳的串-并联">3.阻抗和导纳的串、并联</span></h3><p><img src="/2024/04/01/%E6%AD%A3%E5%BC%A6%E7%A8%B3%E6%80%81%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240415222834.png" alt="微信图片_20240415222834"></p>
<h2><span id="串联谐振">串联谐振</span></h2><h3><span id="1条件">1.条件</span></h3><p>①电路的总阻抗是：Z &#x3D; R + j(ωL - 1&#x2F;ωC)</p>
<p>②发生谐振时，端口电压U&#96;和端口电流I·同相，只有当阻抗的虚部为0才能满足此条件。</p>
<p>③公式：ω &#x3D; ω₀ &#x3D; 1 &#x2F; √（ωC）</p>
<h3><span id="2特征">2.特征</span></h3><p>①谐振时的阻抗最小，电流最大。</p>
<p>②谐振时的电压与电流同相。并且达到最大值。</p>
<p>③谐振时电感电压和电容电压大小相等，方向相反，电阻电压等于电源电压。</p>
]]></content>
      <tags>
        <tag>电子电路基础</tag>
      </tags>
  </entry>
  <entry>
    <title>栈的表示和操作实现</title>
    <url>/2024/04/05/%E6%A0%88%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E6%93%8D%E4%BD%9C%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h3><span id="一-顺序栈">一、顺序栈</span></h3><h3><span id="二-链栈">二、链栈</span></h3><h3><span id="三-用堆栈求解后缀表达式">三、用堆栈求解后缀表达式</span></h3><h4><span id="1定义">1.定义</span></h4><p>后缀表达式是一种不需要括号的表达式，其本身是对栈的一种应用。</p>
<p>与之对应的是中缀表达式，即我们现在使用的四则运算。</p>
<h4><span id="2运算规则">2.运算规则</span></h4><p>顺序：从左到右入栈。</p>
<p>对于数字直接入栈，对于运算符号，就把栈最上面的两个数出栈，进行运算后再重新入栈。式子最后的结果出栈。</p>
<p>栈顶元素永远在运算符的右边。</p>
<h4><span id="3例子">3.例子</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）令P代表入栈，O代表出栈。当利用堆栈求解后缀表达式1 2 3 + * 4 –时，堆栈操作序列是：</span><br><span class="line"></span><br><span class="line">A.PPPOOPOO</span><br><span class="line"></span><br><span class="line">B.PPOOPPOOPPOO</span><br><span class="line"></span><br><span class="line">C.PPPOOPOOPPOO</span><br><span class="line"></span><br><span class="line">D.PPPOOPOOPPOOPO</span><br></pre></td></tr></table></figure>

<p>1、2、3：进栈，PPP</p>
<p>+：对最顶上的3、2出栈，计算2+3&#x3D;5，把结果进栈，OOP</p>
<p>*：对5、1出栈，计算5x1&#x3D;5，把结果进栈，OOP</p>
<p>4：进栈，P</p>
<p>-：对4、5出栈，计算4-5&#x3D;-1，把结果进栈，OOP</p>
<p>最后输出结果：O</p>
<p>答案为D。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（2）表达式`a*(b+c)-d`的后缀表达式是：</span><br><span class="line"></span><br><span class="line">A.`a b c + * d -`</span><br><span class="line"></span><br><span class="line">B.`a b c d * + -`</span><br><span class="line"></span><br><span class="line">C.`a b c * + d -`</span><br><span class="line"></span><br><span class="line">D.`- + * a b c d`</span><br></pre></td></tr></table></figure>

<p>数字优先进栈，所以abc</p>
<p>括号内的式子优先计算，所以首先遇到+，为abc+</p>
<p>算完加法算乘法，所以abc+*</p>
<p>继续将d进栈，然后算减法，所以是abc+*d-</p>
<p>答案为A。</p>
]]></content>
      <tags>
        <tag>数据结构笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构课设报告——用顺序表实现图书信息管理系统</title>
    <url>/2024/03/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E8%AE%BE%E6%8A%A5%E5%91%8A%E2%80%94%E2%80%94%E7%94%A8%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%AE%9E%E7%8E%B0%E5%9B%BE%E4%B9%A6%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90">【案例分析】</a></li>
<li><a href="#%E5%AE%9E%E9%AA%8C%E8%BF%87%E7%A8%8B">【实验过程】</a><ul>
<li><a href="#1%E9%A2%84%E5%85%88%E5%AE%9A%E4%B9%89">1.预先定义</a></li>
<li><a href="#2%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96">2.顺序表的初始化</a></li>
<li><a href="#3%E5%BD%95%E5%85%A5%E5%9B%BE%E4%B9%A6%E4%BF%A1%E6%81%AF">3.录入图书信息</a></li>
<li><a href="#4%E6%9F%A5%E6%89%BE%E5%9B%BE%E4%B9%A6%E4%BF%A1%E6%81%AF">4.查找图书信息</a></li>
</ul>
</li>
<li><a href="#5%E6%B7%BB%E5%8A%A0%E4%B9%A6%E7%B1%8D%E4%BF%A1%E6%81%AF">5.添加书籍信息</a></li>
<li><a href="#6%E5%88%A0%E9%99%A4%E4%B9%A6%E7%B1%8D">6.删除书籍</a></li>
<li><a href="#7%E4%BF%AE%E6%94%B9%E4%B9%A6%E7%B1%8D%E4%BF%A1%E6%81%AF">7.修改书籍信息</a></li>
<li><a href="#8%E6%8E%92%E5%BA%8F">8.排序</a></li>
</ul>
<ul>
<li><a href="#%E4%BB%A3%E7%A0%81">【代码】</a></li>
</ul>
<!-- tocstop -->

<p>[TOC]</p>
<h2><span id="案例分析">【案例分析】</span></h2><p>将图书馆信息管理系统抽象成</p>
<p>线性表，每本书作为线性表的一个元素，其中包括以下功能：</p>
<p>1.查找。通过输入关键词，返回该书的所有信息。</p>
<p>2.插入。添加新的书籍。</p>
<p>3.删除。删除书籍。</p>
<p>4.修改。调用查找功能，找到对应书籍并修改。</p>
<p>5.排序。</p>
<p>6.计数。</p>
<h2><span id="实验过程">【实验过程】</span></h2><h3><span id="1预先定义">1.预先定义</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`#include&lt;new&gt;`</span><br><span class="line">`#include&lt;fstream&gt; //对文件输入输出` </span><br><span class="line">`#include&lt;iostream&gt;  //对屏幕上输入输出`</span><br><span class="line">`using namespace std;`</span><br><span class="line">`#define maxsize 1000`</span><br><span class="line">`typedef struct&#123;`</span><br><span class="line">	`char no[20];  //图书编号` </span><br><span class="line">	`char name[50];  //书名` </span><br><span class="line">	`float price;  //定价` </span><br><span class="line">`&#125;book;`</span><br><span class="line">`typedef struct&#123;`</span><br><span class="line">	`book *elem;   //存储空间的基地址`</span><br><span class="line">	`int len;     //表长`</span><br><span class="line">`&#125;SqList;  //图书表的顺序存储结构为SqList` </span><br></pre></td></tr></table></figure>

<p>之后，在main函数中设置 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`SqList L;` </span><br></pre></td></tr></table></figure>



<h3><span id="2顺序表的初始化">2.顺序表的初始化</span></h3><p>为顺序表分配一个预定义大小的数组空间，并把表长设定为0。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`int initlist(SqList &amp;L)`</span><br><span class="line">`//构造空表` </span><br><span class="line">`&#123;`</span><br><span class="line">	`L.elem = new book[maxsize];`</span><br><span class="line">	`if(!L.elem)  exit(0);  //存储分配失败，不知为何，在这个地方用return -1会导致后续程序出错`</span><br><span class="line">	`L.len=0;`</span><br><span class="line">	`return 1;` </span><br><span class="line">`&#125;`</span><br></pre></td></tr></table></figure>

<p>new int的作用是分配内存，找到一个连续的内存块，然后返回一个指向该内存的指针。</p>
<p>如：<code>int* a = new int;</code></p>
<p>这样，我们为a分配了一个4字节的内存。</p>
<p>如果想分配一个数组，就在数组名后面加[]，里面输入数字。</p>
<h3><span id="3录入图书信息">3.录入图书信息</span></h3><p>在开启图书馆管理功能前，有必要先录入书籍信息，在这里，我用文件读取数组信息的方法实现批量录入。</p>
<p><em>001 NineteenEightyFour 25.00</em><br><em>002 HarryPotter 400.00</em><br><em>003 GonewiththeWind 40.00</em><br><em>004 AnimalFarm 10.00</em><br><em>005 LePetitPrince 22.00</em><br><em>006 ToKillaMockingBird 32.00</em><br><em>007 Siddhartha 32.00</em><br><em>008 DifferentSeasons 29.90</em><br><em>009 FlowersforAlgernon 36.00</em><br><em>010 RiverTown 36.00</em></p>
<p>关于文件读写的笔记，我写在另一篇文章。</p>
<h3><span id="4查找图书信息">4.查找图书信息</span></h3><p>由于图书一共录入三种信息，所以我们可以分别用三种信息（编号，名字，价格）进行查找。编号和名字是char[]字符数组，借助函数**strcmp(新字符，待比较旧字符)**，如果函数值为0，说明两个字符相同，完成查找；这时我们借助一个初始值为0的计数器joke，如果查找成功，joke++，如果遍历结束还是找不到，joke值则始终为0。</p>
<p>如果不要求键入信息十分精准，通过关键字即可返回，则可以使用函数<strong>strstr（母字符串，子字符串）</strong>，注意定义指针。它的写法是：</p>
<p><code>#include&lt;cstring&gt;//头文件</code></p>
<p><code>char new[20];</code></p>
<p><code>char old[20];</code></p>
<p><code>char* a=strstr(old,new);</code></p>
<p><code>if(a==NULL)  cout&lt;&lt;&quot;not found&quot;&lt;&lt;endl; //此时说明两个字符完全不相同</code></p>
<p><u>注意：strstr函数区分大小写。</u></p>
<h4><span id="1根据图书编号查找">（1）根据图书编号查找</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`void Findno(SqList L)`</span><br><span class="line">`//查找书号` </span><br><span class="line">`&#123;`</span><br><span class="line">	`char findno[20];`</span><br><span class="line">	`cin&gt;&gt;findno;`</span><br><span class="line">	`int joke=0;`</span><br><span class="line">	`cout&lt;&lt;&quot;图书编号&quot;&lt;&lt;setw(20)&lt;&lt;&quot;书名&quot;&lt;&lt;setw(30)&lt;&lt;&quot;价格&quot;&lt;&lt;endl;`</span><br><span class="line">	`for(int i=0;i&lt;L.len;i++)&#123;`</span><br><span class="line">		`if(strcmp(findno,L.elem[i].no)==0)&#123;`</span><br><span class="line">			`joke++;`</span><br><span class="line">			`cout&lt;&lt;fixed&lt;&lt;setprecision(2);`</span><br><span class="line">			`cout&lt;&lt;L.elem[i].no&lt;&lt;setw(30)&lt;&lt;L.elem[i].name&lt;&lt;setw(30)&lt;&lt;L.elem[i].price&lt;&lt;endl;`</span><br><span class="line">		`&#125;`</span><br><span class="line">	`&#125;`</span><br><span class="line">	`if(joke==0) cout&lt;&lt;&quot;404 NOT FOUND&quot;&lt;&lt;endl;`</span><br><span class="line">`&#125;`</span><br></pre></td></tr></table></figure>



<h4><span id="2根据书名查找">（2）根据书名查找</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`void Findname(SqList L)`</span><br><span class="line">`//查找书名`</span><br><span class="line">`&#123;`</span><br><span class="line">	`char findname[50];`</span><br><span class="line">	`cin&gt;&gt;findname;`</span><br><span class="line">	`int joke=0;`</span><br><span class="line">	`cout&lt;&lt;&quot;图书编号&quot;&lt;&lt;setw(20)&lt;&lt;&quot;书名&quot;&lt;&lt;setw(30)&lt;&lt;&quot;价格&quot;&lt;&lt;endl;`</span><br><span class="line">	`for(int i=0;i&lt;L.len;i++)&#123;`</span><br><span class="line">	`char *b=strstr(L.elem[i].name,findname);`</span><br><span class="line">		`if(b!=NULL)&#123;`</span><br><span class="line">			`joke++;`</span><br><span class="line">			`cout&lt;&lt;L.elem[i].no&lt;&lt;setw(30)&lt;&lt;L.elem[i].name&lt;&lt;setw(30)&lt;&lt;L.elem[i].price&lt;&lt;endl;`</span><br><span class="line">		`&#125;`</span><br><span class="line">	`&#125;`</span><br><span class="line">	`if(joke==0) cout&lt;&lt;&quot;404 NOT FOUND&quot;&lt;&lt;endl;`</span><br><span class="line">	 ``</span><br><span class="line">`&#125;`</span><br></pre></td></tr></table></figure>



<h4><span id="3根据价格查找">（3）根据价格查找</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`void Findprice(SqList L)`</span><br><span class="line">`//查找价格` </span><br><span class="line">`&#123;`</span><br><span class="line">	`float findprice;`</span><br><span class="line">	`cin&gt;&gt;findprice;`</span><br><span class="line">	`int joke=0;`</span><br><span class="line">	`cout&lt;&lt;&quot;图书编号&quot;&lt;&lt;setw(20)&lt;&lt;&quot;书名&quot;&lt;&lt;setw(30)&lt;&lt;&quot;价格&quot;&lt;&lt;endl;`</span><br><span class="line">	`for(int i=0;i&lt;L.len;i++)&#123;`</span><br><span class="line">		`if(findprice==L.elem[i].price)&#123;`</span><br><span class="line">			`joke++;`</span><br><span class="line">			`cout&lt;&lt;L.elem[i].no&lt;&lt;setw(30)&lt;&lt;L.elem[i].name&lt;&lt;setw(30)&lt;&lt;L.elem[i].price&lt;&lt;endl;`</span><br><span class="line">		`&#125;`</span><br><span class="line">	`&#125;`</span><br><span class="line">	`if(joke==0) cout&lt;&lt;&quot;404 NOT FOUND&quot;&lt;&lt;endl;`</span><br><span class="line">	 ``</span><br><span class="line">`&#125;`</span><br></pre></td></tr></table></figure>



<h2><span id="5添加书籍信息">5.添加书籍信息</span></h2><p>这个功能很简单，先准备好待插入的顺序表位置newnumber，对于newnumber之后的元素，统一后移一个单位，<u>表长加一</u>。记得<u>检查表是否溢出（表长&#x3D;&#x3D;maxsize），和newnumber的合法范围</u>（还记得数组从0开始，而顺序表是从1开始吗？所以，newnumber最小可以是1；另外，插入顺序表允许末尾追加，所以newnumber最大可以是表长+1。实际范围是**<u>[1,表长+1]</u>**。)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">``int listinsert(SqList &amp;L,int newnumber)`</span><br><span class="line">`//添加新图书`</span><br><span class="line">`&#123;`</span><br><span class="line">	`if( (newnumber&gt;L.len+1) || (newnumber&lt;1) ) exit(0);`</span><br><span class="line">	`if(L.len==maxsize) exit(0);`</span><br><span class="line">	`for(int i=L.len-1;i&gt;=newnumber-1;i--)&#123;`</span><br><span class="line">		`L.elem[i+1]=L.elem[i]; //插入位置以后的元素后移一个单位`</span><br><span class="line">	`&#125;L.elem[newnumber-1]=L.elem[maxsize-1];`</span><br><span class="line">	`L.len++;`</span><br><span class="line">	`return 1;`</span><br><span class="line"> &#125;` </span><br><span class="line"></span><br><span class="line">这里，</span><br></pre></td></tr></table></figure>

<p>我把要添加进去的数组信息放在了顺序表的最后一个位置maxsize，等插入位置以后的元素完成后移后，再将这组信息填进待插入的位置。</p>
<p>为了能直观地查看添加后的效果，设置一个输出函数，后续可以重复利用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">``void readlist(SqList L)&#123;`</span><br><span class="line">	`cout&lt;&lt;&quot;图书编号&quot;&lt;&lt;setw(20)&lt;&lt;&quot;书名&quot;&lt;&lt;setw(30)&lt;&lt;&quot;价格&quot;&lt;&lt;endl;`</span><br><span class="line">	`for(int i=0;i&lt;L.len;i++)&#123;`</span><br><span class="line">		`cout&lt;&lt;fixed&lt;&lt;setprecision(2);`</span><br><span class="line">		`cout&lt;&lt;L.elem[i].no&lt;&lt;setw(30)&lt;&lt;L.elem[i].name&lt;&lt;setw(30)&lt;&lt;L.elem[i].price&lt;&lt;endl;`</span><br><span class="line"> `&#125;`</span><br><span class="line">&#125;`</span><br></pre></td></tr></table></figure>



<h2><span id="6删除书籍">6.删除书籍</span></h2><p>这个功能需要借助查找功能。首先，我们查找一本书，定位到它在顺序表中的位置后（自然，我们知道了<u>这个位置的合法范围是**[1,表长]**</u>），使<u>该位置之后的元素统一往前移动一个单位，该书自然就被覆盖掉了。记得<u>表长减一</u>。</u></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`void listdelete(SqList &amp;L)`</span><br><span class="line">`//删除一本书`</span><br><span class="line">`&#123;`</span><br><span class="line">   `int deletedata;`</span><br><span class="line">	`char findnoname[50];`</span><br><span class="line">`cin&gt;&gt;findnoname;`</span><br><span class="line">`int joke=0;`</span><br><span class="line">`char* a;`</span><br><span class="line">`cout&lt;&lt;&quot;图书编号&quot;&lt;&lt;setw(20)&lt;&lt;&quot;书名&quot;&lt;&lt;setw(30)&lt;&lt;&quot;价格&quot;&lt;&lt;endl;`</span><br><span class="line">`for(int i=0;i&lt;L.len;i++)&#123;`</span><br><span class="line">	`a=strstr(L.elem[i].name,findnoname);`</span><br><span class="line">	`if(strcmp(findnoname,L.elem[i].no)==0)&#123;`</span><br><span class="line">		`joke++;`</span><br><span class="line">		`cout&lt;&lt;L.elem[i].no&lt;&lt;setw(30)&lt;&lt;L.elem[i].name&lt;&lt;setw(30)&lt;&lt;L.elem[i].price&lt;&lt;endl;`</span><br><span class="line">		`deletedata=i+1;`</span><br><span class="line">	`&#125;`</span><br><span class="line">	`if(a!=NULL)&#123;`</span><br><span class="line">		`joke++;`</span><br><span class="line">		`cout&lt;&lt;L.elem[i].no&lt;&lt;setw(30)&lt;&lt;L.elem[i].name&lt;&lt;setw(30)&lt;&lt;L.elem[i].price&lt;&lt;endl;`</span><br><span class="line">		`deletedata=i+1;`</span><br><span class="line">	`&#125;`</span><br><span class="line">`&#125;`</span><br><span class="line">`if(joke==0) cout&lt;&lt;&quot;404 NOT FOUND&quot;&lt;&lt;endl;`</span><br><span class="line">	``if((deletedata&lt;1) || (deletedata&gt;L.len)) exit(0);`</span><br><span class="line">	`for(int i=deletedata;i&lt;L.len;i++)&#123;`</span><br><span class="line">		`L.elem[i-1]=L.elem[i]; //对i所在的位置删除数据后，进行前移，前一个元素等于后一个元素` </span><br><span class="line"> `&#125;L.len--;`</span><br><span class="line">&#125;`</span><br></pre></td></tr></table></figure>

<h2><span id="7修改书籍信息">7.修改书籍信息</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int doinglist(SqList &amp;L)</span><br><span class="line">//修改顺序表信息 </span><br><span class="line">&#123;</span><br><span class="line">	cout&lt;&lt;&quot;请输入书籍编号&quot;&lt;&lt;endl;</span><br><span class="line">char findno[20];</span><br><span class="line">cin&gt;&gt;findno;</span><br><span class="line">int joke=0;</span><br><span class="line">int doing;</span><br><span class="line">for(int i=0;i&lt;L.len;i++)&#123;</span><br><span class="line">	if(strcmp(findno,L.elem[i].no)==0)&#123;</span><br><span class="line">		joke++;</span><br><span class="line">		cout&lt;&lt;&quot;获取书籍信息成功！&quot;&lt;&lt;endl;</span><br><span class="line">		cout&lt;&lt;&quot;图书编号&quot;&lt;&lt;setw(20)&lt;&lt;&quot;书名&quot;&lt;&lt;setw(30)&lt;&lt;&quot;价格&quot;&lt;&lt;endl;</span><br><span class="line">		cout&lt;&lt;fixed&lt;&lt;setprecision(2);</span><br><span class="line">		cout&lt;&lt;L.elem[i].no&lt;&lt;setw(30)&lt;&lt;L.elem[i].name&lt;&lt;setw(30)&lt;&lt;L.elem[i].price&lt;&lt;endl;</span><br><span class="line">		while(1)&#123;</span><br><span class="line">			cout&lt;&lt;&quot;请输入（0-3）：1.修改书籍编号 2.修改书名 3.修改书的价格 0.退出修改&quot;&lt;&lt;endl;</span><br><span class="line">			cin&gt;&gt;doing;</span><br><span class="line">			switch(doing)&#123;</span><br><span class="line">				case 1:&#123;</span><br><span class="line">					cout&lt;&lt;&quot;请输入新书籍编号：&quot;&lt;&lt;endl;</span><br><span class="line">					char newno[20];</span><br><span class="line">					cin&gt;&gt;newno;</span><br><span class="line">					strcpy(L.elem[i].no,newno); </span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">				case 2:&#123;</span><br><span class="line">					cout&lt;&lt;&quot;请输入新书名：&quot;&lt;&lt;endl;</span><br><span class="line">					char newname[50];</span><br><span class="line">					cin&gt;&gt;newname;</span><br><span class="line">					strcpy(L.elem[i].name,newname); </span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">				case 3:&#123;</span><br><span class="line">					cout&lt;&lt;&quot;请输入新价格：&quot;&lt;&lt;endl;</span><br><span class="line">					float newprice;</span><br><span class="line">					cin&gt;&gt;newprice;</span><br><span class="line">					L.elem[i].price=newprice;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">				case 0:&#123;</span><br><span class="line">				system(&quot;pause&quot;);</span><br><span class="line">			    system(&quot;cls&quot;);//实现清屏</span><br><span class="line">			    return 0;</span><br><span class="line">				&#125;break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="8排序">8.排序</span></h2><p>依照价格高低，对书籍进行排序。采用选择排序法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void talllist(SqList &amp;L)</span><br><span class="line"> //选择排序法 </span><br><span class="line"> &#123;</span><br><span class="line"> 	int max;  </span><br><span class="line">    for(int i=0;i&lt;L.len-1;i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        max=i;  </span><br><span class="line">        for(int j=i;j&lt;L.len;j++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            if(L.elem[max].price &gt; L.elem[j].price)  //本质是索引为i和i+1 的结构体成员在做比较，这种写法可以保证不漏掉每一组比较 </span><br><span class="line">                max=j;  </span><br><span class="line">        &#125;  </span><br><span class="line">        L.elem[L.len+1] = L.elem[i];  //用一个在顺序表外面的位置储存旧值，暂时没想到其他好的办法 </span><br><span class="line">        L.elem[i] = L.elem[max];  </span><br><span class="line">        L.elem[max] = L.elem[L.len+1] ;</span><br><span class="line">	 &#125;</span><br></pre></td></tr></table></figure>

<p>9.这个很简单，统计数目只需要输出表长就可以了</p>
<p>我用文件读取的时候多读了一行0，所以实操的时候用了表长-1</p>
<h1><span id="代码">【代码】</span></h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;new&gt;</span><br><span class="line">#include&lt;fstream&gt; //对文件输入输出 </span><br><span class="line">#include&lt;iostream&gt;  //对屏幕上输入输出</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define maxsize 1000</span><br><span class="line">typedef struct&#123;</span><br><span class="line">	char no[20];  //图书编号 </span><br><span class="line">	char name[50];  //书名 </span><br><span class="line">	float price;  //定价 </span><br><span class="line">&#125;book;</span><br><span class="line">typedef struct&#123;</span><br><span class="line">	book *elem;   //存储空间的基地址</span><br><span class="line">	int len;     //表长</span><br><span class="line">&#125;SqList;  //图书表的顺序存储结构为SqList </span><br><span class="line"></span><br><span class="line">int initlist(SqList &amp;L)</span><br><span class="line">//构造空表 </span><br><span class="line">&#123;</span><br><span class="line">	L.elem = new book[maxsize];</span><br><span class="line">	if(!L.elem)  exit(0);  //存储分配失败，不知为何，在这个地方用return -1会导致后续程序出错</span><br><span class="line">	L.len=0;</span><br><span class="line">	return 1; </span><br><span class="line">&#125; </span><br><span class="line">void menu()&#123;</span><br><span class="line">//菜单 </span><br><span class="line">	cout&lt;&lt;&quot;————&quot;&lt;&lt;&#x27;\n&#x27;&lt;&lt;&quot;menu&quot;&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;&quot;1.查找某本书&quot;&lt;&lt;&#x27;\n&#x27;&lt;&lt;&quot;2.添加新书&quot;&lt;&lt;&#x27;\n&#x27;&lt;&lt;&quot;3.删除某本书&quot;&lt;&lt;&#x27;\n&#x27;&lt;&lt;&quot;4.修改某本书的信息&quot;&lt;&lt;&#x27;\n&#x27;&lt;&lt; &quot;5.排序&quot;&lt;&lt;&#x27;\n&#x27;&lt;&lt;&quot;6.统计&quot;&lt;&lt;&#x27;\n&#x27;; </span><br><span class="line">	cout&lt;&lt;&quot;————&quot;&lt;&lt;endl; </span><br><span class="line">&#125;</span><br><span class="line">void Findno(SqList L)</span><br><span class="line">//查找书号 </span><br><span class="line">&#123;</span><br><span class="line">	char findno[20];</span><br><span class="line">	cin&gt;&gt;findno;</span><br><span class="line">	int joke=0;</span><br><span class="line">	cout&lt;&lt;&quot;图书编号&quot;&lt;&lt;setw(20)&lt;&lt;&quot;书名&quot;&lt;&lt;setw(30)&lt;&lt;&quot;价格&quot;&lt;&lt;endl;</span><br><span class="line">	for(int i=0;i&lt;L.len;i++)&#123;</span><br><span class="line">		if(strcmp(findno,L.elem[i].no)==0)&#123;</span><br><span class="line">			joke++;</span><br><span class="line">			cout&lt;&lt;L.elem[i].no&lt;&lt;setw(30)&lt;&lt;L.elem[i].name&lt;&lt;setw(30)&lt;&lt;L.elem[i].price&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if(joke==0) cout&lt;&lt;&quot;404 NOT FOUND&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">void Findname(SqList L)</span><br><span class="line">//查找书名</span><br><span class="line">&#123;</span><br><span class="line">	char findname[50];</span><br><span class="line">	cin&gt;&gt;findname;</span><br><span class="line">	int joke=0;</span><br><span class="line">	cout&lt;&lt;&quot;图书编号&quot;&lt;&lt;setw(20)&lt;&lt;&quot;书名&quot;&lt;&lt;setw(30)&lt;&lt;&quot;价格&quot;&lt;&lt;endl;</span><br><span class="line">	for(int i=0;i&lt;L.len;i++)&#123;</span><br><span class="line">	char *b=strstr(L.elem[i].name,findname);</span><br><span class="line">		if(b!=NULL)&#123;</span><br><span class="line">			joke++;</span><br><span class="line">			cout&lt;&lt;L.elem[i].no&lt;&lt;setw(30)&lt;&lt;L.elem[i].name&lt;&lt;setw(30)&lt;&lt;L.elem[i].price&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if(joke==0) cout&lt;&lt;&quot;404 NOT FOUND&quot;&lt;&lt;endl;</span><br><span class="line">	 </span><br><span class="line">&#125;</span><br><span class="line">void Findprice(SqList L)</span><br><span class="line">//查找价格 </span><br><span class="line">&#123;</span><br><span class="line">	float findprice;</span><br><span class="line">	cin&gt;&gt;findprice;</span><br><span class="line">	int joke=0;</span><br><span class="line">	cout&lt;&lt;&quot;图书编号&quot;&lt;&lt;setw(20)&lt;&lt;&quot;书名&quot;&lt;&lt;setw(30)&lt;&lt;&quot;价格&quot;&lt;&lt;endl;</span><br><span class="line">	for(int i=0;i&lt;L.len;i++)&#123;</span><br><span class="line">		if(findprice==L.elem[i].price)&#123;</span><br><span class="line">			joke++;</span><br><span class="line">			cout&lt;&lt;fixed&lt;&lt;setprecision(2);</span><br><span class="line">			cout&lt;&lt;L.elem[i].no&lt;&lt;setw(30)&lt;&lt;L.elem[i].name&lt;&lt;setw(30)&lt;&lt;L.elem[i].price&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if(joke==0) cout&lt;&lt;&quot;404 NOT FOUND&quot;&lt;&lt;endl;</span><br><span class="line">	 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int listinsert(SqList &amp;L,int newnumber)</span><br><span class="line">//添加新图书</span><br><span class="line">&#123;</span><br><span class="line">	if( (newnumber&gt;L.len+1) || (newnumber&lt;1) ) exit(0);</span><br><span class="line">	if(L.len==maxsize) exit(0);</span><br><span class="line">	for(int i=L.len-1;i&gt;=newnumber-1;i--)&#123;</span><br><span class="line">		L.elem[i+1]=L.elem[i]; //插入位置以后的元素后移一个单位</span><br><span class="line">	&#125;L.elem[newnumber-1]=L.elem[maxsize-1];</span><br><span class="line">	L.len++;</span><br><span class="line">	return 1;</span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> void listdelete(SqList &amp;L)</span><br><span class="line"> //删除一本书</span><br><span class="line"> &#123;</span><br><span class="line">    int deletedata;</span><br><span class="line"> 	char findnoname[50];</span><br><span class="line">	cin&gt;&gt;findnoname;</span><br><span class="line">	int joke=0;</span><br><span class="line">	char* a;</span><br><span class="line">	cout&lt;&lt;&quot;图书编号&quot;&lt;&lt;setw(20)&lt;&lt;&quot;书名&quot;&lt;&lt;setw(30)&lt;&lt;&quot;价格&quot;&lt;&lt;endl;</span><br><span class="line">	for(int i=0;i&lt;L.len;i++)&#123;</span><br><span class="line">		a=strstr(L.elem[i].name,findnoname);</span><br><span class="line">		if(strcmp(findnoname,L.elem[i].no)==0)&#123;</span><br><span class="line">			joke++;</span><br><span class="line">			cout&lt;&lt;L.elem[i].no&lt;&lt;setw(30)&lt;&lt;L.elem[i].name&lt;&lt;setw(30)&lt;&lt;L.elem[i].price&lt;&lt;endl;</span><br><span class="line">			deletedata=i+1;</span><br><span class="line">		&#125;</span><br><span class="line">		if(a!=NULL)&#123;</span><br><span class="line">			joke++;</span><br><span class="line">			cout&lt;&lt;L.elem[i].no&lt;&lt;setw(30)&lt;&lt;L.elem[i].name&lt;&lt;setw(30)&lt;&lt;L.elem[i].price&lt;&lt;endl;</span><br><span class="line">			deletedata=i+1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if(joke==0) cout&lt;&lt;&quot;404 NOT FOUND&quot;&lt;&lt;endl;</span><br><span class="line"> 	</span><br><span class="line"></span><br><span class="line"> 	if((deletedata&lt;1) || (deletedata&gt;L.len)) exit(0);</span><br><span class="line"> 	for(int i=deletedata;i&lt;L.len;i++)&#123;</span><br><span class="line"> 		L.elem[i-1]=L.elem[i]; //对i所在的位置删除数据后，进行前移，前一个元素等于后一个元素 </span><br><span class="line"> 	 &#125;L.len--;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> int doinglist(SqList &amp;L)</span><br><span class="line"> //修改顺序表信息 </span><br><span class="line"> &#123;</span><br><span class="line"> 	cout&lt;&lt;&quot;请输入书籍编号&quot;&lt;&lt;endl;</span><br><span class="line">	char findno[20];</span><br><span class="line">	cin&gt;&gt;findno;</span><br><span class="line">	int joke=0;</span><br><span class="line">	int doing;</span><br><span class="line">	for(int i=0;i&lt;L.len;i++)&#123;</span><br><span class="line">		if(strcmp(findno,L.elem[i].no)==0)&#123;</span><br><span class="line">			joke++;</span><br><span class="line">			cout&lt;&lt;&quot;获取书籍信息成功！&quot;&lt;&lt;endl;</span><br><span class="line">			cout&lt;&lt;&quot;图书编号&quot;&lt;&lt;setw(20)&lt;&lt;&quot;书名&quot;&lt;&lt;setw(30)&lt;&lt;&quot;价格&quot;&lt;&lt;endl;</span><br><span class="line">			cout&lt;&lt;fixed&lt;&lt;setprecision(2);</span><br><span class="line">			cout&lt;&lt;L.elem[i].no&lt;&lt;setw(30)&lt;&lt;L.elem[i].name&lt;&lt;setw(30)&lt;&lt;L.elem[i].price&lt;&lt;endl;</span><br><span class="line">			while(1)&#123;</span><br><span class="line">				cout&lt;&lt;&quot;请输入（0-3）：1.修改书籍编号 2.修改书名 3.修改书的价格 0.退出修改&quot;&lt;&lt;endl;</span><br><span class="line">				cin&gt;&gt;doing;</span><br><span class="line">				switch(doing)&#123;</span><br><span class="line">					case 1:&#123;</span><br><span class="line">						cout&lt;&lt;&quot;请输入新书籍编号：&quot;&lt;&lt;endl;</span><br><span class="line">						char newno[20];</span><br><span class="line">						cin&gt;&gt;newno;</span><br><span class="line">						strcpy(L.elem[i].no,newno); </span><br><span class="line">						break;</span><br><span class="line">					&#125;</span><br><span class="line">					case 2:&#123;</span><br><span class="line">						cout&lt;&lt;&quot;请输入新书名：&quot;&lt;&lt;endl;</span><br><span class="line">						char newname[50];</span><br><span class="line">						cin&gt;&gt;newname;</span><br><span class="line">						strcpy(L.elem[i].name,newname); </span><br><span class="line">						break;</span><br><span class="line">					&#125;</span><br><span class="line">					case 3:&#123;</span><br><span class="line">						cout&lt;&lt;&quot;请输入新价格：&quot;&lt;&lt;endl;</span><br><span class="line">						float newprice;</span><br><span class="line">						cin&gt;&gt;newprice;</span><br><span class="line">						L.elem[i].price=newprice;</span><br><span class="line">						break;</span><br><span class="line">					&#125;</span><br><span class="line">					case 0:&#123;</span><br><span class="line">					system(&quot;pause&quot;);</span><br><span class="line">				    system(&quot;cls&quot;);</span><br><span class="line">				    return 0;</span><br><span class="line">					&#125;break;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> &#125;</span><br><span class="line"> void talllist(SqList &amp;L)</span><br><span class="line"> //选择排序法 </span><br><span class="line"> &#123;</span><br><span class="line"> 	int max;  </span><br><span class="line">    for(int i=0;i&lt;L.len-1;i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        max=i;  </span><br><span class="line">        for(int j=i;j&lt;L.len;j++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            if(L.elem[max].price &gt; L.elem[j].price)  //本质是索引为i和i+1 的结构体成员在做比较，这种写法可以保证不漏掉每一组比较 </span><br><span class="line">                max=j;  </span><br><span class="line">        &#125;  </span><br><span class="line">        L.elem[L.len+1] = L.elem[i];  //用一个在顺序表外面的位置储存旧值，暂时没想到其他好的办法 </span><br><span class="line">        L.elem[i] = L.elem[max];  </span><br><span class="line">        L.elem[max] = L.elem[L.len+1] ;</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br><span class="line"> void readlist(SqList L)&#123;</span><br><span class="line"> 	cout&lt;&lt;&quot;图书编号&quot;&lt;&lt;setw(20)&lt;&lt;&quot;书名&quot;&lt;&lt;setw(30)&lt;&lt;&quot;价格&quot;&lt;&lt;endl;</span><br><span class="line"> 	for(int i=0;i&lt;L.len;i++)&#123;</span><br><span class="line"> 		cout&lt;&lt;fixed&lt;&lt;setprecision(2);</span><br><span class="line"> 		cout&lt;&lt;L.elem[i].no&lt;&lt;setw(30)&lt;&lt;L.elem[i].name&lt;&lt;setw(30)&lt;&lt;L.elem[i].price&lt;&lt;endl;</span><br><span class="line">	 &#125;</span><br><span class="line"> &#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	SqList L;</span><br><span class="line">	initlist(L); //顺序表的初始化 </span><br><span class="line">	FILE *fp=NULL;</span><br><span class="line">	FILE *fp1=NULL;</span><br><span class="line">	fp=fopen(&quot;information.txt&quot;,&quot;r&quot;);//r打开只读文件 </span><br><span class="line">	if(fp==NULL)&#123;</span><br><span class="line">	cout&lt;&lt;&quot;文件读取无效&quot;&lt;&lt;endl;</span><br><span class="line">	exit(0); </span><br><span class="line">	&#125;</span><br><span class="line">	int i=0;</span><br><span class="line">	while(!feof(fp))&#123;</span><br><span class="line">        fscanf(fp, &quot;%s %s %f\n&quot;, L.elem[i].no,L.elem[i].name,&amp;L.elem[i].price);//字符变量不需要加&amp;指向地址，%s忽略字符串前一个空格 </span><br><span class="line">		i++;</span><br><span class="line">	&#125; </span><br><span class="line">	L.len=i+1; </span><br><span class="line">	fclose(fp);//关闭文件 </span><br></pre></td></tr></table></figure>

<p>​	</p>
<pre><code>while(1)&#123;
    menu(); 
    int choose;
    int find;
    string yes;
    cin&gt;&gt;choose; 
    switch(choose)&#123;
        case 1:&#123;
            cout&lt;&lt;&quot;请选择（0-3）：1.按图书编号查找 2.按书名查找 3.按价格查找 0.退出&quot;&lt;&lt;endl;
            cin&gt;&gt;find;
            if(find==1) Findno(L);
            if(find==2) Findname(L);
            if(find==3) Findprice(L);
            break;
        &#125;
        case 2:&#123;
            int newnumber;
            cout&lt;&lt;&quot;请输入：添加新图书至第__位(按0退出)&quot;&lt;&lt;endl;
            cin&gt;&gt;newnumber;
            if(newnumber!=0)&#123;
                cin&gt;&gt;L.elem[maxsize-1].no&gt;&gt;L.elem[maxsize-1].name&gt;&gt;L.elem[maxsize-1].price;
                listinsert(L,newnumber);
                cout&lt;&lt;&quot;添加成功！是否查看？Y/N&quot;&lt;&lt;endl;
                cin&gt;&gt;yes;
                if(yes==&quot;Y&quot;) readlist(L);
                if(yes==&quot;N&quot;) break;
            &#125;
            break;
        &#125;
        case 3:&#123;
            cout&lt;&lt;&quot;请选择（0-2）：1.输入图书编号并删除该书 2.输入书名并删除该书 0.退出&quot;&lt;&lt;endl;
            cin&gt;&gt;find;
            if(find==1) &#123;
            cout&lt;&lt;&quot;正在查询你想删除的书...&quot;&lt;&lt;endl; 
            listdelete(L); 
            cout&lt;&lt;&quot;删除完成！请查看：&quot;&lt;&lt;endl; 
            readlist(L);
            &#125;
            if(find==2)&#123;
            cout&lt;&lt;&quot;查找到你想删除的书是：&quot;&lt;&lt;endl; 	
            listdelete(L);
            cout&lt;&lt;&quot;删除完成！请查看：&quot;&lt;&lt;endl; 
            readlist(L);
         	&#125;
            break;
        &#125;
        case 4:&#123;
            cout&lt;&lt;&quot;请选择（0-1）：1.输入图书编号并修改该书信息  0.退出&quot;&lt;&lt;endl;
            cin&gt;&gt;find;
            if(find==1) doinglist(L);
            break;
        &#125;
        case 5:&#123;
            cout&lt;&lt;&quot;请选择（0-1）：1.按价格升序排序  0.退出&quot;&lt;&lt;endl;
            cin&gt;&gt;find;
            if(find==1)&#123;
                talllist(L);
                readlist(L);
            &#125;
            break;
        &#125;
        case 6:&#123;
            cout&lt;&lt;&quot;本系统目前共收录&quot;&lt;&lt;L.len-1&lt;&lt;&quot;本书&quot;&lt;&lt;endl; 
            float sum=0;
            for(int i=0;i&lt;L.len;i++)&#123;
                sum+=L.elem[i].price;
            &#125;
            cout&lt;&lt;fixed&lt;&lt;setprecision(2);
            cout&lt;&lt;&quot;价值约&quot;&lt;&lt; sum&lt;&lt;&quot;元&quot;&lt;&lt;endl; 
            break;
        &#125;
    &#125;
fp1=fopen(&quot;information2.txt&quot;,&quot;w+&quot;);//w+打开可读写文件，若不存在则建立，若存在则清空并覆盖 
if(fp==NULL)&#123;
cout&lt;&lt;&quot;文件写入无效&quot;&lt;&lt;endl;
exit(0); 
&#125;
for(i=0;i&lt;L.len;i++)&#123;
    fprintf(fp1,&quot;%s %s %.2f\n&quot;,L.elem[i].no,L.elem[i].name,L.elem[i].price);
&#125;
fclose(fp1);//关闭文件 

system(&quot;pause&quot;);
system(&quot;cls&quot;);

&#125;
return 0;
&#125;
</code></pre>
]]></content>
      <tags>
        <tag>数据结构笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>高等数学下笔记</title>
    <url>/2024/03/25/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#8-%E5%90%91%E9%87%8F%E4%BB%A3%E6%95%B0%E4%B8%8E%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95">8 - 向量代数与空间解析几何</a><ul>
<li><a href="#8-1-%E5%90%91%E9%87%8F%E5%8F%8A%E5%85%B6%E7%BA%BF%E6%80%A7%E8%BF%90%E7%AE%97">8-1 向量及其线性运算</a></li>
<li><a href="#8-2-%E7%A9%BA%E9%97%B4%E7%9B%B4%E8%A7%92%E5%9D%90%E6%A0%87%E7%B3%BB">8-2 空间直角坐标系</a></li>
<li><a href="#8-3-%E5%90%91%E9%87%8F%E7%9A%84%E7%BB%BC%E5%90%88%E6%80%A7%E8%B4%A8%E5%92%8C%E8%BF%90%E7%AE%97">8-3 向量的综合性质和运算</a></li>
<li><a href="#8-4-%E6%95%B0%E9%87%8F%E7%A7%AF-%E5%90%91%E9%87%8F%E7%A7%AF">8-4 数量积、向量积</a></li>
<li><a href="#8-5-%E5%B9%B3%E9%9D%A2%E5%8F%8A%E5%85%B6%E6%96%B9%E7%A8%8B">8-5 平面及其方程</a></li>
<li><a href="#8-6-%E7%A9%BA%E9%97%B4%E7%9B%B4%E7%BA%BF%E5%8F%8A%E5%85%B6%E6%96%B9%E7%A8%8B">8-6 空间直线及其方程</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<p>[TOC]</p>
<h2><span id="8-向量代数与空间解析几何">8 - 向量代数与空间解析几何</span></h2><h3><span id="8-1-向量及其线性运算">8-1 向量及其线性运算</span></h3><p>1.由三角形两边之和大于第三边，有：|<strong>a</strong> + <strong>b</strong>|&lt;&#x3D;|<strong>a</strong>|+|<strong>b</strong>|; |<strong>a</strong> - <strong>b</strong>|&lt;&#x3D;|<strong>a</strong>|+|<strong>b</strong>|</p>
<p>2.数乘：|λ<strong>a</strong>| &#x3D; |λ||<strong>a</strong>|</p>
<p>3.单位向量<strong>e</strong>&#x3D;<strong>a</strong>&#x2F;|<strong>a</strong>|</p>
<p>4.<strong>a</strong>&#x2F;&#x2F;<strong>b</strong>等价于<strong>b</strong>&#x3D;λ<strong>a</strong>（<strong>a</strong>!&#x3D;0）</p>
<h3><span id="8-2-空间直角坐标系">8-2 空间直角坐标系</span></h3><img src="/2024/03/25/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8B%E7%AC%94%E8%AE%B0/be8b438d8dab4f26425537c8e52ffa4.png" alt="be8b438d8dab4f26425537c8e52ffa4" style="zoom:80%;">

<img src="/2024/03/25/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8B%E7%AC%94%E8%AE%B0/ed720f4486e49cb4f94f47c876630bf.png" alt="ed720f4486e49cb4f94f47c876630bf" style="zoom:80%;">

<p>向量OF（x，y，z）是点O关于点F的向径，<u>求点F的坐标就是求向量OP的坐标</u></p>
<p>①若点F在yoz面上，x&#x3D;0；</p>
<p>②点F在zox面上，y&#x3D;0；点F在xoy面上，z&#x3D;0；</p>
<p>③点F在x轴上，y&#x3D;z&#x3D;0；</p>
<p>④点F在y轴上，z&#x3D;x&#x3D;0；点F在z轴上，x&#x3D;y&#x3D;0；</p>
<p>⑤点F为原点，x&#x3D;y&#x3D;z&#x3D;0。</p>
<h3><span id="8-3-向量的综合性质和运算">8-3 向量的综合性质和运算</span></h3><img src="/2024/03/25/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8B%E7%AC%94%E8%AE%B0/微信截图_20240326011004.png" alt="微信截图_20240326011004" style="zoom:80%;">

<h4><span id="题型"><strong>题型：</strong></span></h4><h5><span id="1向量模的坐标表达式">1.向量模的坐标表达式</span></h5><h5><span id="2两点距离公式">2.两点距离公式：</span></h5><p>求证三角形的类型（等腰、直角、等边）</p>
<p>求已知向量的定向单位向量</p>
<p>求与某几点等距离的点</p>
<h5><span id="3方向角与方向余弦">3.方向角与方向余弦：</span></h5><p>已知角度求点的坐标</p>
<p>已知向量求方向角、余弦和模</p>
<h5><span id="4投影">4.投影</span></h5><p>已知向量求向量在某轴上的投影</p>
<p>已知投影求向量</p>
<h3><span id="8-4-数量积-向量积">8-4 数量积、向量积</span></h3><img src="/2024/03/25/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8B%E7%AC%94%E8%AE%B0/微信截图_20240326013200.png" alt="微信截图_20240326013200" style="zoom:80%;">

<h4><span id="题型"><strong>题型</strong>：</span></h4><p>1.用数量积公式求夹角、投影</p>
<p>2.用向量积求三角形面积（用到正弦）</p>
<p>3.用数量积、向量积定义证垂直或平行</p>
<p>4.（多用）用向量积求平面方程</p>
<h3><span id="8-5-平面及其方程">8-5 平面及其方程</span></h3><h4><span id="1平面的点法式方程">1.平面的点法式方程</span></h4><p><strong>A（x-x₀）+B（y-y₀）+C（z-z₀）&#x3D;0</strong></p>
<p>其中<strong>n</strong>&#x3D;（A,B,C），M₀&#x3D;（x₀，y₀，z₀）</p>
<h4><span id="2平面的一般方程">2.平面的一般方程</span></h4><p><strong>Ax0 + By0 + Cz0 +D&#x3D;0</strong></p>
<p><strong>n</strong>&#x3D;（A,B,C）</p>
<p>①<strong>D&#x3D;0</strong>时，方程表示一个通过<strong>原点</strong>的平面</p>
<p>②<strong>A&#x3D;0</strong>时，<strong>n</strong>垂直于x轴，方程表示一个平行于（或包含）<strong>x轴</strong>的平面；<strong>B&#x3D;0，C&#x3D;0</strong>同理</p>
<p>③<strong>A&#x3D;B&#x3D;0</strong>，<strong>n</strong>同时垂直x轴和y轴，方程表示一个平行于（或重合）<strong>x0y面</strong>的平面；<strong>A&#x3D;C&#x3D;0,B&#x3D;C&#x3D;0</strong>同理</p>
<h4><span id="3平面的截距式方程">3.平面的截距式方程</span></h4><p><strong>x&#x2F;a + y&#x2F;b + z&#x2F;c &#x3D; 1</strong></p>
<p>a、b、c分别是平面在xyz轴上的截距</p>
<h4><span id="4两平面夹角-点到平面距离">4.两平面夹角、点到平面距离</span></h4><p><strong>两平面互相垂直</strong>相当于<strong>A₁A₂ + B₁B₂ + C₁C₂ &#x3D; 0</strong></p>
<p><strong>两平面互相平行或重合</strong>相当于<strong>A₁&#x2F;A₂ &#x3D; B₁&#x2F;B₂ &#x3D; C₁&#x2F;C₂</strong></p>
<img src="/2024/03/25/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8B%E7%AC%94%E8%AE%B0/微信截图_20240326015143.png" alt="微信截图_20240326015143" style="zoom:80%;">



<h3><span id="8-6-空间直线及其方程">8-6 空间直线及其方程</span></h3><h4><span id="1直线的点向式方程对称式方程">1.直线的点向式方程（对称式方程）</span></h4><p>其中，<strong>s</strong>&#x3D;(m,n,p)，M₀&#x3D;(x₀,y₀,z₀)</p>
<p>要素：①方向向量 ②点</p>
<h4><span id="2直线的参数方程">2.直线的参数方程</span></h4><h4><span id="3直线的一般方程">3.直线的一般方程</span></h4><p>表现为两个平面的交线</p>
<h4><span id="4线面角">4.线面角</span></h4><p>范围是【0，90°】</p>
<img src="/2024/03/25/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8B%E7%AC%94%E8%AE%B0/微信截图_20240326015259.png" alt="微信截图_20240326015259" style="zoom:80%;">

<h4><span id="5线线角">5.线线角</span></h4><p>和面面角公式相同，用cos</p>
<h4><span id="6性质">6.性质</span></h4><p><strong>两直线相互垂直（包括异面、相交）</strong>相当于 <strong>m₁m₂ + n₁n₂ + p₁p₂ &#x3D; 0</strong></p>
<p><strong>两直线互相平行或重合</strong> 相当于 <strong>m₁&#x2F;m₂ &#x3D; n₁&#x2F;n₂ &#x3D; p₁&#x2F;p₂</strong></p>
<p><strong>直线与平面平行或直线在平面上</strong> 相当于 <strong>Am + Bn + Cp &#x3D;0</strong></p>
]]></content>
      <tags>
        <tag>高等数学</tag>
      </tags>
  </entry>
  <entry>
    <title>电路的一般分析方法</title>
    <url>/2024/03/14/%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#%E7%94%B5%E8%B7%AF%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%AE%9A%E5%BE%8B">电路的基本概念和基本定律</a><ul>
<li><a href="#1%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8F%98%E9%87%8F">1.电路分析的基本变量</a></li>
<li><a href="#2%E5%9F%BA%E5%B0%94%E9%9C%8D%E5%A4%AB%E5%AE%9A%E5%BE%8B">2.基尔霍夫定律</a></li>
<li><a href="#3%E7%94%B5%E8%B7%AF%E5%85%83%E4%BB%B6">3.电路元件</a></li>
</ul>
</li>
<li><a href="#%E7%94%B5%E9%98%BB%E7%94%B5%E8%B7%AF%E7%9A%84%E4%B8%80%E8%88%AC%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95">电阻电路的一般分析方法</a><ul>
<li><a href="#%E7%AD%89%E6%95%88%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90%E6%B3%95">等效电路分析法</a></li>
<li><a href="#%E7%BD%91%E5%AD%94%E5%88%86%E6%9E%90%E6%B3%95%E4%BE%8B%E9%A2%98p39">网孔分析法（例题p39)</a></li>
<li><a href="#%E8%8A%82%E7%82%B9%E5%88%86%E6%9E%90%E6%B3%95">节点分析法</a></li>
<li><a href="#%E5%BC%A5%E5%B0%94%E6%9B%BC%E5%AE%9A%E7%90%86">弥尔曼定理</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<p>[TOC]</p>
<h2><span id="电路的基本概念和基本定律">电路的基本概念和基本定律</span></h2><h3><span id="1电路分析的基本变量">1.电路分析的基本变量</span></h3><h4><span id="1电流">（1）电流</span></h4><ul>
<li><input disabled type="checkbox"> <strong>电流</strong>：是电路中电荷流动量的度量，它代表单位时间流过电路中某一截面的净电荷量。</li>
<li><input disabled type="checkbox"> 习惯上把正电荷移动的方向规定为电流方向。</li>
<li><input disabled type="checkbox"> 1A &#x3D; 10³mA &#x3D; 10⁶μA</li>
<li><input disabled type="checkbox"> 恒定电流&#x2F;<strong>直流</strong>的大小和方向不随时间变化，用<strong>I</strong>表示；交变电流&#x2F;<strong>交流</strong>用<strong>i</strong>表示。</li>
<li><input disabled type="checkbox"> 如果电流的真实方向和参考方向一致，电流为正值。</li>
</ul>
<h4><span id="2电压">（2）电压</span></h4><ul>
<li><input disabled type="checkbox"> <strong>电压</strong>：电路中两点之间的电位差。(规定电位下降的方向为电压的真实方向)</li>
<li><input disabled type="checkbox"> <strong>电位</strong>：描述电路中电位能分布的物理量。如果正电荷由a点转移到b点时获得能量，则a点为低电位（负极），b点为高电位（正极）。</li>
<li><input disabled type="checkbox"> <strong>电压降</strong>：电压Uab表示单位正电荷从a点移动到b点所失去的电位能。</li>
<li><input disabled type="checkbox"> <strong>参考点</strong>：又叫“零电位点”，此处的电压为0，用<strong>⊥</strong>表示。</li>
<li><input disabled type="checkbox"> 符号：U</li>
<li><input disabled type="checkbox"> 单位：<strong>伏特（V）</strong></li>
</ul>
<p><img src="/2024/03/14/%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E7%AC%94%E8%AE%B0/26b97bbf08071e65df06f449d76d53a.png" alt="26b97bbf08071e65df06f449d76d53a"></p>
<h4><span id="3电功率">（3）电功率</span></h4><ul>
<li><input disabled type="checkbox"> <strong>电功率</strong>：是电路元件消耗电能快慢的度量，它表示单位时间内电路元件消耗的电场能量。</li>
<li><input disabled type="checkbox"> 符号：p或p(t)</li>
<li><input disabled type="checkbox"> 单位：<strong>瓦特（W）</strong></li>
<li><input disabled type="checkbox"> 公式：<strong>p&#x3D; dw&#x2F;dt &#x3D; ui; P&#x3D;UI;</strong>  (非关联参考方向：p&#x3D;-ui或P&#x3D;-UI)</li>
<li><input disabled type="checkbox"> <strong>功率平衡原理</strong>：电路中所有元件的功率之和为0（即能量守恒）。</li>
<li><input disabled type="checkbox"> 当p&gt;0，p是元件的吸收功率；p&lt;0，元件向外部电路提供功率。</li>
</ul>
<h4><span id="4电阻">（4）电阻</span></h4><ul>
<li><p><input disabled type="checkbox"> 
伏安特性：欧姆定律。</p>
</li>
<li><p><input disabled type="checkbox"> 
符号：R</p>
</li>
<li><p><input disabled type="checkbox"> 
单位：<strong>欧姆(Ω)</strong></p>
</li>
<li><p><input disabled type="checkbox"> 
“电阻值”公式：<strong>R &#x3D;U &#x2F; I</strong>（或R&#x3D;-U&#x2F;I）</p>
</li>
<li><p><input disabled type="checkbox"> 
“电阻元件功率”计算公式：<strong>PR &#x3D; U * I &#x3D; R * i2 &#x3D; U2 &#x2F; R</strong></p>
<p><img src="/2024/03/14/%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E7%AC%94%E8%AE%B0/d9bd6db9355927a8f2d38264806ee63.png" alt="d9bd6db9355927a8f2d38264806ee63"></p>
</li>
</ul>
<h4><span id="5电导">（5）电导</span></h4><ul>
<li><input disabled type="checkbox"> 符号：G</li>
<li><input disabled type="checkbox"> 公式：<strong>G&#x3D;1&#x2F;R，U&#x3D;1&#x2F;G，I&#x3D;GU</strong></li>
<li><input disabled type="checkbox"> 单位：<strong>西门子（S）</strong></li>
<li><input disabled type="checkbox"> 电阻元件可以用电导来表征。</li>
<li><input disabled type="checkbox"> G→0，R→∞</li>
</ul>
<h3><span id="2基尔霍夫定律">2.基尔霍夫定律</span></h3><h4><span id="1术语">（1）术语</span></h4><ul>
<li><input disabled type="checkbox"> 节点：两条或两条以上的连接点。</li>
<li><input disabled type="checkbox"> 回路：电路中任一闭合的路径。</li>
<li><input disabled type="checkbox"> 网孔：回路内部中不含支路的回路。</li>
<li><input disabled type="checkbox"> 网络：含元件较多的电路。</li>
</ul>
<h4><span id="2基尔霍夫电流定律kcl">（2）基尔霍夫电流定律（KCL）：</span></h4><p>在任意时刻流进<strong>任意一个结点</strong>的所有支路电流的代数和总是为零。</p>
<p>即：流出&#x3D;流入。</p>
<p>KCL是运用于电路中节点的，也可以将其推广运用到电路的一个封闭面。</p>
<h4><span id="3基尔霍夫电压定律kvl">（3）基尔霍夫电压定律（KVL）：</span></h4><p>在任意时刻绕<strong>任意一个回路</strong>一周所有支路电压的代数和总是为零。</p>
<p><img src="/2024/03/14/%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E7%AC%94%E8%AE%B0/895aa3a1c25920a4277fa7b3db697b3.png" alt="895aa3a1c25920a4277fa7b3db697b3"></p>
<h3><span id="3电路元件">3.电路元件</span></h3><p>电路元件是实际电器元件的理想化模型，是构成电路的基本单元。</p>
<p>从元件对能量的表现划分为：耗能元件（电阻元件），供能元件（独立电源），储能元件，能量控制元件。</p>
<h4><span id="1电阻元件">（1）电阻元件</span></h4><p>分为线性电阻和非线性电阻。</p>
<h4><span id="2供能元件">（2）供能元件</span></h4><p>①<strong>理想电压源</strong></p>
<ul>
<li><p><strong>理想电压源</strong>：二端元件两端电压不随流过它的电流变化，保持固定的数值&#x2F;变化规律。</p>
</li>
<li><p>“理想电压源”的<strong>伏安特性</strong>： 一条平行于电流轴的直线。</p>
</li>
<li><p>流过理想电压源的电流，是由与之相连接的外部电路来决定的。</p>
</li>
</ul>
<p><img src="/2024/03/14/%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E7%AC%94%E8%AE%B0/cc334c63dede1974a4ab95262f2535d.png" alt="cc334c63dede1974a4ab95262f2535d"></p>
<p>②<strong>理想电流源</strong></p>
<ul>
<li><strong>理想电流源</strong>：二端元件两端电源不随流过它的电压变化，保持固定的数值&#x2F;变化规律。</li>
<li>“理想电流源”的<strong>伏安特性</strong>： 一条平行于电压轴的直线。</li>
<li>理想电流源的端电压，是由与之相连接的外部电路决定的。</li>
</ul>
<p><img src="/2024/03/14/%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E7%AC%94%E8%AE%B0/b2940520b48402f779fb7a04f351340.png" alt="b2940520b48402f779fb7a04f351340"></p>
<h4><span id="3电容元件例题p19-p20">（3）电容元件（例题p19、p20）</span></h4><ul>
<li><input disabled type="checkbox"> 电容器是一种能储存电场能量的部件。</li>
<li><input disabled type="checkbox"> <strong>电容元件</strong>：指存储在极板上的“电荷量 q ”与两极板之间的“电压 u ”的代数关系。</li>
<li><input disabled type="checkbox"> 符号：<strong>C（电容量）</strong></li>
<li><input disabled type="checkbox"> 单位：<strong>法拉（F）</strong></li>
<li><input disabled type="checkbox"> 公式：<strong>1F &#x3D; 1C &#x2F; 1V</strong>，**<u>i(t)&#x3D;C<em>du(t)&#x2F;dt</em></u><strong>，</strong>w&#x3D;1&#x2F;2C<em>u²(t)</em></li>
<li><input disabled type="checkbox"> 电容器两端的电压不可能发生跃变（电流→∞）而只能是连续变化的。电容器C在某一时刻的储能只取决于该时刻的电容电压值。</li>
</ul>
<p><img src="/2024/03/14/%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E7%AC%94%E8%AE%B0/2a28d4d268fadbec868ec19c0631fa2.png" alt="2a28d4d268fadbec868ec19c0631fa2"></p>
<ul>
<li><input disabled type="checkbox"> 两电容器的并联：等效电容量&#x3D;两电容量之和。C&#x3D;C1+C2。</li>
</ul>
<p>相当于电容极板面积增大。</p>
<ul>
<li><input disabled type="checkbox"> 两电容器的串联：两电容倒数之和&#x3D;等效电容量的倒数。1&#x2F;C&#x3D;1&#x2F;C1 + 1&#x2F;C2 。</li>
</ul>
<h4><span id="4电感元件例题p23">（4）电感元件（例题p23）</span></h4><ul>
<li><input disabled type="checkbox"> <strong>电感</strong>：流过线圈的“磁通量”与流过线圈的“电流 i ”的代数关系。</li>
<li><input disabled type="checkbox"> 电感元件的原型：空心线圈。</li>
<li><input disabled type="checkbox"> 符号：<strong>L（电感量）</strong></li>
<li><input disabled type="checkbox"> 单位：<strong>亨利（H）</strong></li>
<li><input disabled type="checkbox"> 公式：**<u>u&#x3D;L*di&#x2F;dt</u><strong>（i对t求导），</strong>wL&#x3D;1&#x2F;2Li²(t)**</li>
</ul>
<p><img src="/2024/03/14/%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E7%AC%94%E8%AE%B0/d86662a10020fea5a2b57a231223f5e.png" alt="d86662a10020fea5a2b57a231223f5e"></p>
<ul>
<li><input disabled type="checkbox"> 电感的串联：等效电感量&#x3D;两电感之和。L&#x3D;L1+L2。</li>
</ul>
<p>相当于线圈的匝数增多。</p>
<ul>
<li><input disabled type="checkbox"> 电感的并联：两电感倒数之和&#x3D;等效电感量的倒数。L&#x3D;1&#x2F;L1 + 1&#x2F;L2。</li>
<li><input disabled type="checkbox"> 电感中电流不能发生跃变。</li>
</ul>
<p><img src="/2024/03/14/%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E7%AC%94%E8%AE%B0/69732c59464c97ef9824e0b9011a78f.png" alt="69732c59464c97ef9824e0b9011a78f"></p>
<h4><span id="5控能元件受控电源">（5）控能元件——受控电源</span></h4><p>①VCVS：电压控制电压源</p>
<p>②CCVS：电流控制电压源</p>
<p>③VCCS：电压控制电流源</p>
<p>④CCCS：电流控制电流源</p>
<p><img src="/2024/03/14/%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E7%AC%94%E8%AE%B0/14e0a9a236d237b6ec38351e0eded56.png" alt="14e0a9a236d237b6ec38351e0eded56"></p>
<p>理想：对<strong>受控电压源</strong>来说，其输出电阻为0；对<strong>受控电流源</strong>来说，其输出电阻为无限大。对<strong>电压控制的受控源</strong>来说，其输入电阻为无限大；对<strong>电流控制的受控源</strong>来说，其输入电阻为0。</p>
<p><u>在电路分析时，受控源可看作独立电源，然后进行电源的等效变换。</u></p>
<p><img src="/2024/03/14/%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E7%AC%94%E8%AE%B0/bcc8038ff63ca6cb7d0fee91f5653a7.png" alt="bcc8038ff63ca6cb7d0fee91f5653a7"></p>
<h2><span id="电阻电路的一般分析方法">电阻电路的一般分析方法</span></h2><h3><span id="等效电路分析法">等效电路分析法</span></h3><h4><span id="1电源模型的等效互换">1.电源模型的等效互换</span></h4><p>电源等效互换的依据是电源的外特性相同。</p>
<p><img src="/2024/03/14/%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E7%AC%94%E8%AE%B0/132db370bc2f286ff83b54d52a9a3b2.png" alt="132db370bc2f286ff83b54d52a9a3b2"></p>
<p>（1）<strong>等效电路</strong>：两个电路具有完全相同的“对外连接端”，两者分别和任意其他的电路成分构成完整电路，如果电路的其它部分工作完全一致，则这两个电路互为<strong>等效电路</strong>。</p>
<p>（2）电路外特性：电路外接端上的电压与电流之间的关系。每个元件可视为一个电路部分，它的特性即是<strong>外特性</strong>。</p>
<p>电路中的一部分用其等效电路替换后，电路其它部分的工作情况保持不变；等效只能适合用于外部，对于互相等效的两个电路内部工作一般是不等效的。</p>
<h4><span id="2电阻的串联和并联">2.电阻的串联和并联</span></h4><p>（1）<strong>串联</strong></p>
<ul>
<li><strong>“电阻串联”等效为“单个电阻元件”</strong>；</li>
<li>两个电阻串联的等效条件：<strong>R &#x3D; R1 + R2</strong>；</li>
</ul>
<p><img src="/2024/03/14/%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E7%AC%94%E8%AE%B0/59e11257ee94fbad7830734dc0360eb.png" alt="59e11257ee94fbad7830734dc0360eb"></p>
<p>（2）<strong>并联</strong></p>
<ul>
<li><strong>“电阻并联”也等效为“单个电阻元件”</strong>；</li>
<li>两个电阻并联的等效条件： <strong>G &#x3D; G1 + G2</strong> 或 <strong>R &#x3D; R1 * R2 &#x2F; R1 + R2</strong></li>
</ul>
<p><img src="/2024/03/14/%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E7%AC%94%E8%AE%B0/961340a8100133f28d58f7f3c92b046.png" alt="961340a8100133f28d58f7f3c92b046"></p>
<p>3.电阻的混联及Y-Δ等效变换</p>
<p><img src="/2024/03/14/%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E7%AC%94%E8%AE%B0/4444eafb8d5297a15e32c3fe4f04a1d.png" alt="4444eafb8d5297a15e32c3fe4f04a1d"></p>
<p><img src="/2024/03/14/%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E7%AC%94%E8%AE%B0/7c514345062324cc216b14a44f06b06.png" alt="7c514345062324cc216b14a44f06b06"></p>
<h3><span id="网孔分析法例题p39">网孔分析法（例题p39)</span></h3><ul>
<li>对支路电流法所列的方程中做如下处理，可得到网孔方程：<br>1）对每个网孔按顺时针方向设定一个网孔电流；<br>2）将各支路电流表示成网孔电流的叠加。</li>
<li>将含源支路转化为电压源U与电阻R串联的形式。</li>
<li>自电阻总是正的，而互电阻既可为正也可为负，取决于流过互电阻的两个网孔电流是否一致，一致时取正。</li>
</ul>
<p><img src="/2024/03/14/%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E7%AC%94%E8%AE%B0/e1ca0f90aaf322d807af84bad6afa0f.png" alt="e1ca0f90aaf322d807af84bad6afa0f"></p>
<h3><span id="节点分析法">节点分析法</span></h3><ul>
<li>选取参考节点如4，则节点4的电位为0，其他3个节点分别对参考节点的电位是U1，U2，U3，即为节点电位。</li>
<li>将含源支路转化为电流源I与电导G并联的形式。</li>
</ul>
<p><img src="/2024/03/14/%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E7%AC%94%E8%AE%B0/e11d4d54a9561856fb79a5ce741c6f9.png" alt="e11d4d54a9561856fb79a5ce741c6f9"></p>
<p><strong>总结：</strong>①网络的独立节点数少于网孔数，用节点分析法。</p>
<p>②已知的电源是电流源，用节点分析法；电源是电压源，用网孔分析法。</p>
<p>③网孔分析法只适合平面网络。</p>
<h3><span id="弥尔曼定理">弥尔曼定理</span></h3><p><img src="/2024/03/14/%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E7%AC%94%E8%AE%B0/55339e45bbf28eac69264f6abd4248b.png" alt="55339e45bbf28eac69264f6abd4248b"></p>
]]></content>
      <categories>
        <category>课堂笔记</category>
      </categories>
      <tags>
        <tag>电子电路基础</tag>
      </tags>
  </entry>
  <entry>
    <title>用链表实现交集和并集</title>
    <url>/2024/03/24/%E7%94%A8%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E4%BA%A4%E9%9B%86%E5%92%8C%E5%B9%B6%E9%9B%86/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#7-1-%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%BA%8F%E5%88%97%E7%9A%84%E4%BA%A4%E9%9B%86"><strong>7-1 两个有序链表序列的交集</strong></a><ul>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F">输入格式:</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F">输出格式:</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B">输入样例:</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B">输出样例:</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">代码实现：</a></li>
</ul>
</li>
<li><a href="#7-2-%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%BA%8F%E5%88%97%E7%9A%84%E5%90%88%E5%B9%B6"><strong>7-2 两个有序链表序列的合并</strong></a><ul>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-1">输入格式:</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-1">输出格式:</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B-1">输入样例:</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B-1">输出样例:</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1">代码实现：</a></li>
</ul>
</li>
<li><a href="#7-3-%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%90%88%E5%B9%B6%E6%96%B0%E8%A1%A8%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0"><strong>7-3 两个有序链表合并（新表不含重复元素）</strong></a><ul>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-2">输入格式:</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-2">输出格式:</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B-2">输入样例:</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B-2">输出样例:</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2">代码实现：</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<p>[TOC]</p>
<h2><span id="7-1-两个有序链表序列的交集"><strong>7-1 两个有序链表序列的交集</strong></span></h2><p>已知两个非降序链表序列S1与S2，设计函数构造出S1与S2的交集新链表S3。</p>
<h3><span id="输入格式">输入格式:</span></h3><p>输入分两行，分别在每行给出由若干个正整数构成的非降序序列，用−1表示序列的结尾（−1不属于这个序列）。数字用空格间隔。</p>
<h3><span id="输出格式">输出格式:</span></h3><p>在一行中输出两个输入序列的交集序列，数字间用空格分开，结尾不能有多余空格；若新链表为空，输出<code>NULL</code>。</p>
<h3><span id="输入样例">输入样例:</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 5 -1</span><br><span class="line">2 4 5 8 10 -1</span><br></pre></td></tr></table></figure>

<h3><span id="输出样例">输出样例:</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 5</span><br></pre></td></tr></table></figure>

<h3><span id="代码实现">代码实现：</span></h3><p>这段程序的通过难点主要在于关心交集为空的情况，分为两种：</p>
<p>①集合1和集合2之间最少有一个为空</p>
<p>②集合1和集合2不是空集，但是相同元素的个数为0</p>
<p>针对第二种情况，只需要设置一个计数器i&#x3D;0，当集合1的元素&#x3D;&#x3D;集合2的元素时，i++，若运行到循环结束，i仍然为0，说明得到的交集为空</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef struct LNode&#123;</span><br><span class="line">    int data;</span><br><span class="line">    struct LNode *next;</span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"></span><br><span class="line">int creatlist(LinkList &amp;S1,LinkList &amp;S2)&#123;</span><br><span class="line">    LNode *p1,*p2,*r;</span><br><span class="line">    p1=S1,p2=S2;</span><br><span class="line">    r=S1;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        p1=new LNode;</span><br><span class="line">        cin&gt;&gt;p1-&gt;data;</span><br><span class="line">        if(p1-&gt;data==-1) break;//在链表录入-1前结束循环</span><br><span class="line">        p1-&gt;next=NULL;</span><br><span class="line">        r-&gt;next=p1;</span><br><span class="line">        r=p1;</span><br><span class="line">    &#125;//尾插法</span><br><span class="line">    r=S2;//循环利用变量r</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        p2=new LNode;</span><br><span class="line">        cin&gt;&gt;p2-&gt;data;</span><br><span class="line">        if(p2-&gt;data==-1) break;</span><br><span class="line">        p2-&gt;next=NULL;</span><br><span class="line">        r-&gt;next=p2;</span><br><span class="line">        r=p2;</span><br><span class="line">    &#125;//尾插法</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int jiaoji(LinkList &amp;S1,LinkList &amp;S2)&#123;</span><br><span class="line">    LNode *S3,*p3,*r;</span><br><span class="line">    LNode *p1,*p2;</span><br><span class="line">    p1=S1-&gt;next,p2=S2-&gt;next;</span><br><span class="line">    S3=new LNode;</span><br><span class="line">    S3-&gt;next=NULL;</span><br><span class="line">    r=S3;</span><br><span class="line">    int i=0;//统计S3的长度</span><br><span class="line">    if(S1==NULL || S2==NULL)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;NULL&quot;;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    while(p1&amp;&amp;p2)&#123;</span><br><span class="line">        if(p1-&gt;data==p2-&gt;data)&#123;</span><br><span class="line">            i++;</span><br><span class="line">            p3=new LNode;</span><br><span class="line">            p3-&gt;data=p1-&gt;data;</span><br><span class="line">            p3-&gt;next=NULL;</span><br><span class="line">            r-&gt;next=p3;</span><br><span class="line">            r=p3;</span><br><span class="line">            p1=p1-&gt;next;</span><br><span class="line">            p2=p2-&gt;next;</span><br><span class="line">        &#125;else if(p1-&gt;data&gt;p2-&gt;data) p2=p2-&gt;next;</span><br><span class="line">        else if(p1-&gt;data&lt;p2-&gt;data) p1=p1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    if(i==0) &#123;</span><br><span class="line">        cout&lt;&lt;&quot;NULL&quot;;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    p3=S3-&gt;next;//p3重新退回头结点指向的位置</span><br><span class="line">    while(p3-&gt;next)&#123;</span><br><span class="line">        cout&lt;&lt;p3-&gt;data&lt;&lt;&quot; &quot;;</span><br><span class="line">        p3=p3-&gt;next;</span><br><span class="line">    &#125;cout&lt;&lt;p3-&gt;data;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    LNode *S1,*S2;</span><br><span class="line">    S1=new LNode;</span><br><span class="line">    S1-&gt;next=NULL;</span><br><span class="line">    S2=new LNode;</span><br><span class="line">    S2-&gt;next=NULL;</span><br><span class="line">    creatlist(S1,S2);</span><br><span class="line">    jiaoji(S1,S2);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>测试点</td>
<td>提示</td>
<td>内存(KB)</td>
<td>用时(ms)</td>
<td>结果</td>
<td>得分</td>
<td></td>
</tr>
<tr>
<td>0</td>
<td>样例等价</td>
<td>300</td>
<td>2</td>
<td>答案正确</td>
<td>2 &#x2F; 2</td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>交集为空</td>
<td>488</td>
<td>3</td>
<td>答案正确</td>
<td>2 &#x2F; 2</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>完全相交</td>
<td>276</td>
<td>3</td>
<td>答案正确</td>
<td>2 &#x2F; 2</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>其中一个序列完全属于交集</td>
<td>492</td>
<td>2</td>
<td>答案正确</td>
<td>2 &#x2F; 2</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>其中一个序列为空</td>
<td>492</td>
<td>3</td>
<td>答案正确</td>
<td>2 &#x2F; 2</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>大规模数据</td>
<td>31864</td>
<td>291</td>
<td>答案正确</td>
<td>2 &#x2F; 2</td>
<td></td>
</tr>
</tbody></table>
<h2><span id="7-2-两个有序链表序列的合并"><strong>7-2 两个有序链表序列的合并</strong></span></h2><p>已知两个非降序链表序列S1与S2，设计函数构造出S1与S2合并后的新的非降序链表S3。</p>
<h3><span id="输入格式">输入格式:</span></h3><p>输入分两行，分别在每行给出由若干个正整数构成的非降序序列，用−1表示序列的结尾（−1不属于这个序列）。数字用空格间隔。</p>
<h3><span id="输出格式">输出格式:</span></h3><p>在一行中输出合并后新的非降序链表，数字间用空格分开，结尾不能有多余空格；若新链表为空，输出<code>NULL</code>。</p>
<h3><span id="输入样例">输入样例:</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 3 5 -1</span><br><span class="line">2 4 6 8 10 -1</span><br></pre></td></tr></table></figure>

<h3><span id="输出样例">输出样例:</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3 4 5 6 8 10</span><br></pre></td></tr></table></figure>

<h3><span id="代码实现">代码实现：</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef struct LNode&#123;</span><br><span class="line">    int data;</span><br><span class="line">    struct LNode *next;</span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"></span><br><span class="line">int creatlist(LinkList &amp;S1,LinkList &amp;S2)&#123;</span><br><span class="line">    LNode *p1,*p2,*r;</span><br><span class="line">    r=S1;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        p1=new LNode;</span><br><span class="line">        cin&gt;&gt;p1-&gt;data;</span><br><span class="line">        if(p1-&gt;data==-1) break;</span><br><span class="line">        p1-&gt;next=NULL;</span><br><span class="line">        r-&gt;next=p1;</span><br><span class="line">        r=p1;</span><br><span class="line">    &#125;</span><br><span class="line">    r=S2;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        p2=new LNode;</span><br><span class="line">        cin&gt;&gt;p2-&gt;data;</span><br><span class="line">        if(p2-&gt;data==-1) break;</span><br><span class="line">        p2-&gt;next=NULL;</span><br><span class="line">        r-&gt;next=p2;</span><br><span class="line">        r=p2;</span><br><span class="line">    &#125;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line">int bingji(LinkList &amp;S1,LinkList &amp;S2)&#123;</span><br><span class="line">    LNode *p1,*p2;</span><br><span class="line">    p1=S1-&gt;next,p2=S2-&gt;next;</span><br><span class="line">    LNode *S3,*p3;</span><br><span class="line">    S3=S1;</span><br><span class="line">    p3=S3;</span><br><span class="line">    while(p1&amp;&amp;p2)&#123;</span><br><span class="line">        if(p1-&gt;data&lt;=p2-&gt;data)&#123;</span><br><span class="line">            p3-&gt;next=p1;</span><br><span class="line">            p3=p1;</span><br><span class="line">            p1=p1-&gt;next;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            p3-&gt;next=p2;</span><br><span class="line">            p3=p2;</span><br><span class="line">            p2=p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    p3-&gt;next=p1?p1:p2;</span><br><span class="line">    //三目运算符，等价于</span><br><span class="line">    //if(p1)p3-&gt;next=p1; </span><br><span class="line">    //else if(p2)p3-a.next=p2;</span><br><span class="line">    </span><br><span class="line">    free(S2);//释放头结点</span><br><span class="line">    p3=S3-&gt;next;</span><br><span class="line">    if(p3==NULL)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;NULL&quot;;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    while(p3-&gt;next)&#123;</span><br><span class="line">        cout&lt;&lt;p3-&gt;data&lt;&lt;&quot; &quot;;</span><br><span class="line">        p3=p3-&gt;next;</span><br><span class="line">    &#125;cout&lt;&lt;p3-&gt;data;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    return 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    LNode *S1,*S2;</span><br><span class="line">    S1=new LNode,S2=new LNode;</span><br><span class="line">    S1-&gt;next=NULL,S2-&gt;next=NULL;</span><br><span class="line">    creatlist(S1,S2);</span><br><span class="line">    bingji(S1,S2);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>测试点</th>
<th>提示</th>
<th>内存(KB)</th>
<th>用时(ms)</th>
<th>结果</th>
<th>得分</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>样例等价</td>
<td>400</td>
<td>2</td>
<td>答案正确</td>
<td>5 &#x2F; 5</td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>有并列</td>
<td>288</td>
<td>2</td>
<td>答案正确</td>
<td>5 &#x2F; 5</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>链表为空</td>
<td>400</td>
<td>2</td>
<td>答案正确</td>
<td>5 &#x2F; 5</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>大规模输入</td>
<td>46228</td>
<td>370</td>
<td>答案正确</td>
<td>5 &#x2F; 5</td>
<td></td>
</tr>
</tbody></table>
<h2><span id="7-3-两个有序链表合并新表不含重复元素"><strong>7-3 两个有序链表合并（新表不含重复元素）</strong></span></h2><p>已知两个非降序链表序列S1与S2，设计函数构造出S1与S2合并后的新的非降序链表S3。<br>要求S3中没有重复元素。</p>
<h3><span id="输入格式">输入格式:</span></h3><p>输入分两行，分别在每行给出由若干个正整数构成的非降序序列，用−1表示序列的结尾（−1不属于这个序列）。数字用空格间隔。</p>
<h3><span id="输出格式">输出格式:</span></h3><p>在一行中输出合并后新的非降序链表，要求链表中没有重复元素。数字间用空格分开，结尾不能有多余空格；若新链表为空，输出NULL。</p>
<h3><span id="输入样例">输入样例:</span></h3><p>在这里给出一组输入。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 3 3 5 8 -1</span><br><span class="line">2 3 4 6 8 10 -1</span><br></pre></td></tr></table></figure>

<h3><span id="输出样例">输出样例:</span></h3><p>在这里给出相应的输出。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3 4 5 6 8 10</span><br></pre></td></tr></table></figure>

<h3><span id="代码实现">代码实现：</span></h3><p>这一段程序相对于上一题的难点在于：</p>
<p>①要求并集中的元素不可重复，因此必须细致的分类讨论集合1大于、小于或等于集合2，以及集合1和集合2的值分别等不等于并集已存在的值</p>
<p>②设置了测试点：一个是空表，一个只有两个相同的元素。如果不加上p3-&gt;next&#x3D;NULL，程序会报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef struct LNode&#123;</span><br><span class="line">    int data;</span><br><span class="line">    struct LNode *next;</span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"></span><br><span class="line">int creatlist(LinkList &amp;S1,LinkList &amp;S2)&#123;</span><br><span class="line">    LNode *p1,*p2,*r;</span><br><span class="line">    r=S1;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        p1=new LNode;</span><br><span class="line">        cin&gt;&gt;p1-&gt;data;</span><br><span class="line">        if(p1-&gt;data==-1) break;</span><br><span class="line">        p1-&gt;next=NULL;</span><br><span class="line">        r-&gt;next=p1;</span><br><span class="line">        r=p1;</span><br><span class="line">    &#125;</span><br><span class="line">    r=S2;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        p2=new LNode;</span><br><span class="line">        cin&gt;&gt;p2-&gt;data;</span><br><span class="line">        if(p2-&gt;data==-1) break;</span><br><span class="line">        p2-&gt;next=NULL;</span><br><span class="line">        r-&gt;next=p2;</span><br><span class="line">        r=p2;</span><br><span class="line">    &#125;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line">int bingji(LinkList &amp;S1,LinkList &amp;S2)&#123;</span><br><span class="line">    LNode *p1,*p2;</span><br><span class="line">    p1=S1-&gt;next,p2=S2-&gt;next;</span><br><span class="line">    LNode *S3,*p3;</span><br><span class="line">    S3=S1;</span><br><span class="line">    p3=S3;</span><br><span class="line">    while(p1&amp;&amp;p2)&#123;</span><br><span class="line">        if(p1-&gt;data&lt;p2-&gt;data &amp;&amp;p1-&gt;data!=p3-&gt;data)&#123;</span><br><span class="line">            p3-&gt;next=p1;</span><br><span class="line">            p3=p1;</span><br><span class="line">            p1=p1-&gt;next;</span><br><span class="line">        &#125;else if(p1-&gt;data&gt;p2-&gt;data&amp;&amp;p2-&gt;data!=p3-&gt;data)&#123;</span><br><span class="line">            p3-&gt;next=p2;</span><br><span class="line">            p3=p2;</span><br><span class="line">            p2=p2-&gt;next;</span><br><span class="line">        &#125;else if(p1-&gt;data==p2-&gt;data&amp;&amp;p1-&gt;data!=p3-&gt;data)&#123;</span><br><span class="line">            p3-&gt;next=p1;</span><br><span class="line">            p3=p1;</span><br><span class="line">            p1=p1-&gt;next;</span><br><span class="line">            p2=p2-&gt;next;</span><br><span class="line">        &#125;else if(p1-&gt;data==p3-&gt;data) p1=p1-&gt;next;</span><br><span class="line">        else if(p2-&gt;data==p3-&gt;data) p2=p2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    while(p1)&#123;</span><br><span class="line">        if(p3-&gt;data!=p1-&gt;data)&#123;</span><br><span class="line">            p3-&gt;next=p1;</span><br><span class="line">            p3=p1;</span><br><span class="line">        &#125;</span><br><span class="line">        p1=p1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    while(p2)&#123;</span><br><span class="line">        if(p3-&gt;data!=p2-&gt;data)&#123;</span><br><span class="line">            p3-&gt;next=p2;</span><br><span class="line">            p3=p2;</span><br><span class="line">        &#125;</span><br><span class="line">        p2=p2-&gt;next;</span><br><span class="line">    &#125;//不能简单地使用三目运算符，因为必须考虑值相等的情况</span><br><span class="line">    p3-&gt;next=NULL;//如果没有这一条，会报错一个测试点</span><br><span class="line">    free(S2);//释放头结点</span><br><span class="line">    p3=S3-&gt;next;</span><br><span class="line">    if(p3==NULL)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;NULL&quot;;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    while(p3-&gt;next)&#123;</span><br><span class="line">        cout&lt;&lt;p3-&gt;data&lt;&lt;&quot; &quot;;</span><br><span class="line">        p3=p3-&gt;next;</span><br><span class="line">    &#125;cout&lt;&lt;p3-&gt;data;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    return 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    LNode *S1,*S2;</span><br><span class="line">    S1=new LNode,S2=new LNode;</span><br><span class="line">    S1-&gt;next=NULL,S2-&gt;next=NULL;</span><br><span class="line">    creatlist(S1,S2);</span><br><span class="line">    bingji(S1,S2);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>测试点</td>
<td>提示</td>
<td>内存(KB)</td>
<td>用时(ms)</td>
<td>结果</td>
<td>得分</td>
<td></td>
</tr>
<tr>
<td>0</td>
<td>样例</td>
<td>316</td>
<td>2</td>
<td>答案正确</td>
<td>5 &#x2F; 5</td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>一个是空表，另一个只有两个相同元素</td>
<td>316</td>
<td>2</td>
<td>答案正确</td>
<td>5 &#x2F; 5</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>两个表都只有一个元素且相同</td>
<td>316</td>
<td>2</td>
<td>答案正确</td>
<td>5 &#x2F; 5</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>两个表有很多相同元素</td>
<td>452</td>
<td>2</td>
<td>答案正确</td>
<td>5 &#x2F; 5</td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>数据结构笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>tag</title>
    <url>/tag/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
