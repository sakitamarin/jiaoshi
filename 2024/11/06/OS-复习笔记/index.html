<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="John Doe">







<title>OS 复习笔记 | Hexo</title>



    <link rel="icon" href="/favicon.ico">



<style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Sans+SC:wght@300;400;500;700&family=Roboto+Mono&display=swap');
</style>



    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    




    <!-- scripts list from _config.yml -->
    
    <script src="/js/menu.js"></script>
    







    <script src='https://unpkg.com/valine@1.4.16/dist/Valine.min.js'></script>




  <!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.1.1"></head>
  <body>
    <div class="mask-border">
    </div>

    <div class="wrapper">

      <div class="header">
  <div class="flex-container">
    <div class="header-inner">
      <div class="site-brand-container">
        <a href="/">
          
            首页
          
        </a>
      </div>
      <div id="menu-btn" class="menu-btn" onclick="toggleMenu()">
        Menu
      </div>
      <nav class="site-nav">
        <ul class="menu-list">
          
            
              <li class="menu-item">
                <a href="/">主页</a>
              </li> 
                   
          
            
              <li class="menu-item">
                <a href="/archives/">归档</a>
              </li> 
                   
          
            
              <li class="menu-item">
                <a href="/categories/gallery/">画廊</a>
              </li> 
                   
          
          
            <li class="menu-item search-btn">
              <a href="#">Search</a>
            </li>
          
        </ul>
      </nav>
    </div>
  </div>
</div>


      <div class="main">
        <div class="flex-container">
          <article id="post">

  
    <div class="post-head">
    <div class="post-info">
        <div class="tag-list">
            
                
                    <span class="post-tag">
                        <a href="/tags/2024-2025-1%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/">
                            2024-2025-1课内笔记
                        </a>
                    </span>    
                           
            
        </div>
        <div class="post-title">
            
            
                OS 复习笔记
            
            
        </div>
        <span class="post-date">
            Nov 6, 2024
        </span>
    </div>
    <div class="post-img">
        
            <div class="h-line-primary"></div>
              
    </div>
</div>
    <div class="post-content">
    <h1><span id="第七章-内存管理">第七章 内存管理</span></h1><h2><span id="一-内存管理的功能">一、内存管理的功能</span></h2><h3><span id="1内存分配的三种基本形式">1.内存分配的三种基本形式</span></h3><p><strong>（1）直接指定方式——编写程序时确定地址</strong></p>
<p><strong>（2）静态分配方式——程序装入内存时确定地址</strong></p>
<p>编译器编译的目标程序都采用从0开始的编址方式。</p>
<p><strong>（3）动态分配方式——程序执行时确定地址</strong></p>
<p>可以接受不可预测的分配和释放内存区域的请求，实现个别存储区域的分配和回收。</p>
<h3><span id="2地址变换">2.地址变换</span></h3><p><strong>（1）地址空间</strong></p>
<p>程序编译后，从0开始，称为逻辑地址，其集合为地址空间。</p>
<p>由计算机体系结构决定，如16位地址范围64kb，32位地址范围4gb。</p>
<p><strong>（2）存储空间</strong></p>
<p>程序在主存中实际位置称为物理地址，其集合为存储空间。</p>
<p>大小由计算机的内存决定。</p>
<p><strong>（3）地址转换</strong></p>
<p>逻辑地址到物理地址的转换，又叫重定位。</p>
<h3><span id="3存储保护">3.存储保护</span></h3><p><strong>（1）地址保护</strong></p>
<p>一个进程中的程序通常不能跳转到另一个进程的指令地址上去。</p>
<p><strong>（2）权限保护</strong></p>
<p>对于不同的进程有不同的存取权限。</p>
<p>4.存储共享</p>
<p>（1）允许每个进程访问该程序同一个副本</p>
<p>（2）让每个进程有自己单独的副本</p>
<h3><span id="5存储扩充">5.存储扩充</span></h3><p><strong>（1）请求调入功能</strong></p>
<p>把程序的一部分装入内存，使其先运行，在运行的过程中随时请求操作系统把需要的部分调入内存。</p>
<p><strong>（2）置换功能</strong></p>
<p>把不需要的部分换出主存，以装载需要的部分。（需要外存支持）</p>
<h2><span id="二-连续分配方式">二、连续分配方式</span></h2><p>1.单一连续分配</p>
<p>出现在单道程序系统中。</p>
<h3><span id="2固定分区分配">2.固定分区分配</span></h3><p><strong>（1）特点</strong></p>
<ul>
<li>操作系统初始化时把内存空间划分多个分区</li>
<li>运行时不改变，这种机制称为固定分区分配</li>
</ul>
<p><strong>（2）划分固定分区的两种方法</strong></p>
<ul>
<li>分区大小相同</li>
<li>分区大小不同</li>
</ul>
<p><strong>（3）优点：</strong>简单</p>
<p><strong>缺点：</strong>内存利用率低，会产生很多内碎片</p>
<h3><span id="3动态分区分配按需分配">3.动态分区分配——按需分配</span></h3><p><strong>（1）特点</strong></p>
<ul>
<li>事先不划定大小</li>
<li>根据进程大小动态分配内存空间</li>
</ul>
<p><strong>（2）分配策略</strong>（重要）</p>
<ul>
<li>首次适应算法：从链表的开头开始查找</li>
<li>下次适应算法：对首次适应算法的改动，从上次查找停止的位置开始查找</li>
<li>最佳适应算法：<strong>查找时间最长，产生最多外碎片</strong></li>
<li>最坏适应算法：使用当前可用的最大分区</li>
</ul>
<p><strong>排序：首次&gt;下次&gt;最坏&gt;最佳</strong></p>
<p><img src="/2024/11/06/OS-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241106030021302-1730835186457-1.png" alt="image-20241106030021302"></p>
<p><img src="/2024/11/06/OS-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241106030042521-1730835198918-3.png" alt="image-20241106030042521"></p>
<p><img src="/2024/11/06/OS-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241106030056654-1730835211197-5.png" alt="image-20241106030056654"></p>
<p><img src="/2024/11/06/OS-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241106030140820-1730835216988-7.png" alt="image-20241106030140820"></p>
<h2><span id="三-交换和覆盖">三、交换和覆盖</span></h2><h2><span id="四-基本分页分配方式">四、基本分页分配方式</span></h2><p><strong>分区分配方式的缺点：</strong></p>
<ul>
<li>会遗留很多碎片</li>
<li>要求连续的较大的空间</li>
</ul>
<p><strong>当前操作系统全部采用基本分页分配方式。</strong></p>
<h3><span id="1页面相关概念">1.页面相关概念</span></h3><p><strong>（1）页面：</strong></p>
<p>分页存储管理是将作业的逻辑地址划分成一系列同等大小的部分，称为页。</p>
<p>每个作业的页的编号都是从0开始。</p>
<p>把可用的物理内存也划分成同样大小的连续的部分，称为块。</p>
<p>先有块，才有页。</p>
<p><strong>（2）地址结构：</strong></p>
<p>由页号和页内偏移量组成。</p>
<p>2^10&#x3D;1K     2^11&#x3D;2K     2^12&#x3D;4K    2^20&#x3D;1M</p>
<p><img src="/2024/11/06/OS-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241106031044737-1730835231317-9.png" alt="image-20241106031044737"></p>
<h2><span id="2计算重要">2.计算（重要）</span></h2><h4><span id="1若逻辑地址a十进制页大小l">（1）<strong>若逻辑地址A（十进制），页大小L</strong></span></h4><p>①页号p&#x3D; INT（A&#x2F;L)</p>
<p>②页内偏移w&#x3D; (A mod L)</p>
<h4><span id="2若逻辑地址a八x2f十六进制页面大小为l">（2）<strong>若逻辑地址A（八&#x2F;十六进制），页面大小为L</strong></span></h4><p>①先把逻辑地址A转换成二进制；</p>
<p>②计算页面大小L在地址结构中占的位数l；</p>
<p>③右侧数0 ~ l-1位为偏移量；</p>
<p>④右侧数第 l 位开始为页号。</p>
<h4><span id="3逻辑地址a转物理地址">（3）<strong>逻辑地址A转物理地址</strong></span></h4><p>若逻辑地址为十进制数，则用页号p&#x3D;INT(A&#x2F;页大小L), 页内偏移量w&#x3D;AmodL，找页表块 号，</p>
<p>块号大小+偏移量&#x3D;物理地址 </p>
<p>若为八进制&#x2F;十六进制，则转为二进制，然后根据页大小L从右往左取位数，取页内偏移量 和页号，找页表块号，</p>
<p>块号大小+偏移量&#x3D;物理地址</p>
<p><img src="/2024/11/06/OS-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241106032228541-1730835249284-11.png" alt="image-20241106032228541"></p>
<h3><span id="3页面大小">3.页面大小</span></h3><p>页数&#x3D;文件大小&#x2F;页面大小</p>
<p>页表文件大小&#x3D;页数*块号大小</p>
<p>页表文件页数&#x3D;页面大小&#x2F;页表文件大小</p>
<h4><span id="1分页存储管理所造成的资源消耗"><strong>（1）分页存储管理所造成的资源消耗</strong></span></h4><ul>
<li><strong>内存资源：</strong>页表需要保存在内存中，占用内存资源 </li>
<li><strong>运行性能：</strong>获取指令的过程中需要多次访问内存（至少2次！）</li>
</ul>
<p><strong>（2）把页表页看成普通的文件，对它进行离散的分配，即对页表再分页，由此形成多级页表 的思想。</strong></p>
<p><strong>（3）最优页面大小公式：</strong></p>
<p> <strong>p&#x3D;根号（2es）</strong> </p>
<p>页面大小p，每个页表项需要e字节，平均进程大小是s字节</p>
<h2><span id="五-基本分段分配方式">五、基本分段分配方式</span></h2><h4><span id="1引入分段的必要性">1.<strong>引入分段的必要性</strong></span></h4><p>逻辑上完整</p>
<p>动态增长</p>
<p>动态链接</p>
<p>信息共享</p>
<p>信息保护</p>
<h4><span id="2地址变换机构">2.地址变换机构</span></h4><ul>
<li>由逻辑地址得到段号，段内地址；</li>
<li>段号与段表寄存器中的段长度比较，检查是否越界；</li>
<li>由段表始址、段号找到对应段表项；</li>
<li>检查段表中记录的段长，<strong>检查段内地址是否越界</strong>（区分页表的一点）；</li>
<li>由段表中“基址+段内地址”得到最终的物理地址；</li>
<li>访问目标单元；</li>
</ul>
<h4><span id="例题">例题</span></h4><p>在分段系统中，段表如下所示，请将逻辑地址（0，337），（1，5000），（2，3609），（5，1230）转换为物理地址。</p>
<p>段号	内存地址	段长<br>0	         50K	10K<br>1	         60K	3K<br>2	         70K	5K<br>3	        120K	8K<br>4	        150K	4K<br>（1）段号0小于段表长5，段号合法；根据段表第0项可知段表的内存始址为50K，段长为10K；由于段内地址337小于段长10K，故段内地址也是合法的。因此可以得出对应物理地址为50K+337&#x3D;51537；</p>
<p>（2）段号1小于段表长5，段号合法；根据段表第1项可知段表的内存始址为60K，段长为3K；经检查，段内地址5000超过段长3K，因此产生越界中断；</p>
<p>（3）段号2小于段表长5，段号合法；根据段表第2项可知段表的内存始址为70K，段长为5K；由于段内地址3609小于段长5K，故段内地址也是合法的。因此可以得出对应物理地址为70K+3609&#x3D;75289；</p>
<p>（4）段号不合法，产生越界中断；</p>
<h4><span id="3分页与分段的区别">3.分页与分段的区别</span></h4><ul>
<li>页是信息的物理单位，段是信息的逻辑单位；</li>
<li>页是系统的，段是用户的；</li>
<li>页的大小是固定的，段的长度是不固定的；</li>
<li>分页的地址空间是一维的，分段的地址空间是二维的；</li>
<li>页存在内碎片，段存在外碎片。</li>
</ul>
<h1><span id="第八章-虚拟存储管理">第八章 虚拟存储管理</span></h1><h2><span id="一-虚拟存储器">一、虚拟存储器</span></h2><h3><span id="1为什么需要虚拟存储器">1.为什么需要虚拟存储器</span></h3><p>(1) 用户地址空间可以大于物理内存空间 </p>
<p>(2) 内存尽可能保存多个进程——提高并发性（提高CPU利用率）</p>
<h3><span id="2虚拟存储器">2.虚拟存储器</span></h3><p>通过<strong>请求调入功能</strong>和<strong>置换功能</strong>，能从<strong>逻辑上</strong>对内存容量加以<strong>扩充</strong>的一种存储器系统（基于程序局部性原理）</p>
<h3><span id="3虚拟存储器的特点">3.虚拟存储器的特点</span></h3><ul>
<li><strong>多次性：</strong>一个进程的数据会多次装入内存</li>
<li><strong>对换性：</strong>允许一个程序在运行过程中从内存换入和换出</li>
<li><strong>虚拟性：</strong>未改变系统中内存物理的大小</li>
</ul>
<p>4.需要解决的问题</p>
<p>地址映射、分配策略、置换策略、装载控制</p>
<h2><span id="二-请求页式分配">二、请求页式分配</span></h2><h3><span id="1请求分页">1.请求分页</span></h3><p>在基本分页的基础上增加请求调页和页面置换功能的一种存储分配策略 </p>
<p>(1) 在进程开始运行前，不是装入全部页面，而是装入几个页面 </p>
<p>(2) 根据进程运行的需要，动态装入其他页 </p>
<p>(3) 当内存空间已满，需要装入新页面，则需要置换算法淘汰某个页面</p>
<h3><span id="2结构">2.结构</span></h3><p><img src="/2024/11/06/OS-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20241122014844.png" alt="微信截图_20241122014844"></p>
<h3><span id="3缺页中断机构及特点">3.缺页中断机构及特点</span></h3><p>访问的页不在内存，产生一个<strong>缺页中断</strong>——状态位为0</p>
<p><strong>缺页中断特点</strong>：</p>
<ul>
<li>同样要经历中断步骤（硬件寄存器支持）</li>
<li>在指令执行期间产生</li>
<li>恢复执行被中断指令</li>
</ul>
<h3><span id="4内存分配策略">4.内存分配策略</span></h3><p>（1）内存分配要考虑的问题：</p>
<ul>
<li>分配进程物理块少，内存中进程数越多，进程缺页可能性很高。</li>
<li>进程分配的物理块超过一定数目后，给该进程分配更多的物理块对该进程的缺页率没有影响。</li>
</ul>
<p>（2）三种组合：</p>
<p>固定分配局部置换、可变分配局部置换、可变分配全局置换</p>
<p>（3）内存分配方法：</p>
<p>平均分配、按进程大小比例分配（bi&#x3D;pi&#x2F;p*m)、考虑优先级的分配算法</p>
<p>（4）影响缺页率的因素：</p>
<ul>
<li>分配的物理块数</li>
<li>置换算法</li>
<li>数据访问顺序</li>
</ul>
<h3><span id="5页面置换算法">5.页面置换算法</span></h3><h4><span id="1最优页面置换算法opt">（1）最优页面置换算法——OPT</span></h4><p>选择当前内存中最后一个用到的页并把它置换出去，<strong>往后推</strong></p>
<p><img src="/2024/11/06/OS-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241213004548764.png" alt="image-20241213004548764"></p>
<h4><span id="2先进先出置换算法fifo">（2）先进先出置换算法——FIFO</span></h4><p>选择最早进入内存的那一页并把它置换出去</p>
<p>产生<strong>Belady异常（物理块多反而缺页率增加）</strong></p>
<p><img src="/2024/11/06/OS-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241213004610988.png" alt="image-20241213004610988"></p>
<h4><span id="3最近最少使用置换算法lru">（3）最近最少使用置换算法——LRU</span></h4><p><img src="/2024/11/06/OS-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241213004634309.png" alt="image-20241213004634309"></p>
<h4><span id="4时钟算法">（4）时钟算法</span></h4><p>某一页首次装入内存时，使用位u置为1，当被使用时也置为1；</p>
<p>指针扫描，当扫描到这个页面，置为0；</p>
<p>当扫描到一个u&#x3D;0的物理块，这个物理块就被置换，指针继续移动一个格子。</p>
<p><img src="/2024/11/06/OS-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241213004728354.png" alt="image-20241213004728354"></p>
<h4><span id="5改进时钟算法">（5）改进时钟算法</span></h4><p>Clock只考虑了使用频率，未考虑是否修改。 故增加一个修改位w；</p>
<p>新装入页u&#x3D;1，w&#x3D;0； 找u&#x3D;0，w&#x3D;0 或 u&#x3D;0，w&#x3D;1的物理块替换</p>
<p>①扫描时不修改使用位，若找到u&#x3D;0，w&#x3D;0的，置换它； </p>
<p>②若未找到，再次扫描，找u&#x3D;0，w&#x3D;1的，置换它，并将期间遇到u&#x3D;1的都置0 </p>
<p>③若未找到，跳转①</p>
<h3><span id="6段页式分配方法">6.段页式分配方法</span></h3><p>（1）<strong>分页的优势</strong></p>
<ul>
<li>对程序员是透明的</li>
<li>消除外部碎片</li>
<li>大小固定相等，可开发出精致的存储管理算法</li>
</ul>
<p>（2）<strong>分段的优势</strong></p>
<ul>
<li>具有处理不断增长的数据结构的能力</li>
<li>无内碎片</li>
<li>段共享及保护操作容易</li>
<li>支持动态链接</li>
</ul>
<h3><span id="7工作集模型">7.工作集模型</span></h3><p>基本思想：</p>
<ul>
<li>一个进程当前正在使用的页面的集合称为它的工作集</li>
<li>如果在内存中装入的是整个工作集，进程的运行就不会产生很多缺页</li>
<li>若分配给进程的物理块太少，无法容纳下整个工作集，进程的运行会产生大量的缺页</li>
</ul>
<h3><span id="8伙伴策略原理">8.伙伴策略原理</span></h3><p>在进程提出存储请求时，Linux并不一定按照请求的块数进行分配，而是将大于、等于这个数目的最小2^i个块数进行分配。</p>
<p>例如要求3个块，则分配2^2&#x3D;4个块</p>
<p>（1）特点</p>
<ul>
<li>允许内部碎片的存在</li>
<li>外部碎片非常少</li>
<li>从空间区队列表中搜索空闲块的速度极快</li>
</ul>
<p>（2）分配和释放</p>
<p>内存可分配总量为1MB，请求和释放的序列为：A(100KB)→B(240KB)→C(64KB)→D(256KB)→B(240KB)→A(100KB)→E(75KB)→C(64KB)→E(75KB)→D(256KB)</p>
<p><img src="/2024/11/06/OS-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/51da8a3eea3ebae4c60146d92fc4671.jpg" alt="51da8a3eea3ebae4c60146d92fc4671"></p>
<h1><span id="第九章-设备管理不考大题">第九章 设备管理（不考大题）</span></h1><h2><span id="一-io系统">一、IO系统</span></h2><h3><span id="1设备的类别">1.设备的类别</span></h3><p>（1）使用特性</p>
<p><img src="/2024/11/06/OS-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241213010925611.png" alt="image-20241213010925611"></p>
<p>（2）系统观点——数据传输率</p>
<p>低速设备——键盘、</p>
<p>中速设备——打印机</p>
<p>高速设备——磁带、磁盘、光盘</p>
<p>（3）按系统观点——传输单位</p>
<p> 字符设备——不可寻址、I&#x2F;O中断驱动和传输率相对较低 </p>
<p> 块设备——可寻址、一般为DMA方式</p>
<p>（4）按系统观点——共享属性</p>
<p>独占设备——如打印机、磁带机等顺序设备。作为系统资源，也称为临界资源 </p>
<p> 共享设备——如磁盘可随机访问随机设备 </p>
<p> 虚拟设备——<strong>通过虚拟技术将独占设备变换成可共享逻辑设备，供多个进程同时访问</strong></p>
<p>（5）系统设备与用户设备 </p>
<p>系统设备（标准设备）——一些通用设备；</p>
<p>如键盘、 打印机以及文件存储设备等 </p>
<p>用户设备（非标准设备）——由用户自己安装配置后 ，由操作系统统一管理的设备；</p>
<p>如实时系统中的A&#x2F;D 、D&#x2F;A变换器、现场监控数码显示</p>
<h3><span id="2设备标识">2.设备标识</span></h3><p> <strong>3 个原因:</strong> </p>
<p>①类型与数量多，赋予绝对设备号 </p>
<p>② 并发性；编写程序时，不可能知道哪类哪台设备是可用的 </p>
<p>③ 使用的方便性；I&#x2F;O申请时，给出类型号、设备号（相对顺序），由系统进行“地址变换” （绝对设备号）</p>
<h3><span id="3io系统的结构">3.IO系统的结构</span></h3><p><strong>（1）总线结构</strong></p>
<p>由于规模不同，系统结构不尽相同: </p>
<ul>
<li>在微型计算机和小型计算机系统中大多采用了<strong>单总线 I&#x2F;O系统结构</strong> </li>
<li>一些中、大型计算机系统中，往往具有专门进行I&#x2F;O处理的通道（处理机），因而更多地采用了<strong>多总线</strong>多通道结构</li>
</ul>
<p><strong>（2）设备控制器</strong></p>
<p>作用：</p>
<ul>
<li>是CPU与IO设备之间的接口</li>
<li>根据主机发来的命令控制设备进行IO操作</li>
</ul>
<p>功能：</p>
<ul>
<li>接受命令并进行译码（控制寄存器）</li>
<li>进行数据交换（数据寄存器）</li>
<li>记录和报告设备状态（状态寄存器）</li>
</ul>
<h2><span id="二-io设备数据传输控制方式">二、IO设备数据传输控制方式</span></h2><h3><span id="1程序直接控制方式早期用户使用">1.程序直接控制方式——早期用户使用</span></h3><p>①用户直接编写I&#x2F;O指令程序控制输入输出</p>
<p>②要保持CPU与外设同步（由于速度差距）</p>
<p>（1）优点：CPU与外设通过状态信息得到同步，硬件简单。</p>
<p>（2）缺点：</p>
<ul>
<li>CPU不断读取状态寄存器信息，造成“忙等”。</li>
<li>CPU只能与一台设备交换数据,不能实现设备之间的并行工作。</li>
<li>传输完全在CPU控制之下，对外部出现异常事件无实时响应能力。</li>
</ul>
<p>(只适用于较简单的单片机系统）</p>
<h3><span id="2中断控制方式要求设备控制器应具备中断机构">2.中断控制方式——要求设备控制器应具备中断机构</span></h3><p>中断驱动方式仅适合于中、慢速设备。对于大批量成组数据交换，可以利用DMA和通道方式</p>
<p>（1）基本工作过程： </p>
<p>① CPU执行设备驱动程序，向控制器发启动指令 </p>
<p>② 控制器按照I&#x2F;O指令要求，启动并控制I&#x2F;O设备工作。CPU与外设是并行操作的。 </p>
<p>③ 输入就绪&#x2F;输出完成，控制器向CPU发中断信号。 </p>
<p>④ CPU接中断信号，保护现场，转中断处理程序。 </p>
<p>⑤ 中断处理程序完成后退出中断，恢复现场。</p>
<p> ⑥ 将控制转回被打断的执行位置。</p>
<p>（2）优点： </p>
<ul>
<li>CPU与外设、外设与外设可以并行工作，提高系统效率</li>
<li>具有实时响应能力，可应用于实时控制场合</li>
</ul>
<p>（3）弱点： </p>
<ul>
<li>完成一次I&#x2F;O要多次中断驱动</li>
<li>对各高速设备，或成组数据交换的问题——</li>
<li>一方面高速外设由于中断方式可能来不及响应而丢失数据</li>
<li>另一方面，成组数据交换多次地通过中断进行，也显得速度太慢</li>
</ul>
<h3><span id="3dma控制方式">3.DMA控制方式</span></h3><p>通道的引入：</p>
<ul>
<li>一个DMA控制器只能挂接少量的同类设备</li>
<li>一次一块+且地址连续，若多个块，就需要多次启动DMA，因而也产生了多次中断处理</li>
</ul>
<p>特点： </p>
<ul>
<li>数据在内存和设备之间直接传送，CPU不干预。 </li>
<li>一个数据块传输完，DMA向CPU发出一个中断请求。 </li>
<li>数据的传输控制完全由DMA控制器完成，速度快， 适合高速成组数据传输。 </li>
<li>数据块在传输过程中，CPU与外设并行工作，比中断控制方式的并行性高。</li>
</ul>
<h3><span id="4通道控制方式">4.通道控制方式</span></h3><p>特点：</p>
<ul>
<li>一次可以实现多个离散数据块的传输。</li>
<li>可通过指令实现对设备控制，如磁带反绕等。</li>
<li>可以实现较为复杂的I&#x2F;O控制。</li>
</ul>
<p><img src="/2024/11/06/OS-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241213012648214.png" alt="image-20241213012648214"></p>
<h2><span id="三-设备管理">三、设备管理</span></h2><p>①用户不可能掌握每一种设备的具体控制与操作</p>
<p>②由于系统的并发性也不允许用户直接控制各个设备的启动与操作</p>
<h3><span id="1设备管理的目标">1.设备管理的目标</span></h3><p>(1) 设备独立性：提供通用、一致、规范的使用接口，做到用户应用程序与实际物理设备无关 </p>
<p>(2) 提高系统整体效率：提高设备和CPU效率，如设备控制方式、缓冲技术</p>
<p><strong>可利用分层方法实现IO管理软件</strong></p>
<h3><span id="2io管理层次">2.IO管理层次</span></h3><p>（1）用户进程</p>
<p>（2）逻辑IO（独立于设备的软件）</p>
<p>（3）设备IO（设备驱动程序）</p>
<p>（4）中断控制程序（主机与IO设备接口）</p>
<h3><span id="3io-管理主要功能">3.IO 管理主要功能</span></h3><p>(1) 记录设备信息 </p>
<p>(2) 设备分配与再分配 </p>
<p>(3) 实施IO操作 </p>
<p>(4) 缓冲管理</p>
<h2><span id="四-缓冲">四、缓冲</span></h2><p>作用：</p>
<p>(1) 减少进程被阻塞的机会，以及设备和中断的次数 </p>
<p>(2) 缓解对存储管理模块的干扰 </p>
<p>(3) 缓解CPU和低速外设速度不匹配的矛盾，使数据处理速度提高</p>
<h2><span id="五-io软件设计">五、IO软件设计</span></h2><p> IO 软件层次 </p>
<p>(1) IO 中断处理设备 </p>
<p>(2) IO 设备驱动程序 </p>
<p>(3) 与设备无关的操作系统IO软件 </p>
<p>(4) 用户层IO软件</p>
<h2><span id="六-磁盘存储器管理">六、磁盘存储器管理</span></h2><p>扇区：IO传输和空间分配基本单位</p>
<h3><span id="1改善磁盘io速度">1.改善磁盘IO速度</span></h3><p>(1) 选硬件上性能指标高者 </p>
<p>(2) 根据IO请求采用适合的磁盘调度算法 </p>
<p>(3) 设置磁盘高速缓冲区</p>
<h3><span id="2确定一个扇区需要三个参数">2.确定一个扇区需要三个参数</span></h3><p>柱面号(磁道)、盘面号(磁头)和扇区号(三维地址物理形式)</p>
<p>对于数组A【i】【j】【k】</p>
<p>i&#x3D;磁道，j&#x3D;磁头，k&#x3D;扇区</p>
<h3><span id="3磁盘访问时间">3.磁盘访问时间</span></h3><p>寻道时间Ts&#x3D;启动磁盘的时间S + 移动磁道n条*m（低速0.3，高速0.1）</p>
<p>旋转延迟时间Tr &#x3D; 1 &#x2F;（2r）</p>
<p>传输时间Td&#x3D;每次读写的字节数b &#x2F;旋转速度r*一条磁道上的字节数N</p>
<p>平均访问时间Ta&#x3D;Ts + Tr + Td</p>
<h3><span id="4磁盘调度算法重点">4.磁盘调度算法（重点）</span></h3><p>(1) FCFS&#x2F;FIFO</p>
<p>优点：策略是公平的</p>
<p>缺点：大量进程访问者竞争一个磁盘，则性能接近于随机调度，性能很差 </p>
<p><img src="/2024/11/06/OS-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241213020114717.png" alt="image-20241213020114717"></p>
<p>(2) SSTF 最短寻道时间优先</p>
<p>策略——选择当前位置移动距离最短I&#x2F;O访问者</p>
<p>问题——每次选择距离最短者同时，忽略可能不断新I&#x2F;O请求进程加入到队列 中，使队列中距离远访问者总也得不到调度，产生所谓<strong>“饥饿”</strong>现象 </p>
<p><img src="/2024/11/06/OS-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241213020129155.png" alt="image-20241213020129155"></p>
<p>(3) SCAN </p>
<p>避免了饥饿现象。</p>
<p>由于这种算法使得磁臂移动规律颇似电梯的运动，因而也称为电梯算法 </p>
<p><img src="/2024/11/06/OS-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241213020201106.png" alt="image-20241213020201106"></p>
<p>(4) CSCAN </p>
<p>磁头”单向”读&#x2F;写运动</p>
<p><img src="/2024/11/06/OS-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241213020231735.png" alt="image-20241213020231735"></p>

</div> 

<script>
    window.onload = detectors();
</script>
    <div class="post-footer">
    <div class="h-line-primary"></div>
    <nav class="post-nav">
        <div class="prev-item">
           
                <div class="icon arrow-left"></div>
                <div class="post-link">
                    <a href="/2024/11/08/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/">Prev</a>
                </div>
            
        </div>
        <div class="next-item">
            
                <div class="icon arrow-right"></div>
                <div class="post-link">
                  <a href="/2024/10/24/java%E9%A2%98%E5%BA%93%EF%BC%88%E4%B8%8A%EF%BC%89/">Next</a>  
                </div>  
            
        </div>
    </nav>
</div>

    
      <div class="post-comment">

    
        <div id="vcomments"></div>
        <script>
            var META = ['nick', 'mail', 'link'];
            var meta = 'nick,mail';
            meta = meta.split(',').filter(item => {
                return META.includes(item);
            });
            new Valine({
                el: '#vcomments',
                appId: 'f131VXTFNbI57QRvg5lJFtbq-MdYXbMMI',
                appKey: 'd1GENolYcYpRMO2FbRRbarov',
                lang: 'zh-CN',
                placeholder: 'Say something',
                avatar: 'mp',
                meta: meta
            })
        </script>    
     

     
    
    

</div>
     
  
</article>
        </div>
      </div>
      
      <div class="footer">
    <div class="flex-container">
        <div class="footer-text">
            
            
            
                Powered by <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> & <a target="_blank" rel="noopener" href="https://github.com/zoeingwingkei/frame/">Frame</a>
                
        </div>
    </div>
</div>

    </div>

    
      <div class="search-popup">
    <div class="search-popup-overlay">  
    </div>
    <div class="search-popup-window" >
        <div class="search-header">
            <div class="search-input-container">
              <input autocomplete="off" autocapitalize="off" maxlength="80"
                     placeholder="Search Anything" spellcheck="false"
                     type="search" class="search-input">
            </div>
            <div class="search-close-btn">
                <div class="icon close-btn"></div>
            </div>
        </div>
        <div class="search-result-container">
        </div>
    </div>
</div>

<script>
    const searchConfig = {
        path             : "/search.xml",
        top_n_per_article: "1",
        unescape         : "false",
        trigger: "auto",
        preload: "false"
    }
</script>
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js"></script>
<script src="/js/search.js"></script>
    
    

  </body>
</html>
