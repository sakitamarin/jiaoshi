<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="John Doe">







<title>图的表示和操作 | Hexo</title>



    <link rel="icon" href="/favicon.ico">



<style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Sans+SC:wght@300;400;500;700&family=Roboto+Mono&display=swap');
</style>



    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    




    <!-- scripts list from _config.yml -->
    
    <script src="/js/menu.js"></script>
    







    <script src='https://unpkg.com/valine@1.4.16/dist/Valine.min.js'></script>




  <!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.1.1"></head>
  <body>
    <div class="mask-border">
    </div>

    <div class="wrapper">

      <div class="header">
  <div class="flex-container">
    <div class="header-inner">
      <div class="site-brand-container">
        <a href="/">
          
            首页
          
        </a>
      </div>
      <div id="menu-btn" class="menu-btn" onclick="toggleMenu()">
        Menu
      </div>
      <nav class="site-nav">
        <ul class="menu-list">
          
            
              <li class="menu-item">
                <a href="/">主页</a>
              </li> 
                   
          
            
              <li class="menu-item">
                <a href="/archives/">归档</a>
              </li> 
                   
          
            
              <li class="menu-item">
                <a href="/categories/gallery/">画廊</a>
              </li> 
                   
          
          
            <li class="menu-item search-btn">
              <a href="#">Search</a>
            </li>
          
        </ul>
      </nav>
    </div>
  </div>
</div>


      <div class="main">
        <div class="flex-container">
          <article id="post">

  
    <div class="post-head">
    <div class="post-info">
        <div class="tag-list">
            
                
                    <span class="post-tag">
                        <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/">
                            数据结构笔记
                        </a>
                    </span>    
                           
            
        </div>
        <div class="post-title">
            
            
                图的表示和操作
            
            
        </div>
        <span class="post-date">
            Jun 1, 2024
        </span>
    </div>
    <div class="post-img">
        
            <div class="h-line-primary"></div>
              
    </div>
</div>
    <div class="post-content">
    <!-- toc -->

<ul>
<li><a href="#%E4%B8%80-%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C">一、图的基本操作</a><ul>
<li><a href="#int-locatevex">int LocateVex();</a></li>
<li><a href="#int-firstadjvex">int FirstAdjVex();</a></li>
<li><a href="#int-nextadjvex">int NextAdjVex();</a></li>
<li><a href="#void-showmatrix">void showMatrix();</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C-%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84">二、图的存储结构</a></li>
<li><a href="#1%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5">1.邻接矩阵</a><ul>
<li><a href="#1%E6%97%A0%E5%90%91%E7%BD%91%E7%9A%84%E5%AE%9A%E4%B9%89">（1）无向网的定义</a></li>
<li><a href="#2%E6%97%A0%E5%90%91%E7%BD%91%E7%9A%84%E5%88%9B%E5%BB%BA">（2）无向网的创建</a></li>
</ul>
</li>
<li><a href="#2%E9%82%BB%E6%8E%A5%E8%A1%A8%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8">2.邻接表（链式存储）</a><ul>
<li><a href="#1%E5%AE%9A%E4%B9%89">（1）定义</a></li>
<li><a href="#2%E5%88%9B%E5%BB%BA">（2）创建</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89-%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86">三、图的遍历</a><ul>
<li><a href="#1%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86">1.深度优先遍历</a></li>
<li><a href="#2%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86">2.广度优先遍历</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<p>[TOC]</p>
<h2><span id="一-图的基本操作">一、图的基本操作</span></h2><h3><span id="int-locatevex">int LocateVex();</span></h3><p>&#x2F;&#x2F; 返回顶点u在图中的位置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int LocateVex(MGraph G, VertexType u) &#123;</span><br><span class="line">	int i;</span><br><span class="line">	for (i = 0; i &lt; G.vexnum &amp;&amp; G.vexs[i] != u; i++);</span><br><span class="line">	return i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="int-firstadjvex">int FirstAdjVex();</span></h3><p>&#x2F;&#x2F; 返回图G中u的第一个邻接节点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int FirstAdjVex(MGraph G, VertexType u) &#123;</span><br><span class="line">	int index = LocateVex(G, u);</span><br><span class="line">	int i;</span><br><span class="line">	for (i = 0; i &lt; G.vexnum; i++) &#123;</span><br><span class="line">		if (G.arcs[index][i].adj != -1) break;</span><br><span class="line">	&#125;</span><br><span class="line">	if (i == G.vexnum) return -1;  // 没有临界点</span><br><span class="line">	else return i;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3><span id="int-nextadjvex">int NextAdjVex();</span></h3><p>&#x2F;&#x2F; 返回G中顶点v相对于u的下一邻接点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int NextAdjVex(MGraph G, VertexType v, VertexType u) &#123;</span><br><span class="line">	int indexV = LocateVex(G, v);</span><br><span class="line">	int indexU = LocateVex(G, u);</span><br><span class="line">	int index;</span><br><span class="line">	for (index = indexU + 1; index &lt; G.vexnum &amp;&amp; G.arcs[indexV][index].adj == -1; index++);</span><br><span class="line">	if (index == G.vexnum) return -1;</span><br><span class="line">	else return index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="void-showmatrix">void showMatrix();</span></h3><p>&#x2F;&#x2F; 打印图的邻接矩阵</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void showMatrix(MGraph G) &#123;</span><br><span class="line">	for (int i = 0; i &lt; G.vexnum; i++) &#123;</span><br><span class="line">		for (int j = 0; j &lt; G.vexnum; j++) cout &lt;&lt; G.arcs[i][j].adj &lt;&lt; &quot; &quot;;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="二-图的存储结构">二、图的存储结构</span></h2><h2><span id="1邻接矩阵">1.邻接矩阵</span></h2><p>图没有顺序存储结构，但可以利用二维数组来表示元素之间的关系，即邻接矩阵表示法。</p>
<p>邻接矩阵是表示顶点之间相邻关系的矩阵。</p>
<p><strong>无向图</strong></p>
<p><img src="/2024/06/01/%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E6%93%8D%E4%BD%9C/fd2a45a63a414cfdb6800122ecd6bb82.jpg" alt="fd2a45a63a414cfdb6800122ecd6bb82"></p>
<p><strong>有向网</strong></p>
<p><img src="/2024/06/01/%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E6%93%8D%E4%BD%9C/af06656474c14cfb839a5cb7e8cae998.jpg" alt="af06656474c14cfb839a5cb7e8cae998"></p>
<h3><span id="1无向网的定义">（1）无向网的定义</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#define MAXINT 32767 //表示极大值，即∞</span><br><span class="line">#define MVnum 100 //最大顶点数</span><br><span class="line"></span><br><span class="line">typedef char VerTexType;//假设顶点为字符型</span><br><span class="line">typedef int ArcType; //假设边的权值为整型</span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line">	VerTexType vexs[MVnum]; //顶点表</span><br><span class="line">	ArcType arcs[MVnum][MVnum]; //邻接矩阵</span><br><span class="line">	int vexnum,arcnum; //图的当前点数和边数 </span><br><span class="line">&#125;AMGraph;</span><br></pre></td></tr></table></figure>

<h3><span id="2无向网的创建">（2）无向网的创建</span></h3><ul>
<li>输入总顶点数和总边数；</li>
<li>依次输入点的信息；</li>
<li>初始化邻接矩阵；</li>
<li>依次输入每条边（及其权值），<u>确定两个顶点在图中的位置之后</u>，使相应边赋予相应的权值，<u>同时使其对称边赋予相同的权值</u>。</li>
</ul>
<p><strong>创建。</strong></p>
<p>无向图的创建只需要删除w变量的部分，并把无穷改成1就好。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int CreateUDN(AMGraph &amp;G)&#123; </span><br><span class="line">	cin&gt;&gt;G.vexnum&gt;&gt;G.arcnum; //输入总点数和总边数</span><br><span class="line">	for(int i=0;i&lt;G.vexnum;i++)&#123;</span><br><span class="line"> 		cin&gt;&gt;G.vexs[i]; //输入点的信息</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=0;i&lt;G.arcnum;i++)</span><br><span class="line">	  for(int j=0;i&lt;G.arcnum;j++)</span><br><span class="line">	    G.arcs[i][j]=MAXINT; //初始化邻接矩阵，边的权值均置为∞ </span><br><span class="line">	for(int k=0;k&lt;G.arcnum;k++) &#123;  // 输入弧v1-v2的信息</span><br><span class="line">		VerTexType v1,v2;int w;</span><br><span class="line">		cin&gt;&gt;v1&gt;&gt;v2&gt;&gt;w; </span><br><span class="line">		int index1 = LocateVex(G, v1);</span><br><span class="line">		int index2 = LocateVex(G, v2);</span><br><span class="line">		G.arcs[index1][index2]= w; // w表示邻接的权值 </span><br><span class="line">		G.arcs[index2][index1] = G.arcs[index1][index2];  // 无向图对称构造</span><br><span class="line">	&#125;</span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>打印。</strong></p>
<pre><code>for(i = 0 ; i &lt; G.vexnum ; ++i)&#123;
    for(j = 0; j &lt; G.vexnum; ++j)&#123;
        if(j != G.vexnum - 1)&#123;
            if(G.arcs[i][j] != MaxInt)
                cout &lt;&lt; G.arcs[i][j] &lt;&lt; &quot;\t&quot;;
            else
                cout &lt;&lt; &quot;∞&quot; &lt;&lt; &quot;\t&quot;;
        &#125;
        else&#123;
            if(G.arcs[i][j] != MaxInt)
                cout &lt;&lt; G.arcs[i][j] &lt;&lt;endl;
            else
                cout &lt;&lt; &quot;∞&quot; &lt;&lt;endl;
        &#125;
    &#125;
&#125;//for
</code></pre>
<h2><span id="2邻接表链式存储">2.邻接表（链式存储）</span></h2><p><img src="/2024/06/01/%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E6%93%8D%E4%BD%9C/v2-917733c568ffe18d48b5493b1b327f05_r.jpg" alt="v2-917733c568ffe18d48b5493b1b327f05_r"></p>
<h3><span id="1定义">（1）定义</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#typedef MVNum 100 //最大顶点数 </span><br><span class="line">typedef struct ArcNode&#123; //边结点 </span><br><span class="line">	int adjvex; //该边所指向的顶点的位置</span><br><span class="line">	struct ArcNode *nextarc; //指向下一条边的指针</span><br><span class="line">	//InfoType info         //网的边权值 </span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line">typedef struct VNode&#123; //顶点表 </span><br><span class="line">	VertexType data; //顶点信息</span><br><span class="line">	ArcNode *firstarc; //指向第一天依附该结点的弧的指针 </span><br><span class="line">&#125;VNode,AdjList[MVNum];</span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line">	AdjList vertices;</span><br><span class="line">	int vexnum,arcnum; //图的当前顶点数和边数 </span><br><span class="line">&#125;ALGraph; </span><br></pre></td></tr></table></figure>

<h3><span id="2创建">（2）创建</span></h3><ul>
<li><p>输入总顶点数和总边数；</p>
</li>
<li><p>依次输入点的信息存在顶点表中，每个表头结点的指针域初始化为NULL；</p>
</li>
<li><p>创建邻接表，依次输入每条边依附的两个顶点，确定这两个顶点的序号i和j之后，将此边结点分别插入vi和vj</p>
</li>
<li><p>对应的两个边链表的头部。如果是有向图，只需生成一个序号为j的边结点，插入到vj的边链表头。</p>
<p>  int CreateUDG(ALGraph &amp;G){<br>  &#x2F;&#x2F;采用邻接表表示法，创建无向图G<br>  cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum;				&#x2F;&#x2F;输入总顶点数，总边数<br>  for(int i &#x3D; 0; i &lt; G.vexnum; ++i){          	&#x2F;&#x2F;输入各点，构造表头结点表<br>  cin &gt;&gt; G.vertices[i].data;           	&#x2F;&#x2F;输入顶点值<br>  G.vertices[i].firstarc&#x3D;NULL;			&#x2F;&#x2F;初始化表头结点的指针域为NULL<br>  }&#x2F;&#x2F;for<br>  for(int k &#x3D; 0; k &lt; G.arcnum;++k){        		&#x2F;&#x2F;输入各边，构造邻接表<br>  VerTexType v1 , v2;<br>  int i , j;<br>  cin &gt;&gt; v1 &gt;&gt; v2;                 		&#x2F;&#x2F;输入一条边依附的两个顶点<br>  i &#x3D; LocateVex(G, v1);  j &#x3D; LocateVex(G, v2);<br>  &#x2F;&#x2F;确定v1和v2在G中位置，即顶点在G.vertices中的序号<br><br>  ArcNode <em>p1&#x3D;new ArcNode;               	&#x2F;&#x2F;生成一个新的边结点</em>p1<br>  p1-&gt;adjvex&#x3D;j;                   		&#x2F;&#x2F;邻接点序号为j<br>  p1-&gt;nextarc&#x3D; G.vertices[i].firstarc;  G.vertices[i].firstarc&#x3D;p1;<br>  &#x2F;&#x2F;将新结点<em>p1插入顶点vi的边表头部<br><br>  ArcNode <em>p2&#x3D;new ArcNode;                &#x2F;&#x2F;生成另一个对称的新的边结点</em>p2<br>  p2-&gt;adjvex&#x3D;i;                   		&#x2F;&#x2F;邻接点序号为i<br>  p2-&gt;nextarc&#x3D; G.vertices[j].firstarc;  G.vertices[j].firstarc&#x3D;p2;<br>  &#x2F;&#x2F;将新结点</em>p2插入顶点vj的边表头部<br>  }&#x2F;&#x2F;for<br>  return 1;<br>  }</p>
</li>
</ul>
<h2><span id="三-图的遍历">三、图的遍历</span></h2><h3><span id="1深度优先遍历">1.深度优先遍历</span></h3><p>设置变量。</p>
<p>图的遍历和树的遍历类似，即从图中某一顶点出发遍历图中其余顶点，且使每一个顶点仅被访问一次。<br>为了避免同一顶点被访问多次，在遍历图的过程中，必须记下每个已被访问过的顶点。为此，我们可以设一个辅助数组Visited[N]来标记某一顶点是否被访问过了，初始化为False。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool visited[MVNum];           					//访问标志数组，其初值为&quot;false&quot; </span><br><span class="line">int FirstAdjVex(Graph G , int v);				//返回v的第一个邻接点</span><br><span class="line">int NextAdjVex(Graph G , int v , int w);		//返回v相对于w的下一个邻接点</span><br></pre></td></tr></table></figure>

<p>类似于树的先序遍历。</p>
<ul>
<li>从图中某个顶点v出发，访问v，并置visited[v]的值为1；</li>
<li>依次检查v的所有邻接点w，如果visited[w]的值为0，再从w出发进行遍历，直到图中所有顶点都被遍历过。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 图的深度优先遍历</span><br><span class="line">void DFSTraverse(MGraph G) &#123;</span><br><span class="line">	int* visited = new int[G.vexnum]; // 访问标志数组</span><br><span class="line">	for (int i = 0; i &lt; G.vexnum; i++) visited[i] = 0; // 初始化未被访问</span><br><span class="line">	for (int i = 0; i &lt; G.vexnum; i++) &#123;</span><br><span class="line">		if (!visited[i]) DFS(G, i, visited); // 对尚未访问的顶点i调用DFS，</span><br><span class="line">											 // 因为图G可能不是连通图</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 从图中第v个顶点开始进行深度优先遍历</span><br><span class="line">void DFS(MGraph G, int v, int* visited) &#123;</span><br><span class="line">	visited[v] = 1; //先访问顶点v</span><br><span class="line">	cout &lt;&lt; G.vexs[v] &lt;&lt; &quot; &quot;;</span><br><span class="line">	for (int w = FirstAdjVex(G, G.vexs[v]); w &gt;= 0; w = NextAdjVex(G, G.vexs[v], G.vexs[w])) &#123;</span><br><span class="line">		if (!visited[w]) DFS(G, w, visited); // 对v的尚未访问的邻接顶点w递归调用DFS</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="2广度优先遍历">2.广度优先遍历</span></h3><p><strong>广度优先搜索（Broadth First Search）</strong> 类似于树层次遍历的过程，即以v为初始点，由近即远，一次访问和v有路径相通且路径长度为1，2，…的顶点。此过程可借助于<code>队列</code>实现。</p>
<ul>
<li>从图中某个顶点出发，访问v，并置visited[v]的值为1，然后v进队；</li>
<li>只要队列不空，则：</li>
<li>队头顶点u出队；</li>
<li>依次检查u的所有邻接点w，如果visited[w]为0，访问w，并置其值为1，w进队。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void BFSTraverse(MGraph G) &#123;</span><br><span class="line">// 按照广度优先非递归遍历图G，使用辅助队列Q和访问标志数组visited。</span><br><span class="line">	int* visited = new int[G.vexnum];</span><br><span class="line">	queue&lt;int&gt; Q;</span><br><span class="line">	int i;</span><br><span class="line">	for (i = 0; i &lt; G.vexnum; i++) visited[i] = 0;</span><br><span class="line">	for (i = 0; i &lt; G.vexnum; i++) &#123;</span><br><span class="line">		if (!visited[i]) &#123; //访问顶点i</span><br><span class="line">			visited[i] = 1;</span><br><span class="line">			cout &lt;&lt; G.vexs[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">			Q.push(i);</span><br><span class="line">			while (!Q.empty()) &#123;</span><br><span class="line">				int u = Q.front();</span><br><span class="line">				Q.pop(); //取出对头顶点</span><br><span class="line">				for (int w = FirstAdjVex(G, G.vexs[u]); w &gt;= 0; w = NextAdjVex(G, G.vexs[u], G.vexs[w])) &#123;</span><br><span class="line">					if (!visited[w]) &#123;  // w为u的尚未访问的邻接顶点</span><br><span class="line">						visited[w] = 1;</span><br><span class="line">						cout &lt;&lt; G.vexs[w] &lt;&lt; &quot; &quot;;</span><br><span class="line">						Q.push(w);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</div> 

<script>
    window.onload = detectors();
</script>
    <div class="post-footer">
    <div class="h-line-primary"></div>
    <nav class="post-nav">
        <div class="prev-item">
           
        </div>
        <div class="next-item">
            
                <div class="icon arrow-right"></div>
                <div class="post-link">
                  <a href="/2024/06/01/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/">Next</a>  
                </div>  
            
        </div>
    </nav>
</div>

    
      <div class="post-comment">

    
        <div id="vcomments"></div>
        <script>
            var META = ['nick', 'mail', 'link'];
            var meta = 'nick,mail';
            meta = meta.split(',').filter(item => {
                return META.includes(item);
            });
            new Valine({
                el: '#vcomments',
                appId: 'f131VXTFNbI57QRvg5lJFtbq-MdYXbMMI',
                appKey: 'd1GENolYcYpRMO2FbRRbarov',
                lang: 'zh-CN',
                placeholder: 'Say something',
                avatar: 'mp',
                meta: meta
            })
        </script>    
     

     
    
    

</div>
     
  
</article>
        </div>
      </div>
      
      <div class="footer">
    <div class="flex-container">
        <div class="footer-text">
            
            
            
                Powered by <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> & <a target="_blank" rel="noopener" href="https://github.com/zoeingwingkei/frame/">Frame</a>
                
        </div>
    </div>
</div>

    </div>

    
      <div class="search-popup">
    <div class="search-popup-overlay">  
    </div>
    <div class="search-popup-window" >
        <div class="search-header">
            <div class="search-input-container">
              <input autocomplete="off" autocapitalize="off" maxlength="80"
                     placeholder="Search Anything" spellcheck="false"
                     type="search" class="search-input">
            </div>
            <div class="search-close-btn">
                <div class="icon close-btn"></div>
            </div>
        </div>
        <div class="search-result-container">
        </div>
    </div>
</div>

<script>
    const searchConfig = {
        path             : "/search.xml",
        top_n_per_article: "1",
        unescape         : "false",
        trigger: "auto",
        preload: "false"
    }
</script>
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js"></script>
<script src="/js/search.js"></script>
    
    

  </body>
</html>
