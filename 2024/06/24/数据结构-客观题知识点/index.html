<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="John Doe">







<title>数据结构 客观题知识点 | Hexo</title>



    <link rel="icon" href="/favicon.ico">



<style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Sans+SC:wght@300;400;500;700&family=Roboto+Mono&display=swap');
</style>



    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    




    <!-- scripts list from _config.yml -->
    
    <script src="/js/menu.js"></script>
    







    <script src='https://unpkg.com/valine@1.4.16/dist/Valine.min.js'></script>




  <!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.1.1"></head>
  <body>
    <div class="mask-border">
    </div>

    <div class="wrapper">

      <div class="header">
  <div class="flex-container">
    <div class="header-inner">
      <div class="site-brand-container">
        <a href="/">
          
            首页
          
        </a>
      </div>
      <div id="menu-btn" class="menu-btn" onclick="toggleMenu()">
        Menu
      </div>
      <nav class="site-nav">
        <ul class="menu-list">
          
            
              <li class="menu-item">
                <a href="/">主页</a>
              </li> 
                   
          
            
              <li class="menu-item">
                <a href="/archives/">归档</a>
              </li> 
                   
          
            
              <li class="menu-item">
                <a href="/categories/gallery/">画廊</a>
              </li> 
                   
          
          
            <li class="menu-item search-btn">
              <a href="#">Search</a>
            </li>
          
        </ul>
      </nav>
    </div>
  </div>
</div>


      <div class="main">
        <div class="flex-container">
          <article id="post">

  
    <div class="post-head">
    <div class="post-info">
        <div class="tag-list">
            
                
                    <span class="post-tag">
                        <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/">
                            数据结构笔记
                        </a>
                    </span>    
                           
            
        </div>
        <div class="post-title">
            
            
                数据结构 客观题知识点
            
            
        </div>
        <span class="post-date">
            Jun 24, 2024
        </span>
    </div>
    <div class="post-img">
        
            <div class="h-line-primary"></div>
              
    </div>
</div>
    <div class="post-content">
    <!-- toc -->

<ul>
<li><a href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%BB%AA%E8%AE%BA">第一章 绪论</a></li>
<li><a href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%BA%BF%E6%80%A7%E8%A1%A8">第二章 线性表</a></li>
<li><a href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97">第三章 栈和队列</a></li>
<li><a href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%95%B0%E7%BB%84-%E5%B9%BF%E4%B9%89%E8%A1%A8-%E4%B8%B2">第四章 数组 广义表 串</a></li>
<li><a href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%9B%BE">第六章 图</a></li>
<li><a href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%9F%A5%E6%89%BE">第七章 查找</a></li>
<li><a href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%8E%92%E5%BA%8F">第八章 排序</a></li>
<li><a href="#%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A%E9%A2%98">名词解释题</a><ul>
<li><a href="#%E9%93%BE%E8%A1%A8%E5%92%8C%E9%A1%BA%E5%BA%8F%E8%A1%A8">链表和顺序表</a></li>
<li><a href="#%E9%82%BB%E6%8E%A5%E8%A1%A8%E5%92%8C%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5">邻接表和邻接矩阵</a></li>
<li><a href="#%E6%8E%92%E5%BA%8F">排序</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<p>[TOC]</p>
<h2><span id="第一章-绪论">第一章 绪论</span></h2><p>被计算机加工的数据元素不是孤立的，它们彼此之间一般存在某种关系，通常把数据元素之间的这种关系称为 <strong>结构</strong></p>
<p>数据结构涉及数据的逻辑结构、存储结构和施加其上的操作3个方面</p>
<p>数据结构操作的实现与存储结构有关</p>
<p>定义逻辑结构时可不考虑存储结构</p>
<p><strong>数据结构的逻辑结构独立于其存储结构</strong></p>
<p>数据逻辑结构可以分为集合结构、线性结构、树结构和图结构</p>
<p>从逻辑上可将数据结构分为线性结构和非线性结构，<strong>线性表、栈与队列、字符串、数组、广义表是线性结构，树、图、集合是非线性结构</strong></p>
<p>线性表——一对一</p>
<p>集合——松散</p>
<p>树——一对多</p>
<p>图——多对多</p>
<p>关于抽象数据类型的描述：数据封装、使用与实现分离、信息隐藏</p>
<p>算法的时间复杂度与（<strong>问题规模</strong> ）有关。</p>
<p>某算法的时间复杂度是<em>O</em>(<em>n</em>2)，表明该算法的<strong>执行时间与<em>n</em>2成正比</strong></p>
<p><strong>算法+数据结构&#x3D;程序</strong></p>
<p><strong>数据元素</strong>是数据的基本单位，在计算机中通常作为一个整体进行考虑和处理。</p>
<p><strong>数据项</strong>是数据结构讨论问题的最小单元</p>
<p>数据结构在计算机内存中的表示是指<strong>数据的存储结构</strong></p>
<p>数据结构是一门研究非数值计算的程序设计问题中计算机的( <strong>操作对象</strong>)以及它们之间的关系和操作的学科。</p>
<p>顺序存储结构的特点是借助元素在存储器中的相对位置来表示数据元素之间的逻辑关系。（逻辑上相邻的两个元素对应的物理地址也是相邻的）</p>
<p>链式存储结构的特点是借助指示元素存储地址的指针来表示数据元素之间的逻辑关系。</p>
<p>一个正确的算法应该具有 5 个特性：确定性、可行性、有穷性，有一个或多个输出，有零个或多个输入</p>
<p>数据结构中评价算法的两个重要指标是<strong>空间复杂度</strong>和<strong>时间复杂度</strong></p>
<h2><span id="第二章-线性表">第二章 线性表</span></h2><p>对于顺序存储的长度为<em>N</em>的线性表，访问结点和增加结点的时间复杂度分别对应为<em>O</em>(1)和<em>O</em>(<em>N</em>)。</p>
<p>顺序表是一种随机存取的存储结构。</p>
<p>顺序存储设计时，存储单元的地址一定连续。</p>
<p>若某线性表最常用的操作是存取任一指定序号的元素和在最后进行插入和删除运算，则利用顺序表存储最节省时间。</p>
<p>顺序存储结构的主要缺点是不利于插入或删除操作。</p>
<p>一个顺序表所占用的存储空间大小与(元素的存放顺序 )无关，和表的长度、元素的类型、元素中各字段的类型有关。</p>
<p>要将一个顺序表{<em>a</em>0,<em>a</em>1,……,<em>a**n</em>−1}中第i个数据元素<em>a**i</em>(0≤i≤n-1)删除，需要移动（<strong>n-i-1</strong> ）个数据元素。</p>
<p>若长度为n的线性表采用顺序存储结构，那么删除它的第i个数据元素<strong>之前</strong>，需要它一次向前移动（<strong>n-i+1</strong>）个数据元素。</p>
<p>若长度为n的线性表采用顺序结构，在第i个数据元素之前插入一个元素，需要它依次向后移动（n-i+1）个元素。</p>
<p><strong>线性表L&#x3D;（a1, a2 ,……，an ）用一维数组表示，假定删除线性表中任一元素的概率相同（都为1&#x2F;n），则删除一个元素平均需要移动元素的个数是（n-1）&#x2F;2。</strong></p>
<p><strong>等概率情况下，在表长为n的顺序表中插入一个元素所需移动的元素平均个数为n&#x2F;2</strong></p>
<p><strong>删除（n-1）&#x2F;2  ········查找（n+1）&#x2F;2·········· 插入n&#x2F;2</strong></p>
<p>非空线性表除终端结点外，每个结点都有唯一的后继结点。</p>
<p>链式存储的优点是插入、删除元素时不会引起后续元素的移动，缺点是只能顺序访问各元素。</p>
<p>在单链表中，增加一个头结点的最终目的是为了<strong>方便运算的实现</strong></p>
<p>将线性表La和Lb头尾连接，要求时间复杂度为O(1)，且占用辅助空间尽量小。应该使用哪种结构？<strong>带尾指针的单循环链表</strong></p>
<p>可以用带表头附加结点的链表表示线性表，也可以用不带头结点的链表表示线性表，前者最主要的好处是（<strong>使空表和非空表的处理统一</strong>）。</p>
<p>在单链表中，要删除某一指定结点，必须先找到该结点的<strong>直接前驱</strong>。</p>
<p>链表的存储密度小于 1</p>
<h2><span id="第三章-栈和队列">第三章 栈和队列</span></h2><p>堆栈和队列都是插入、删除受到约束的线性表</p>
<p>若采用带头、尾指针的单向链表表示一个堆栈，那么该堆栈的栈顶指针top应该如何设置？<strong>将链表头设为top</strong></p>
<p>栈st为空的判断条件为<strong>st.top &#x3D;&#x3D; st.base</strong></p>
<p>栈st为满的判断条件为<strong>st.top-st.base&gt;&#x3D; st.stacksize</strong></p>
<p>在一个链栈中,若栈顶指针等于NULL则为栈空</p>
<p>和顺序栈相比，链栈有一个比较明显的优势是<strong>通常不会出现栈满的情况</strong></p>
<p>栈和队列的共同点是只允许在端点处插入和删除元素</p>
<p>不论是入队列操作还是入栈操作,在顺序存储结构上都需要考虑”溢出”情况。</p>
<p>在少用一个元素空间的循环队列(m为最大队列长度)是满队列的条件**(rear+1)%m&#x3D;&#x3D;front**</p>
<p>缓冲区应该是一个(<strong>队列</strong> )结构</p>
<p>最不适合用作链队的链表是（）。<strong>只带队头指针的非循环双链表</strong></p>
<p>从一个顺序队列中删除元素时，<strong>首先要取出队首指针所指位置上的元素</strong></p>
<p>在一个顺序存储的循环队列中，若队尾指针指向队尾元素的后一个位置，则队头指针一般指向队头元素的（ ）。<strong>当前位置</strong></p>
<p>在一个顺序循环队列中，若队头指针指向队头元素的当前位置，则队尾指针一般指向队尾元素的（ ）位置。<strong>后一个</strong></p>
<p>一个递归算法必须包括终止条件和递归部分</p>
<p>一个递归的定义可以用递归过程求解，也可以用非递归过程求解，但单从运行时间来看， 通常递归过程比非递归过程<strong>较慢</strong></p>
<h2><span id="第四章-数组-广义表-串">第四章 数组 广义表 串</span></h2><p>广义表是一种（<strong>递归</strong>）数据结构。</p>
<p>若一个问题既可以用迭代方式也可以用递归方式求解，则（<strong>迭代</strong> ）的方法具有更髙的时空效率。</p>
<p>递归函数转换为非递归函数时，通常借助（<strong>栈</strong> ）数据结构</p>
<p>递归函数占用较多的存储空间</p>
<p>串既可以采用顺序存储，也可以采用链式存储</p>
<p>串的长度是指串中所含字符的个数</p>
<p>设有两个串p和q，其中q是p的子串，求q在p中首次出现的位置的算法称为（ <strong>模式匹配</strong>）。</p>
<p>串是一种特殊的线性表，其特殊性体现在（ 数据元素是一个字符）。</p>
<p>对特殊矩阵采用压缩存储的主要目的是(减少不必要的存储空间 )</p>
<p>对n阶对称矩阵压缩存储时，需要表长为（n(n+1)&#x2F;2　）的顺序表。</p>
<p>设主串的长度为n，子串的长度为m，那么BF算法的时间复杂度为（ ）。<strong>O(nxm)</strong></p>
<p>BF算法在最好情况下为O（n+m），最坏情况下为O（nxm）</p>
<p>KMP算法的最大特点是指示主串的指针不用回溯</p>
<h2><span id="第六章-图">第六章 图</span></h2><p>图的BFS生成树的树高比DFS生成树的树高（<strong>小或相等</strong>）</p>
<p>图的遍历是从给定的源点出发每一个顶点仅被访问一次</p>
<p>遍历的基本算法有两种：深度遍历和广度遍历</p>
<p>图的深度遍历是一个递归过程</p>
<p>图的深度优先遍历类似于二叉树的先序遍历，栈</p>
<p>在用邻接表表示有<em>N</em>个结点<em>E</em>条边的图时，深度优先遍历算法的时间复杂度为：<strong><em>O</em>(<em>N</em>+<em>E</em>)</strong></p>
<p>图的广度优先搜索遍历类似于二叉树的层次遍历</p>
<p>用邻接表表示图进行广度优先遍历时，通常借助（ 队列）来实现算法</p>
<p>如果从无向图的任一顶点出发进行一次深度优先搜索可访问所有顶点，则该图一定是连通图</p>
<p>下面（　<strong>Prim算法</strong>）算法适合构造一个稠密图G的最小生成树。</p>
<p>任何一个带权无向连通图的最小生成树——有可能不唯一</p>
<p>在求最小生成树时，Kruskal算法更适合于____。<strong>稀疏图</strong></p>
<p>数据结构中Dijkstra算法用来解决哪个问题？<strong>最短路径</strong></p>
<h2><span id="第七章-查找">第七章 查找</span></h2><p>对二叉搜索树进行什么遍历可以得到从小到大的排序序列？<strong>中序遍历</strong></p>
<p>对于一个数据序列，按照输入顺序建立一个二叉排序树，该二叉排序树的形状取决于（<strong>数据元素的输入次序</strong> ）</p>
<p>折半查找与二叉排序树的时间性能（ ）。有时不相同</p>
<p>如果要求一个线性表既能较快的查找，又能适应动态变化的要求，最好采用( <strong>分块查找</strong>)查找法。</p>
<p>通过设置哨兵从而不需要判断下标是否越界的是（逆向顺序查找 ）</p>
<p>设有一个已排序的线性表（长度&gt;&#x3D;２），分别用顺序查找法和二分查找法找一个与K相等的元素，比较的次数分别是S和B，在查找不成功的情况下，S和B的关系是（S&gt;&#x3D;B）。</p>
<p>对线性表进行二分查找时，要求线性表必须( )<strong>以顺序方式存储，且结点按关键字有序排序</strong></p>
<h2><span id="第八章-排序">第八章 排序</span></h2><p>对n个不同的关键字由小到大进行冒泡排序,在下列( )情况下比较的次数最多.<strong>从大到小排序好的</strong></p>
<p>在最好和最坏情况下的时间复杂度均为O(nlogn)且稳定的排序方法是( <strong>归并排序</strong>).</p>
<p>从未排序的序列中依次取出一个元素与已排序序列中的元素进行比较,然后将其放在已排序序列的合适位置上,该排序方法称为<strong>插入排序</strong></p>
<p>下列排序算法中，不稳定的是<strong>希尔排序快速排序堆排序</strong></p>
<p>下列排序算法中，占用辅助空间最多的是（归并排序 ）</p>
<p>如果原始数据已有序，那么，使用<strong>直接插入</strong>排序算法最快。</p>
<h2><span id="名词解释题">名词解释题</span></h2><h3><span id="链表和顺序表">链表和顺序表</span></h3><h4><span id="顺序表">顺序表</span></h4><p>优点：便于随机存取，存取速度快，便利了查找和修改元素；存储密度大，利用效率高</p>
<p>缺点：占用了连续一大块的存储空间，容易浪费；不方便插入和删除元素</p>
<h4><span id="链表">链表</span></h4><p>优点：方便插入和删除元素；存储空间分配灵活，逻辑存储，不要求物理地址相邻<br>缺点：存储密度小，利用效率不高；不方便存取元素</p>
<h3><span id="邻接表和邻接矩阵">邻接表和邻接矩阵</span></h3><p>一个图的邻接矩阵表示是唯一的，而邻接表表示不唯一</p>
<h4><span id="邻接表one">邻接表（O(n+e)）</span></h4><p>优点：便于增加和删除顶点；便于统计边的数目；空间效率高</p>
<p>缺点：不便于判断两个顶点是否有边；不便于计算各个顶点的度</p>
<h4><span id="邻接矩阵on2">邻接矩阵（O(n²)）</span></h4><p>优点：便于判断两个顶点是否有边；便于计算各个顶点的度</p>
<p>缺点：不便于增加和删除顶点；不便于统计边的数目；空间复杂度高</p>
<h3><span id="排序">排序</span></h3><p>直接插入排序：和打扑克牌一样，把未排序的部分按序取出一个元素插入到已经排序好的有序序列中，插入位置从前往后找。时间复杂度O(n^2),空间复杂度O(1)</p>
<p>希尔排序：分组直接插入排序，将排序元素按增量序列分为几组，组内直接插入排序，缩减增量，使得元素基本有序，在进行一次直接插入排序。时间复杂度O(nlog2 n)，空间复杂度O(1)</p>
<p>冒泡排序：比较相邻元素的值。时间复杂度O(n^2),空间复杂度O(1)</p>
<p>快速排序：从左到右的元素都能一次性找到自己最终位置。piovt基准，low,high。时间复杂度O(nlog2 n),空间复杂度O(log2 n)</p>
<p>直接选择排序：在给定的一组记录中选择最小的和第一个记录交换，然后从第二个记录到最后记录中找最小的和第二个记录交换，如此下去。方式可选小放前面、选大放后面。时间复杂度O(n^2),空间复杂度O(1)</p>
<p>堆排序：大根堆、小根堆。时间复杂度O(nlon2 n),空间复杂度O(1)</p>
<p>二路归并排序：两两归并，排序成一个个有序序列。时间复杂度O(nlog2 n),空间复杂度O(n)</p>
<p>基数排序：实现方法为最高位优先、最低为优先。利用辅助队列按位收集和分配。时间复杂度O(n),空间复杂度O(r )</p>

</div> 

<script>
    window.onload = detectors();
</script>
    <div class="post-footer">
    <div class="h-line-primary"></div>
    <nav class="post-nav">
        <div class="prev-item">
           
                <div class="icon arrow-left"></div>
                <div class="post-link">
                    <a href="/2024/06/29/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1-%E7%AC%94%E8%AE%B0/">Prev</a>
                </div>
            
        </div>
        <div class="next-item">
            
                <div class="icon arrow-right"></div>
                <div class="post-link">
                  <a href="/2024/06/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%BB%E8%A7%82%E9%A2%98%E6%B1%87%E6%80%BB/">Next</a>  
                </div>  
            
        </div>
    </nav>
</div>

    
      <div class="post-comment">

    
        <div id="vcomments"></div>
        <script>
            var META = ['nick', 'mail', 'link'];
            var meta = 'nick,mail';
            meta = meta.split(',').filter(item => {
                return META.includes(item);
            });
            new Valine({
                el: '#vcomments',
                appId: 'f131VXTFNbI57QRvg5lJFtbq-MdYXbMMI',
                appKey: 'd1GENolYcYpRMO2FbRRbarov',
                lang: 'zh-CN',
                placeholder: 'Say something',
                avatar: 'mp',
                meta: meta
            })
        </script>    
     

     
    
    

</div>
     
  
</article>
        </div>
      </div>
      
      <div class="footer">
    <div class="flex-container">
        <div class="footer-text">
            
            
            
                Powered by <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> & <a target="_blank" rel="noopener" href="https://github.com/zoeingwingkei/frame/">Frame</a>
                
        </div>
    </div>
</div>

    </div>

    
      <div class="search-popup">
    <div class="search-popup-overlay">  
    </div>
    <div class="search-popup-window" >
        <div class="search-header">
            <div class="search-input-container">
              <input autocomplete="off" autocapitalize="off" maxlength="80"
                     placeholder="Search Anything" spellcheck="false"
                     type="search" class="search-input">
            </div>
            <div class="search-close-btn">
                <div class="icon close-btn"></div>
            </div>
        </div>
        <div class="search-result-container">
        </div>
    </div>
</div>

<script>
    const searchConfig = {
        path             : "/search.xml",
        top_n_per_article: "1",
        unescape         : "false",
        trigger: "auto",
        preload: "false"
    }
</script>
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js"></script>
<script src="/js/search.js"></script>
    
    

  </body>
</html>
